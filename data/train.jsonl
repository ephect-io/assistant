{"instruction": "Write an Ephect PHP component", "input": "Based on Ephect source: bootstrap.php", "output": "<?php\n\nuse Ephect\\Framework\\Core\\Autoloader;\nuse Ephect\\Framework\\Modules\\ModuleInstaller;\nuse Ephect\\Framework\\Plugins\\PluginInstaller;\nuse Ephect\\Framework\\Registry\\FrameworkRegistry;\nuse Ephect\\Framework\\Registry\\HooksRegistry;\n\n//define('DIRECTORY_SEPARATOR', Phar::running() ? '_' : DIRECTORY_SEPARATOR);\ndefine('FRAMEWORK_PATH', dirname(__FILE__) . DIRECTORY_SEPARATOR . 'Framework' . DIRECTORY_SEPARATOR);\ndefine('HOOKS_DIR', 'Hooks' . DIRECTORY_SEPARATOR);\n\ninclude  dirname(__FILE__) . DIRECTORY_SEPARATOR . 'constants.php';\n\ninclude  dirname(__FILE__) . DIRECTORY_SEPARATOR . 'constants_utils.php';\n\ninclude FRAMEWORK_PATH . 'Utils' . DIRECTORY_SEPARATOR . 'File.php';\ninclude FRAMEWORK_PATH . 'Utils' . DIRECTORY_SEPARATOR . 'Text.php';\ninclude FRAMEWORK_PATH . 'ElementTrait.php';\ninclude FRAMEWORK_PATH . 'ElementUtils.php';\ninclude FRAMEWORK_PATH . 'Registry' . DIRECTORY_SEPARATOR . 'RegistryInterface.php';\ninclude FRAMEWORK_PATH . 'Registry' . DIRECTORY_SEPARATOR . 'StaticRegistryInterface.php';\ninclude FRAMEWORK_PATH . 'Registry' . DIRECTORY_SEPARATOR . 'AbstractRegistry.php';\ninclude FRAMEWORK_PATH . 'Registry' . DIRECTORY_SEPARATOR . 'StaticRegistryTrait.php';\ninclude FRAMEWORK_PATH . 'Registry' . DIRECTORY_SEPARATOR . 'AbstractStaticRegistry.php';\ninclude FRAMEWORK_PATH . 'Registry' . DIRECTORY_SEPARATOR . 'FrameworkRegistry.php';\ninclude FRAMEWORK_PATH . 'Registry' . DIRECTORY_SEPARATOR . 'HooksRegistry.php';\ninclude FRAMEWORK_PATH . 'Registry' . DIRECTORY_SEPARATOR . 'AbstractStateRegistry.php';\ninclude FRAMEWORK_PATH . 'Registry' . DIRECTORY_SEPARATOR . 'StateRegistry.php';\ninclude FRAMEWORK_PATH . 'Modules' . DIRECTORY_SEPARATOR . 'ModuleInstaller.php';\ninclude FRAMEWORK_PATH . 'Plugins' . DIRECTORY_SEPARATOR . 'PluginInstaller.php';\n\nHooksRegistry::register();\nif(file_exists(\\Constants::CUSTOM_HOOKS_ROOT) && is_dir(\\Constants::CUSTOM_HOOKS_ROOT)) {\n    HooksRegistry::register(\\Constants::CUSTOM_HOOKS_ROOT);\n}\nHooksRegistry::load();\n\nFrameworkRegistry::register();\nif (!\\Constants::CONFIG_AUTOLOAD) {\n    include FRAMEWORK_PATH . 'Logger' . DIRECTORY_SEPARATOR . 'Logger.php';\n    include FRAMEWORK_PATH . 'Core' . DIRECTORY_SEPARATOR . 'Autoloader.php';\n    Autoloader::register();\n}\n\nModuleInstaller::findAllAndInitialize();\nPluginInstaller::loadBootstraps();\n\nHooksRegistry::load();"}
{"instruction": "Write an Ephect component", "input": "Based on Ephect source: constants.php", "output": "<?php\n\n$document_root = isset($_SERVER['DOCUMENT_ROOT']) && !empty($_SERVER['DOCUMENT_ROOT']) ? $_SERVER['DOCUMENT_ROOT'] . DIRECTORY_SEPARATOR : '';\n\ndefine('DONT_USE_IS_WEB_APP', $document_root !== '');\ndefine('DONT_USE_IS_PHAR_APP', (Phar::running() !== ''));\ndefine('DONT_USE_IS_CLI_APP', (Phar::running() === '') && !DONT_USE_IS_WEB_APP);\nconst DONT_USE_REL_CONFIG_DIR = 'config' . DIRECTORY_SEPARATOR;\nconst DONT_USE_REL_CONFIG_APP = 'app';\n\nif (DONT_USE_IS_WEB_APP) {\n    define('DONT_USE_DOCUMENT_ROOT', $document_root);\n\n    $site_root = dirname(DONT_USE_DOCUMENT_ROOT) . DIRECTORY_SEPARATOR;\n\n    define('DONT_USE_SITE_ROOT', $site_root);\n    define('DONT_USE_CONFIG_DIR', DONT_USE_SITE_ROOT . DONT_USE_REL_CONFIG_DIR);\n    define(\n        'DONT_USE_CONFIG_FRAMEWORK',\n        file_exists(DONT_USE_CONFIG_DIR . 'framework')\n            ? trim(file_get_contents(DONT_USE_CONFIG_DIR . 'framework'))\n            : 'vendor/ephect-io/framework/Ephect'\n    );\n    define(\n        'DONT_USE_CONFIG_APP',\n        file_exists(DONT_USE_CONFIG_DIR . DONT_USE_REL_CONFIG_APP)\n            ? trim(file_get_contents(DONT_USE_CONFIG_DIR . DONT_USE_REL_CONFIG_APP))\n            : DONT_USE_REL_CONFIG_APP\n    );\n    define('DONT_USE_SRC_ROOT', DONT_USE_SITE_ROOT . DONT_USE_CONFIG_APP . DIRECTORY_SEPARATOR);\n\n    define('DONT_USE_AJIL_CONFIG', trim(file_get_contents(DONT_USE_CONFIG_DIR . 'javascripts')));\n    define('DONT_USE_EPHECT_ROOT', DONT_USE_SITE_ROOT . DONT_USE_CONFIG_FRAMEWORK . DIRECTORY_SEPARATOR);\n    define('DONT_USE_AJIL_ROOT', DONT_USE_SITE_ROOT . DONT_USE_AJIL_CONFIG . DIRECTORY_SEPARATOR);\n\n    $appname = pathinfo(DONT_USE_SITE_ROOT, PATHINFO_FILENAME);\n    define('DONT_USE_APP_NAME', $appname);\n\n    define('DONT_USE_AJIL_VENDOR_SRC', DONT_USE_AJIL_ROOT);\n    define('DONT_USE_EPHECT_VENDOR_SRC', DONT_USE_EPHECT_ROOT);\n    define('DONT_USE_EPHECT_VENDOR_LIB', DONT_USE_EPHECT_VENDOR_SRC . 'Framework' . DIRECTORY_SEPARATOR);\n    define('DONT_USE_EPHECT_VENDOR_APPS', DONT_USE_EPHECT_VENDOR_SRC . 'Apps' . DIRECTORY_SEPARATOR);\n\n    $rewrite_base = '/';\n\n    if (file_exists(DONT_USE_CONFIG_DIR . 'rewrite_base') && $rewrite_base = file_get_contents(DONT_USE_CONFIG_DIR . 'rewrite_base')) {\n        $rewrite_base = trim($rewrite_base);\n    }\n    define('DONT_USE_REWRITE_BASE', $rewrite_base);\n\n    $scheme = 'http';\n    if (str_contains($_SERVER['SERVER_SOFTWARE'], 'IIS')) {\n        $scheme = ($_SERVER['HTTPS'] == 'off') ? 'http' : 'https';\n    } elseif (str_contains($_SERVER['SERVER_SOFTWARE'], 'Apache')) {\n        $scheme = $_SERVER['REQUEST_SCHEME'];\n    } elseif (str_contains($_SERVER['SERVER_SOFTWARE'], 'lighttpd')) {\n        $scheme = str_contains($_SERVER['SERVER_PROTOCOL'], 'HTPPS') ? 'https' : 'http';\n    } elseif (str_contains($_SERVER['SERVER_SOFTWARE'], 'nginx')) {\n        $scheme = str_contains($_SERVER['SERVER_PROTOCOL'], 'HTPPS') ? 'https' : 'http';\n    }\n\n    define('DONT_USE_HTTP_PROTOCOL', $scheme);\n    define('DONT_USE_HTTP_USER_AGENT', $_SERVER['HTTP_USER_AGENT'] ?? '');\n    define('DONT_USE_HTTP_HOST', $_SERVER['HTTP_HOST']);\n    define('DONT_USE_HTTP_ORIGIN', $_SERVER['HTTP_ORIGIN'] ?? '');\n    define('DONT_USE_HTTP_ACCEPT', $_SERVER['HTTP_ACCEPT'] ?: '');\n    define('DONT_USE_HTTP_PORT', $_SERVER['SERVER_PORT']);\n    define('DONT_USE_COOKIE', $_COOKIE);\n    define('DONT_USE_REQUEST_URI', $_SERVER['REQUEST_URI']);\n    define('DONT_USE_REQUEST_METHOD', $_SERVER['REQUEST_METHOD']);\n    define('DONT_USE_QUERY_STRING', parse_url(DONT_USE_REQUEST_URI, PHP_URL_QUERY) ?: '');\n    define('DONT_USE_SERVER_NAME', $_SERVER['SERVER_NAME']);\n    define('DONT_USE_SERVER_HOST', DONT_USE_HTTP_PROTOCOL . '://' . DONT_USE_HTTP_HOST);\n    define('DONT_USE_SERVER_ROOT', DONT_USE_HTTP_PROTOCOL . '://' . DONT_USE_SERVER_NAME . ((DONT_USE_HTTP_PORT !== '80' && DONT_USE_HTTP_PORT !== '443') ? ':' . DONT_USE_HTTP_PORT : ''));\n    define('DONT_USE_BASE_URI', DONT_USE_SERVER_NAME . ((DONT_USE_HTTP_PORT !== '80') ? ':' . DONT_USE_HTTP_PORT : '') . ((DONT_USE_REQUEST_URI !== '') ? DONT_USE_REQUEST_URI : ''));\n    define('DONT_USE_FULL_URI', DONT_USE_HTTP_PROTOCOL . '://' . DONT_USE_BASE_URI);\n    define('DONT_USE_FULL_SSL_URI', 'https://' . DONT_USE_BASE_URI);\n\n    /**\n     * TO BE TESTED ON SUBDIRECTORY\n     */\n    // $hostPort = explode(':', DONT_USE_HTTP_HOST);\n    // $is127 = (($host = array_shift($hostPort) . (isset($hostPort[1]) ? $port = ':' . $hostPort[1] : $port = '') == '127.0.0.1' . $port) ? $hostname = 'localhost' : $hostname = $host) !== $host;\n    // $isIndex = (((strpos(DONT_USE_REQUEST_URI, 'index.php')  > -1) ? $requestUri = str_replace('index.php', '', DONT_USE_REQUEST_URI) : $requestUri = DONT_USE_REQUEST_URI) !== DONT_USE_REQUEST_URI);\n\n    // if ($is127 || $isIndex) {\n    //     header('Location: //' . $hostname . $port . $requestUri);\n    //     exit(302);\n    // }\n    /**\n     * END\n     */\n}\n\nif (!DONT_USE_IS_WEB_APP) {\n    $site_root = (getcwd() ? getcwd() : __DIR__) . DIRECTORY_SEPARATOR;\n\n    [$app_path] = get_included_files();\n    $script_name = pathinfo($app_path, PATHINFO_BASENAME);\n    $script_dir = pathinfo($app_path, PATHINFO_DIRNAME);\n    $appName = pathinfo($script_name)['filename'];\n    $script_root = $script_dir . DIRECTORY_SEPARATOR;\n\n    define('DONT_USE_APP_CWD', str_replace($script_name, '', $app_path));\n    define('DONT_USE_SITE_ROOT', $script_root);\n\n    define('DONT_USE_CONFIG_DIR', DONT_USE_SITE_ROOT . 'config' . DIRECTORY_SEPARATOR);\n    define('DONT_USE_CONFIG_FRAMEWORK', file_exists(DONT_USE_CONFIG_DIR . 'framework') ? trim(file_get_contents(DONT_USE_CONFIG_DIR . 'framework')) : 'vendor/ephect-io/framework/Ephect');\n    define('DONT_USE_EPHECT_ROOT', DONT_USE_SITE_ROOT . DONT_USE_CONFIG_FRAMEWORK . DIRECTORY_SEPARATOR);\n    define('DONT_USE_CONFIG_APP', file_exists(DONT_USE_CONFIG_DIR . 'app') ? trim(file_get_contents(DONT_USE_CONFIG_DIR . 'app')) : 'app');\n    define('DONT_USE_SRC_ROOT', $script_root . DONT_USE_CONFIG_APP . DIRECTORY_SEPARATOR);\n\n    $vendor_dir = 'vendor' . DIRECTORY_SEPARATOR . 'ephect-io' . DIRECTORY_SEPARATOR;\n    $portable_dir = 'Epehct' . DIRECTORY_SEPARATOR;\n    $bootstrap = 'bootstrap.php';\n\n    $ephect_dir = $vendor_dir . 'framework' . DIRECTORY_SEPARATOR . 'Ephect' . DIRECTORY_SEPARATOR;\n    $ajil_dir = $vendor_dir . 'javascripts' . DIRECTORY_SEPARATOR . 'Ajil' . DIRECTORY_SEPARATOR;\n    $ephect_vendor_lib = '';\n    $ephect_vendor_apps = '';\n\n    define('DONT_USE_APP_NAME', $appName);\n\n    $ephect_root = Phar::running();\n\n    if (file_exists(DONT_USE_SITE_ROOT . $portable_dir . $bootstrap)) {\n        $ephect_dir = $portable_dir;\n    }\n    $ephect_vendor_lib = $ephect_dir . 'Framework' . DIRECTORY_SEPARATOR;\n    $ephect_vendor_apps = $ephect_dir . 'Apps' . DIRECTORY_SEPARATOR;\n\n    $ephect_root = DONT_USE_SITE_ROOT . $ephect_vendor_lib;\n\n    define('DONT_USE_EPHECT_VENDOR_SRC', $ephect_dir);\n    define('DONT_USE_AJIL_VENDOR_SRC', $ajil_dir);\n    define('DONT_USE_EPHECT_VENDOR_LIB', $ephect_vendor_lib);\n    define('DONT_USE_EPHECT_VENDOR_APPS', $ephect_vendor_apps);\n\n    define('DONT_USE_EPHECT_APPS_ROOT', DONT_USE_SITE_ROOT . DONT_USE_EPHECT_VENDOR_APPS);\n\n    define('DONT_USE_REQUEST_URI', 'https://localhost/');\n    define('DONT_USE_REQUEST_METHOD', 'GET');\n    define('DONT_USE_QUERY_STRING', parse_url(DONT_USE_REQUEST_URI, PHP_URL_QUERY));\n\n    define('DONT_USE_AJIL_ROOT', DONT_USE_SITE_ROOT . DONT_USE_AJIL_VENDOR_SRC);\n}\n\ndefine(\n    'DONT_USE_CONFIG_DOCROOT',\n    file_exists(DONT_USE_CONFIG_DIR . 'document_root')\n        ? trim(file_get_contents(DONT_USE_CONFIG_DIR . 'document_root'))\n        : 'public'\n);\ndefine(\n    'DONT_USE_CONFIG_HOSTNAME',\n    file_exists(DONT_USE_CONFIG_DIR . 'hostname')\n        ? trim(file_get_contents(DONT_USE_CONFIG_DIR . 'hostname'))\n        : 'localhost'\n);\ndefine(\n    'DONT_USE_CONFIG_NAMESPACE',\n    file_exists(DONT_USE_CONFIG_DIR . 'namespace')\n        ? trim(file_get_contents(DONT_USE_CONFIG_DIR . 'namespace'))\n        : DONT_USE_APP_NAME\n);\ndefine(\n    'DONT_USE_CONFIG_COMMANDS',\n    file_exists(DONT_USE_CONFIG_DIR . 'commands')\n        ? trim(file_get_contents(DONT_USE_CONFIG_DIR . 'commands'))\n        : 'Commands'\n);\ndefine(\n    'DONT_USE_CONFIG_PAGES',\n    file_exists(DONT_USE_CONFIG_DIR . 'pages')\n        ? trim(file_get_contents(DONT_USE_CONFIG_DIR . 'pages'))\n        : 'Pages'\n);\ndefine(\n    'DONT_USE_CONFIG_LIBRARY',\n    file_exists(DONT_USE_CONFIG_DIR . 'library')\n        ? trim(file_get_contents(DONT_USE_CONFIG_DIR . 'library'))\n        : 'Library'\n);\ndefine(\n    'DONT_USE_CONFIG_COMPONENTS',\n    file_exists(DONT_USE_CONFIG_DIR . 'components')\n        ? trim(file_get_contents(DONT_USE_CONFIG_DIR . 'components'))\n        : 'Components'\n);\ndefine(\n    'DONT_USE_CONFIG_HOOKS',\n    file_exists(DONT_USE_CONFIG_DIR . 'hooks')\n        ? trim(file_get_contents(DONT_USE_CONFIG_DIR . 'hooks'))\n        : 'Hooks'\n);\n\ndefine(\n    'DONT_USE_CONFIG_AUTOLOAD',\n    file_exists(DONT_USE_CONFIG_DIR . 'autoload')\n        ? (trim(file_get_contents(DONT_USE_CONFIG_DIR . 'autoload')) == 'true') \n        : false\n);\n\nif (!DONT_USE_IS_WEB_APP) {\n    define('DONT_USE_DOCUMENT_ROOT', DONT_USE_SITE_ROOT . DONT_USE_CONFIG_DOCROOT . DIRECTORY_SEPARATOR);\n}\n\nclass Constants\n{\n    public const REL_CONFIG_DIR = DONT_USE_REL_CONFIG_DIR;\n    public const REL_CONFIG_APP = DONT_USE_REL_CONFIG_APP;\n    public const IS_WEB_APP = DONT_USE_IS_WEB_APP;\n    public const IS_PHAR_APP = DONT_USE_IS_PHAR_APP;\n    public const IS_CLI_APP = DONT_USE_IS_CLI_APP;\n    public const DOCUMENT_ROOT = DONT_USE_DOCUMENT_ROOT;\n    public const SITE_ROOT = DONT_USE_SITE_ROOT;\n    public const CONFIG_DIR = DONT_USE_CONFIG_DIR;\n    public const CONFIG_FRAMEWORK = DONT_USE_CONFIG_FRAMEWORK;\n    public const CONFIG_APP = DONT_USE_CONFIG_APP;\n    public const SRC_ROOT = DONT_USE_SRC_ROOT;\n    public const AJIL_CONFIG = DONT_USE_AJIL_CONFIG;\n    public const EPHECT_ROOT = DONT_USE_EPHECT_ROOT;\n    public const AJIL_ROOT = DONT_USE_AJIL_ROOT;\n    public const APP_NAME = DONT_USE_APP_NAME;\n    public const AJIL_VENDOR_SRC = DONT_USE_AJIL_VENDOR_SRC;\n    public const EPHECT_VENDOR_SRC = DONT_USE_EPHECT_VENDOR_SRC;\n    public const EPHECT_VENDOR_LIB = DONT_USE_EPHECT_VENDOR_LIB;\n    public const EPHECT_VENDOR_APPS = DONT_USE_EPHECT_VENDOR_APPS;\n    public const REWRITE_BASE = DONT_USE_REWRITE_BASE;\n    public const HTTP_PROTOCOL = DONT_USE_HTTP_PROTOCOL;\n    public const HTTP_USER_AGENT = DONT_USE_HTTP_USER_AGENT;\n    public const HTTP_HOST = DONT_USE_HTTP_HOST;\n    public const HTTP_ORIGIN = DONT_USE_HTTP_ORIGIN;\n    public const HTTP_ACCEPT = DONT_USE_HTTP_ACCEPT;\n    public const HTTP_PORT = DONT_USE_HTTP_PORT;\n    public const COOKIE = DONT_USE_COOKIE;\n    public const REQUEST_URI = DONT_USE_REQUEST_URI;\n    public const REQUEST_METHOD = DONT_USE_REQUEST_METHOD;\n    public const QUERY_STRING = DONT_USE_QUERY_STRING;\n    public const SERVER_NAME = DONT_USE_SERVER_NAME;\n    public const SERVER_HOST = DONT_USE_SERVER_HOST;\n    public const SERVER_ROOT = DONT_USE_SERVER_ROOT;\n    public const BASE_URI = DONT_USE_BASE_URI;\n    public const FULL_URI = DONT_USE_FULL_URI;\n    public const FULL_SSL_URI = DONT_USE_FULL_SSL_URI;\n    public const APP_CWD = DONT_USE_APP_CWD;\n    public const EPHECT_APPS_ROOT = DONT_USE_EPHECT_APPS_ROOT;\n    public const CONFIG_DOCROOT = DONT_USE_CONFIG_DOCROOT;\n    public const CONFIG_HOSTNAME = DONT_USE_CONFIG_HOSTNAME;\n    public const CONFIG_NAMESPACE = DONT_USE_CONFIG_NAMESPACE;\n    public const CONFIG_COMMANDS = DONT_USE_CONFIG_COMMANDS;\n    public const CONFIG_PAGES = DONT_USE_CONFIG_PAGES;\n    public const CONFIG_LIBRARY = DONT_USE_CONFIG_LIBRARY;\n    public const CONFIG_COMPONENTS = DONT_USE_CONFIG_COMPONENTS;\n    public const CONFIG_HOOKS = DONT_USE_CONFIG_HOOKS;\n    public const CONFIG_AUTOLOAD = DONT_USE_CONFIG_AUTOLOAD;\n    public const REL_RUNTIME_JS_DIR = 'js' . DIRECTORY_SEPARATOR . 'runtime' . DIRECTORY_SEPARATOR;\n    public const REL_RUNTIME_CSS_DIR = 'css' . DIRECTORY_SEPARATOR . 'runtime' . DIRECTORY_SEPARATOR;\n    public const RUNTIME_JS_DIR = DONT_USE_DOCUMENT_ROOT . self::REL_RUNTIME_JS_DIR;\n    public const RUNTIME_CSS_DIR = DONT_USE_DOCUMENT_ROOT . self::REL_RUNTIME_CSS_DIR;\n\n\n    public const EPHECT_VENDOR_WIDGETS = DONT_USE_EPHECT_VENDOR_SRC . 'Widgets' . DIRECTORY_SEPARATOR;\n    public const EPHECT_VENDOR_PLUGINS = DONT_USE_EPHECT_VENDOR_SRC . 'Modules' . DIRECTORY_SEPARATOR;\n    public const EPHECT_WIDGETS_ROOT = DONT_USE_SITE_ROOT . self::EPHECT_VENDOR_WIDGETS;\n    public const EPHECT_PLUGINS_ROOT = DONT_USE_SITE_ROOT . self::EPHECT_VENDOR_PLUGINS;\n\n    public const APP_DIR = DONT_USE_CONFIG_APP . DIRECTORY_SEPARATOR;\n    public const APP_ROOT = DONT_USE_SRC_ROOT;\n    public const APP_SCRIPTS = self::APP_ROOT . 'scripts' . DIRECTORY_SEPARATOR;\n    public const APP_CLIENT = self::APP_ROOT . 'client' . DIRECTORY_SEPARATOR;\n    public const APP_DATA = DONT_USE_SITE_ROOT . 'data' . DIRECTORY_SEPARATOR;\n    public const APP_BUSINESS = self::APP_ROOT . 'business' . DIRECTORY_SEPARATOR;\n    public const CONTROLLER_ROOT = self::APP_ROOT . 'controllers' . DIRECTORY_SEPARATOR;\n    public const BUSINESS_ROOT = self::APP_ROOT . 'business' . DIRECTORY_SEPARATOR;\n    public const MODEL_ROOT = self::APP_ROOT . 'models' . DIRECTORY_SEPARATOR;\n    public const REST_ROOT = self::APP_ROOT . 'rest' . DIRECTORY_SEPARATOR;\n\n    public const VIEW_ROOT = self::APP_ROOT . 'views' . DIRECTORY_SEPARATOR;\n\n    public const REL_RUNTIME_DIR = 'runtime' . DIRECTORY_SEPARATOR;\n    public const RUNTIME_DIR = DONT_USE_SITE_ROOT . self::REL_RUNTIME_DIR;\n    public const REL_CACHE_DIR = 'cache' . DIRECTORY_SEPARATOR;\n    public const CACHE_DIR = DONT_USE_SITE_ROOT . self::REL_CACHE_DIR;\n    public const REL_BUILD_DIR = 'build' . DIRECTORY_SEPARATOR;\n    public const BUILD_DIR = self::CACHE_DIR . self::REL_BUILD_DIR;\n    public const REL_STATIC_DIR = 'static' . DIRECTORY_SEPARATOR;\n    public const STATIC_DIR = self::CACHE_DIR . self::REL_STATIC_DIR;\n    public const REL_STORE_DIR = 'store' . DIRECTORY_SEPARATOR;\n    public const STORE_DIR = self::CACHE_DIR . self::REL_STORE_DIR;\n    public const REL_COPY_DIR = 'copy' . DIRECTORY_SEPARATOR;\n    public const COPY_DIR = self::CACHE_DIR . self::REL_COPY_DIR;\n    public const REL_UNIQUE_DIR = 'unique' . DIRECTORY_SEPARATOR;\n    public const UNIQUE_DIR = self::CACHE_DIR . self::REL_UNIQUE_DIR;\n    public const LOG_PATH = DONT_USE_SITE_ROOT . 'logs' . DIRECTORY_SEPARATOR;\n    public const INFO_LOG = self::LOG_PATH . 'info.log';\n    public const DEBUG_LOG = self::LOG_PATH . 'debug.log';\n    public const ERROR_LOG = self::LOG_PATH . 'error.log';\n    public const SQL_LOG = self::LOG_PATH . 'sql.log';\n    public const ROUTES_JSON = self::RUNTIME_DIR . 'routes.json';\n    public const FRAMEWORK_ROOT = DONT_USE_EPHECT_ROOT . 'Framework' . DIRECTORY_SEPARATOR;\n    public const HOOKS_DIR = 'Hooks';\n    public const HOOKS_ROOT = DONT_USE_EPHECT_ROOT . self::HOOKS_DIR . DIRECTORY_SEPARATOR;\n    public const PLUGINS_ROOT = DONT_USE_EPHECT_ROOT . 'Plugins' . DIRECTORY_SEPARATOR;\n    public const COMMANDS_ROOT = DONT_USE_EPHECT_ROOT . 'Commands' . DIRECTORY_SEPARATOR;\n    public const CUSTOM_COMMANDS_ROOT = DONT_USE_SRC_ROOT . DONT_USE_CONFIG_COMMANDS . DIRECTORY_SEPARATOR;\n    public const CUSTOM_PAGES_ROOT = DONT_USE_SRC_ROOT . DONT_USE_CONFIG_PAGES . DIRECTORY_SEPARATOR;\n    public const CUSTOM_COMPONENTS_ROOT = DONT_USE_SRC_ROOT . DONT_USE_CONFIG_COMPONENTS . DIRECTORY_SEPARATOR;\n    public const CUSTOM_HOOKS_ROOT = DONT_USE_SRC_ROOT . DONT_USE_CONFIG_HOOKS . DIRECTORY_SEPARATOR;\n\n    public const CLASS_EXTENSION = '.class.php';\n    public const HTML_EXTENSION = '.html';\n    public const PREHTML_EXTENSION = '.phtml';\n    public const CSS_EXTENSION = '.css';\n    public const JS_EXTENSION = '.js';\n    public const JSON_EXTENSION = '.json';\n    public const CLASS_JS_EXTENSION = '.class.js';\n    public const TS_EXTENSION = '.ts';\n    public const CLASS_TS_EXTENSION = '.class.ts';\n    public const MJS_EXTENSION = '.mjs';\n    public const TPL_EXTENSION = '.tpl';\n    public const TXT_EXTENSION = '.txt';\n}"}
{"instruction": "Write an Ephect PHP component", "input": "Based on Ephect source: constants_utils.php", "output": "<?php\n\nfunction siteRoot(): string\n{\n    $siteRoot = DONT_USE_SITE_ROOT;\n    $vendorPos = strpos(DONT_USE_SITE_ROOT, 'vendor');\n\n    if ($vendorPos > -1) {\n        $siteRoot = substr(DONT_USE_SITE_ROOT, 0, $vendorPos);\n    }\n\n    return $siteRoot;\n}\nfunction siteConfigPath(): string\n{\n    return siteRoot() . DONT_USE_REL_CONFIG_DIR;\n}\n\nfunction siteRuntimePath(): string\n{\n    return siteRoot() . \\Constants::REL_RUNTIME_DIR;\n}\n\nfunction siteSrcPath(): string\n{\n    $configDir = siteConfigPath();\n    $srcDir = file_exists($configDir . DONT_USE_REL_CONFIG_APP) ? trim(file_get_contents($configDir . DONT_USE_REL_CONFIG_APP)) : DONT_USE_REL_CONFIG_APP;\n    return siteRoot() . $srcDir . DIRECTORY_SEPARATOR;\n}"}
{"instruction": "Write an Ephect command handler", "input": "Based on Ephect source: CommonLib.php", "output": "<?php\n\nnamespace Ephect\\Commands;\n\nuse Ephect\\Framework\\CLI\\Application;\nuse Ephect\\Framework\\CLI\\Console;\nuse Ephect\\Framework\\Element;\nuse Ephect\\Framework\\Utils\\File;\n\nclass CommonLib extends Element\n{\n    /**\n     * Constructor\n     */\n    public function __construct(Application $parent)\n    {\n        parent::__construct($parent);\n    }\n\n    public function requireTree(string $treePath): object\n    {\n        $tree = File::walkTreeFiltered($treePath, ['php']);\n        $result = ['path' => $treePath, 'tree' => $tree];\n\n        return (object)$result;\n    }\n\n    public function displayTree($path): void\n    {\n        $tree = File::walkTreeFiltered($path);\n        Console::writeLine($tree);\n    }\n\n\n}"}
{"instruction": "Write an Ephect PHP component", "input": "Based on Ephect source: Element.php", "output": "<?php\n\nnamespace Ephect\\Framework;\n\nuse ReflectionClass;\nuse ReflectionException;\n\nclass Element extends StaticElement implements ElementInterface\n{\n    use ElementTrait;\n\n    protected array $children = [];\n    private ?ReflectionClass $reflection = null;\n\n    public function __construct(?ElementInterface $parent = null, ?string $id = null)\n    {\n        parent::__construct();\n\n        $this->parent = $parent;\n        $this->id = ($id === null) ? '_' . time() : $id;\n    }\n\n    public static function getClassAttributesData(object $instance): array\n    {\n        $result = [];\n        $temp = [];\n\n        $reflection = new ReflectionClass($instance);\n        $attributes = $reflection->getAttributes();\n\n        foreach ($attributes as $attribute) {\n            $name = $attribute->getName();\n            $args = $attribute->getArguments();\n\n            if (isset($temp[$name])) {\n                $temp[$name] = array_merge($temp[$name], $args);\n            } else {\n                $temp[$name] = $args;\n            }\n        }\n\n        foreach ($temp as $key => $value) {\n            $result[] = [\"name\" => $key, \"args\" => $value];\n        }\n\n        return $result;\n    }\n\n    /**\n     * @throws ReflectionException\n     */\n    public function getMethodParameters($method): ?array\n    {\n        $ref = $this->getReflection();\n        $met = $ref->getMethod($method);\n\n        $params = [];\n        foreach ($met->getParameters() as $currentParam) {\n            $params[] = $currentParam->name;\n        }\n\n        return $params;\n    }\n\n    public function getReflection(): ?ReflectionClass\n    {\n        if ($this->reflection == null) {\n            $this->reflection = new ReflectionClass(get_class($this));\n        }\n        return $this->reflection;\n    }\n\n    public function addChild(ElementInterface $child): void\n    {\n        $this->children[$child->getId()] = $child;\n    }\n\n    public function removeChild(ElementInterface $child): void\n    {\n        unset($this->children[$child->getId()]);\n    }\n\n    public function getChildById($id): ?object\n    {\n        $result = null;\n\n        if (array_key_exists($id, $this->children)) {\n            $result = $this->children[$id];\n        }\n\n        return $result;\n    }\n\n    public function getChildrenIds(): ?array\n    {\n        return array_keys($this->children);\n    }\n\n    public function getFileName(): string\n    {\n        $reflection = $this->getReflection();\n        return $reflection->getFileName();\n    }\n}"}
{"instruction": "Write an Ephect PHP component", "input": "Based on Ephect source: ElementInterface.php", "output": "<?php\n\nnamespace Ephect\\Framework;\n\ninterface ElementInterface\n{\n    public static function functionName($fullQualifiedName): string;\n\n    public function getUID(): string;\n\n    public function getMotherUID(): string;\n\n    public function getId(): string;\n\n    public function getParent(): ?ElementInterface;\n\n    public function getClass(): string;\n\n    public function getBaseClass(): string;\n\n    public function getNamespace(): string;\n\n}"}
{"instruction": "Write an Ephect PHP component", "input": "Based on Ephect source: ElementTrait.php", "output": "<?php\n\nnamespace Ephect\\Framework;\n\nuse Ephect\\Framework\\Crypto\\Crypto;\n\ntrait ElementTrait\n{\n    protected $parent = null;\n    protected ?string $uid = '';\n    protected ?string $motherUID = '';\n    protected string $id = 'noname';\n    protected ?string $class = '';\n    protected string $namespace = '';\n    protected string $function = '';\n\n    public static function functionName($fullQualifiedName): string\n    {\n        $fqFunctionName = explode('\\\\', $fullQualifiedName);\n        return array_pop($fqFunctionName);\n    }\n\n    public function getUID(): string\n    {\n        if ($this->uid === '') {\n            $this->uid = Crypto::createOID();\n        }\n        return $this->uid;\n    }\n\n    public function getMotherUID(): string\n    {\n        return $this->motherUID;\n    }\n\n    public function getId(): string\n    {\n        return $this->id;\n    }\n\n    protected function setId($value): void\n    {\n        $this->id = $value;\n    }\n\n    public function getParent(): ?ElementInterface\n    {\n        return $this->parent;\n    }\n\n    public function getBaseclass(): string\n    {\n        return get_parent_class($this);\n    }\n\n    public function getNamespace(): string\n    {\n\n        if ($this->namespace === '') {\n            $classParts = explode('\\\\', $this->getclass());\n            $this->function = array_pop($classParts);\n            $this->namespace = implode('\\\\', $classParts);\n        }\n\n        return $this->namespace;\n    }\n\n    public function getClass(): string\n    {\n        if ($this->class == '') {\n            $this->class = get_class($this);\n        }\n\n        return $this->class;\n    }\n}"}
{"instruction": "Write an Ephect PHP component", "input": "Based on Ephect source: ElementUtils.php", "output": "<?php\n\nnamespace Ephect\\Framework;\n\nuse Ephect\\Framework\\Utils\\File;\n\nuse function strlen;\n\nfinal class ElementUtils\n{\n    public static function getNamespaceFromFQClassName($fqClassName): string\n    {\n        $classParts = explode('\\\\', $fqClassName);\n        array_pop($classParts);\n        return implode('\\\\', $classParts);\n    }\n\n    public static function getFunctionDefinitionFromFile($filepath): ?array\n    {\n        $contents = File::safeRead($filepath);\n\n        if ($contents === null) {\n            return null;\n        }\n\n        return self::getFunctionDefinition($contents);\n    }\n\n    public static function getFunctionDefinition($contents): ?array\n    {\n\n        $re = '/namespace *?([\\w\\\\\\\\]+);[\\w\\W\\\\\\\\]*function *?([$\\w]+) *?\\(([\\w\\W]*)\\)\\W*:? *?(\\w+)?\\W*(\\{)/U';\n\n        preg_match($re, $contents, $matches, PREG_OFFSET_CAPTURE, 0);\n\n        if (!count($matches)) {\n            return ['', '', '', '', -1];\n        }\n        $namespace = $matches[1][0];\n        $functionName = $matches[2][0];\n        $parameters = $matches[3][0];\n        $returnedType = $matches[4][0];\n        $pos = $matches[5][1];\n\n        return [$namespace, $functionName, $parameters, $returnedType, $pos];\n    }\n\n    public static function getEnumDefinitionFromFile($filepath): ?array\n    {\n        $contents = File::safeRead($filepath);\n\n        if ($contents === null) {\n            return null;\n        }\n\n        return self::getEnumDefinition($contents);\n    }\n\n    public static function getEnumDefinition($contents): ?array\n    {\n        [$namespace, $pos] = self::grabKeywordName('namespace', $contents, ';');\n        [$enumName, $pos] = self::grabKeywordName('enum', $contents, ' ');\n        $pos = strpos($contents, '{', $pos);\n\n        $enumName = trim($enumName, '{');\n        $enumName = trim($enumName);\n\n        return [$namespace, $enumName, $pos];\n    }\n\n    public static function grabKeywordName(string $keyword, string $classText, string $delimiter): array\n    {\n        $result = '';\n        $needle = $keyword . ' ';\n\n        $end = -1;\n        $start = strpos($classText, $needle);\n        if ($start > -1) {\n            $start += strlen($needle);\n            $end = strpos($classText, $delimiter, $start);\n            $result = trim(substr($classText, $start, $end - $start));\n        }\n\n        return [$result, $end];\n    }\n\n    public static function getTraitDefinitionFromFile($filepath): ?array\n    {\n        $contents = File::safeRead($filepath);\n\n        if ($contents === null) {\n            return null;\n        }\n\n        return self::getTraitDefinition($contents);\n    }\n\n    public static function getTraitDefinition($contents): ?array\n    {\n        [$namespace, $pos] = self::grabKeywordName('namespace', $contents, ';');\n        [$traitName, $pos] = self::grabKeywordName('trait', $contents, ' ');\n        $pos = strpos($contents, '{', $pos);\n\n        $traitName = trim($traitName, '{');\n        $traitName = trim($traitName);\n\n        return [$namespace, $traitName, $pos];\n    }\n\n    public static function getInterfaceDefinitionFromFile($filepath): ?array\n    {\n        $contents = File::safeRead($filepath);\n\n        if ($contents === null) {\n            return null;\n        }\n\n        return self::getInterfaceDefinition($contents);\n    }\n\n    public static function getInterfaceDefinition($contents): ?array\n    {\n        [$namespace, $pos] = self::grabKeywordName('namespace', $contents, ';');\n        [$interfaceName, $pos] = self::grabKeywordName('interface', $contents, ' ');\n        $pos = strpos($contents, '{', $pos);\n\n        $interfaceName = trim($interfaceName, '{');\n        $interfaceName = trim($interfaceName);\n\n        return [$namespace, $interfaceName, $pos];\n    }\n\n    public static function getClassDefinitionFromFile($filepath): ?array\n    {\n        $contents = File::safeRead($filepath);\n\n        if ($contents === null) {\n            return null;\n        }\n\n        return self::getClassDefinition($contents);\n    }\n\n    public static function getClassDefinition($contents): ?array\n    {\n        [$namespace, $pos] = self::grabKeywordName('namespace', $contents, ';');\n        [$className, $pos] = self::grabKeywordName('class', $contents, ' ');\n        $pos = strpos($contents, '{', $pos);\n\n        $className = trim($className, '{');\n        $className = trim($className);\n\n        return [$namespace, $className, $pos];\n    }\n\n    public static function normalizeClassname(string $classname): string\n    {\n        $classNameParts = explode('\\\\', $classname);\n        if (count($classNameParts) === 1) {\n            $classname = \\Constants::CONFIG_NAMESPACE . '\\\\' . $classname;\n        }\n\n        return $classname;\n    }\n\n\n}"}
{"instruction": "Write an Ephect PHP component", "input": "Based on Ephect source: StaticElement.php", "output": "<?php\n\nnamespace Ephect\\Framework;\n\nuse Ephect\\Framework\\Logger\\Logger;\n\nclass StaticElement\n{\n    protected static object|null $instance = null;\n    protected static Logger|null $logger = null;\n\n    protected function __construct()\n    {\n    }\n\n    public static function getLogger(): Logger\n    {\n        if (self::$logger === null) {\n            self::$logger = Logger::create();\n        }\n        return self::$logger;\n    }\n\n    public static function create(...$params)\n    {\n        $class = __CLASS__;\n        self::$instance = null;\n\n        if (count($params) > 0) {\n            self::$instance = new $class();\n        } else {\n            self::$instance = new $class($params);\n        }\n\n        return self::$instance;\n    }\n}"}
{"instruction": "Write an Ephect PHP component", "input": "Based on Ephect source: useContainer.php", "output": "<?php\n\nnamespace Ephect\\Hooks;\n\nuse Ephect\\Framework\\Registry\\MemoryRegistry;\n\n/**\n * @param array<array<int|string, int|string>>|null $memory\n * @param string $get\n * @return array\n * @throws \\InvalidArgumentException\n */\nfunction useContainer(object|null $class = null, string $get = ''): array\n{\n    if ($class !== null && $get !== '') {\n        throw new \\InvalidArgumentException(\n            \"You can't assign an object in memory and get an indexed value at once. Pass one or zero argument.\"\n        );\n    }\n\n    $setContainer = function (object $class): void {\n        MemoryRegistry::writeItem('container', $class);\n    };\n\n\n    if ($class !== null) {\n        $setContainer($class);\n    } else {\n        $container = MemoryRegistry::item('container');\n\n        if ($get !== '' && isset($container[$get])) {\n            $value = (is_array($container) ? $container[$get] : $container?->$get) ;\n            return [$value, $setContainer];\n        }\n    }\n\n    return [$container, $setContainer];\n}"}
{"instruction": "Write an Ephect PHP component", "input": "Based on Ephect source: useEffect.php", "output": "<?php\n\nnamespace Ephect\\Hooks;\n\nfunction useEffect($callback, ...$params): void\n{\n    call_user_func($callback, ...$params);\n}"}
{"instruction": "Write an Ephect PHP component", "input": "Based on Ephect source: useImport.php", "output": "<?php\n\nnamespace Ephect\\Hooks;\n\nfunction useImport(string $export, string $from): string\n{\n    return \"import { $export } from $from\" . PHP_EOL;\n}"}
{"instruction": "Write an Ephect PHP component", "input": "Based on Ephect source: useInterval.php", "output": "<?php\n\nnamespace Ephect\\Hooks;\n\nfunction useInterval($callback, $ms, $max = 0): void\n{\n    $last = microtime(true);\n    $seconds = $ms / 1000;\n\n    register_tick_function(function () use (&$last, $callback, $seconds, $max) {\n        static $busy = false;\n        static $n = 0;\n\n        if ($busy) {\n            return;\n        }\n\n        $busy = true;\n\n        $now = microtime(true);\n        while ($now - $last > $seconds) {\n            if ($max && $n == $max) {\n                break;\n            }\n            ++$n;\n\n            $last += $seconds;\n            $callback();\n        }\n\n        $busy = false;\n    });\n}"}
{"instruction": "Write an Ephect PHP component", "input": "Based on Ephect source: useMemory.php", "output": "<?php\n\nnamespace Ephect\\Hooks;\n\nuse Ephect\\Framework\\Registry\\MemoryRegistry;\n\n/**\n * @param array<array<int|string, int|string>>|null $memory\n * @param string $get\n * @return array\n * @throws \\InvalidArgumentException\n */\nfunction useMemory(array|object|null $memory = null, string $get = ''): array\n{\n    if ($memory !== null && $get !== '') {\n        throw new \\InvalidArgumentException(\n            \"You can't assign an object in memory and get an indexed value at once. Pass one or zero argument.\"\n        );\n    }\n\n    $setMemory = function (array|object $memory): void {\n        MemoryRegistry::writeItem('memory', $memory);\n    };\n\n\n    if ($memory !== null) {\n        $setMemory($memory);\n    } else {\n        $memory = MemoryRegistry::item('memory');\n\n        if ($get !== '' && isset($memory[$get])) {\n            $value = (is_array($memory) ? $memory[$get] : $memory?->$get) ;\n            return [$value, $setMemory];\n        }\n    }\n\n    return [$memory, $setMemory];\n}"}
{"instruction": "Write an Ephect PHP component", "input": "Based on Ephect source: useProps.php", "output": "<?php\n\nnamespace Ephect\\Hooks;\n\nuse Closure;\nuse ReflectionException;\nuse ReflectionFunction;\nuse stdClass;\n\n// function useProps(Closure $callback, ?array $defaults = null, ?object $props = null): void\n/**\n * Deprecated\n *\n * @param Closure $callback\n * @param object|null $props\n * @return void\n * @throws ReflectionException\n */\n#[Deprecated(\"Useless function\", \"useEffect\", \"0.3\")]\nfunction useProps(Closure $callback, ?object $props = null): void\n{\n    // $defaults = $defaults;\n\n    $ref = new ReflectionFunction($callback);\n    $params = $ref->getStaticVariables();\n    $defaults = $params;\n    // $params = $ref->getParameters();\n\n    $hasProps = $props !== null;\n\n    $newProps = !$hasProps ? new stdClass() : $props;\n    $newArgs = [];\n\n    foreach ($params as $name => $param) {\n\n        if ($name == 'props') {\n            continue;\n        }\n        $prop = $name;\n        // $prop = $param->getName();\n\n        if ($hasProps) {\n\n            if (!isset($newProps->$prop)) {\n                // $newProps->$prop = $defaults[$prop];\n                $newArgs[] = $defaults[$prop];\n            } else {\n                $newProps->$prop = $props->$prop;\n                $newArgs[] = $props->$prop;\n            }\n        } else {\n            if (!isset($newProps->$prop)) {\n                $newProps->$prop = $defaults[$prop];\n            }\n            $newArgs[] = $newProps->$prop;\n        }\n    }\n\n    call_user_func_array($callback, $newArgs);\n}"}
{"instruction": "Write an Ephect PHP component", "input": "Based on Ephect source: useQueryArgument.php", "output": "<?php\n\nnamespace Ephect\\Hooks;\n\nfunction useQueryArgument($arg, $default = ''): string|array\n{\n\n    // mysql_escape_string\n    if (isset($_POST[$arg])) {\n        $result = htmlspecialchars(filter_input(INPUT_POST, $arg));\n        if (is_array($_POST[$arg])) {\n            $result = filter_input(INPUT_POST, $arg, FILTER_REQUIRE_ARRAY);\n        }\n        return $result;\n    }\n\n    if (isset($_GET[$arg])) {\n        $result = filter_input(INPUT_GET, $arg, FILTER_SANITIZE_STRING);\n        return $result;\n    }\n\n    return $default;\n}"}
{"instruction": "Write an Ephect PHP component", "input": "Based on Ephect source: useRouteParams.php", "output": "<?php\n\nnamespace Ephect\\Hooks;\n\nfunction useRouteParams($base64Params)\n{\n    $params = base64_decode($base64Params);\n    return json_decode($params);\n}"}
{"instruction": "Write an Ephect PHP component", "input": "Based on Ephect source: useService.php", "output": "<?php\n\nnamespace Ephect\\Hooks;\n\nuse Ephect\\Framework\\Registry\\FrameworkRegistry;\nuse Ephect\\Framework\\Services\\ServiceFactory;\nuse Ephect\\Framework\\Services\\ServiceFactoryInterface;\nuse Ephect\\Framework\\Services\\ServiceInterface;\n\nfunction useService(string $serviceClass): ?ServiceInterface\n{\n    $filename = \\Constants::CONFIG_DIR . \"factories.php\";\n    if (!file_exists($filename)) {\n        return null;\n    }\n\n    $result = null;\n\n    $factories = require_once $filename;\n    foreach ($factories as $factoryClass) {\n        $factoryFile = FrameworkRegistry::read($factoryClass);\n        include_once $factoryFile;\n        if (is_subclass_of($factoryClass, ServiceFactoryInterface::class)) {\n            $factory = new $factoryClass();\n            $result = $factory->create($serviceClass);\n            break;\n        }\n    }\n\n    return $result;\n}"}
{"instruction": "Write an Ephect PHP component", "input": "Based on Ephect source: useSlot.php", "output": "<?php\n\nnamespace Ephect\\Hooks;\n\nuse JetBrains\\PhpStorm\\Deprecated;\n\n/**\n * Deprecated\n *\n * @param [type] $callback\n * @param [type] ...$params\n * @return void\n */\n#[Deprecated(\"Useless function\", \"useEffect\", \"0.3\")]\nfunction useSlot($callback, ...$params): void\n{\n    call_user_func($callback, ...$params);\n}"}
{"instruction": "Write an Ephect PHP component", "input": "Based on Ephect source: useState.php", "output": "<?php\n\nnamespace Ephect\\Hooks;\n\nuse Ephect\\Framework\\Registry\\StateRegistry;\n\n/**\n * @param array<array<int|string, int|string>>|null $state\n * @param string $get\n * @return array<mixed, \\Closure>\n * @throws \\InvalidArgumentException\n */\nfunction useState(?array $state = null, string $get = ''): array\n{\n    if ($state !== null && $get !== '') {\n        throw new \\InvalidArgumentException(\n            \"You can't assign a state and get an indexed value at once. Pass one or zero argument.\"\n        );\n    }\n\n    $setState = function (array $state): void {\n        StateRegistry::write('state', $state);\n    };\n\n    if ($state !== null) {\n        $setState($state);\n\n        $json = json_encode($state);\n        $state = json_decode($json, true);\n    } else {\n        $state = StateRegistry::item('state');\n\n        $json = json_encode($state);\n        $state = json_decode($json, true);\n\n        if ($get !== '') {\n            return [$state[$get] ?? null, $setState];\n        }\n    }\n\n    return [$state, $setState];\n}"}
{"instruction": "Write an Ephect PHP component", "input": "Based on Ephect source: useStore.php", "output": "<?php\n\nnamespace Ephect\\Hooks;\n\nuse Ephect\\Framework\\Registry\\StateRegistry;\n\n/**\n * @param array|object|null $store\n * @return array\n */\nfunction useStore(array|object|null $store = null, string $get = ''): array\n{\n    if ($store !== null && $get !== '') {\n        throw new \\InvalidArgumentException(\n            \"You can't assign a state and get an indexed value at once. Pass one or zero argument.\"\n        );\n    }\n\n    $setStore = function (array|object $store): void {\n        StateRegistry::writeItem('store', $store);\n    };\n\n    if ($store !== null) {\n        $setStore($store);\n\n        $json = json_encode($store);\n        $store = json_decode($json);\n    } else {\n        $store = StateRegistry::item('store');\n\n        $json = json_encode($store);\n        $store = json_decode($json);\n\n        if ($get !== '') {\n            return [$store->$get ?? null, $setStore];\n        }\n    }\n\n    return [$store, $setStore];\n}"}
{"instruction": "Write an Ephect PHP component", "input": "Based on Ephect source: useTimeout.php", "output": "<?php\n\nnamespace Ephect\\Hooks;\n\nfunction useTimeout($callback, $ms): void\n{\n    useInterval($callback, $ms, 1);\n}"}
{"instruction": "Write an Ephect PHP component", "input": "Based on Ephect source: AuthenticationService.php", "output": "<?php\n\nnamespace Ephect\\Plugins\\Authentication;\n\nuse Ephect\\Framework\\Crypto\\Crypto;\nuse Ephect\\Framework\\StaticElement;\nuse Ephect\\Modules\\DataAccess\\Client\\PDO\\PdoDataAccess;\n\nclass AuthenticationService extends StaticElement\n{\n    protected $userId = null;\n    protected $userName = null;\n\n    public static function getPermissionByToken(string $token): ?string\n    {\n        $result = null;\n        if ($token != '') {\n            $token = self::renewToken($token);\n            if (is_string($token)) {\n                $result = $token;\n            }\n        }\n\n        return $result;\n    }\n\n    public static function renewToken($token = ''): ?string\n    {\n        $result = null;\n\n        self::$logger->debug(__METHOD__ . '::TOKEN::' . $token);\n\n        if (strlen($token) > 0 && substr($token, 0, 1) == '!') {\n            $result = $token;\n            return $result;\n        }\n\n        //        $userId = $this->getUserId();\n        //        $login = $this->getUserName();\n\n        $connection = PdoDataAccess::getCryptoDB();\n        $stmt = $connection->query(\"select * from crypto where token =:token and outdated=0;\", ['token' => $token]);\n        if ($row = $stmt->fetchAssoc()) {\n            $userId = $row[\"userId\"];\n            $login = $row[\"userName\"];\n\n            $stmt = $connection->query(\"UPDATE crypto SET outdated=1 WHERE token =:token;\", ['token' => $token]);\n\n        }\n\n        $token = Crypto::createToken('');\n        $connection->query(\n            \"INSERT INTO crypto (token, userId, userName, outdated) VALUES(:token, :userId, :login, 0);\",\n            ['token' => $token, 'userId' => $userId, 'login' => $login]\n        );\n\n        $result = $token;\n\n        return $result;\n    }\n\n    public function getUserId(): string\n    {\n        if (!isset($this->userId) || empty($this->userId)) {\n            if (isset($_SESSION['userId'])) {\n                $this->userId = $_SESSION['userId'];\n            } else {\n                $this->setUserId('#!user' . uniqid() . '#');\n            }\n        }\n        return $this->userId;\n    }\n\n    public function setUserId($value): void\n    {\n        $_SESSION['userId'] = $value;\n        $this->userId = $value;\n    }\n\n    public function getUserName(): string\n    {\n        if (!isset($this->userName) || empty($this->userName)) {\n            if (isset($_SESSION['userName'])) {\n                $this->userName = $_SESSION['userName'];\n            } else {\n                $this->setUserName('#!user' . uniqid() . '#');\n            }\n        }\n        return $this->userName;\n    }\n\n    public function setUserName($value): void\n    {\n        $_SESSION['userName'] = $value;\n        $this->userName = $value;\n    }\n\n    public static function setUserToken(string $userId, string $login): ?string\n    {\n        $result = null;\n\n        $connection = PdoDataAccess::getCryptoDB();\n        $token = Crypto::createToken('');\n        $stmt = $connection->query(\n            \"INSERT INTO crypto (token, userId, userName, outdated) VALUES(:token, :userId, :login, 0);\",\n            ['token' => $token, 'userId' => $userId, 'login' => $login]\n        );\n\n        return ($token || $stmt->fetch()) ? $token : $result;\n    }\n\n    public function updateToken($token): ?int\n    {\n        $result = null;\n\n        $connection = PdoDataAccess::getCryptoDB();\n        $stmt = $connection->query(\"select * from crypto where token=:token and outdated=0;\", ['token' => $token]);\n\n        if ($stmt->fetch()) {\n            $stmt = $connection->query(\"UPDATE crypto SET outdated=1 WHERE token=:token;\", ['token' => $token]);\n            if ($stmt->fetch()) {\n                $result = $stmt->getRowCount();\n            }\n        }\n\n        return $result;\n    }\n\n}"}
{"instruction": "Write an Ephect PHP component", "input": "Based on Ephect source: SetupService.php", "output": "<?php\n\nnamespace Ephect\\Plugins\\Setup;\n\nuse Ephect\\Framework\\Core\\PhpInfo;\nuse Ephect\\Framework\\Logger\\Logger;\nuse Ephect\\Framework\\Utils\\File;\nuse Ephect\\Framework\\Web\\Curl;\nuse Exception;\nuse PharData;\n\nclass SetupService\n{\n    private string $_rewriteBase = '/';\n\n    public function __construct()\n    {\n        $rewriteBase = dirname(pathinfo($_SERVER['SCRIPT_NAME'], PATHINFO_DIRNAME)) . DIRECTORY_SEPARATOR;\n        $rewriteBase = str_replace(\"//\", \"/\", $rewriteBase);\n        // define('\\Constants::REWRITE_BASE', $rewriteBase);\n    }\n\n    public function getRewriteBase(): string\n    {\n        return \\Constants::REWRITE_BASE;\n    }\n\n    public function installPhinkJS(): bool\n    {\n        $ok = false;\n\n        try {\n            $filename = 'phinkjs.tar.gz';\n            $tarfilename = 'phinkjs.tar';\n            $phinkjs_dirname = 'phinkjs' . DIRECTORY_SEPARATOR;\n\n            $filepath = \\Constants::FRAMEWORK_ROOT;\n\n            if (file_exists($filepath . $phinkjs_dirname)) {\n                chdir($filepath . $phinkjs_dirname);\n\n                unlink('.gitignore');\n                $github = '.github' . DIRECTORY_SEPARATOR;\n                if (file_exists($filepath . $phinkjs_dirname . $github)) {\n                    File::delTree($filepath . $phinkjs_dirname . $github);\n                }\n\n                chdir('..');\n                File::delTree($filepath . $phinkjs_dirname);\n            }\n\n            if (!file_exists($filepath . $phinkjs_dirname)) {\n                chdir($filepath);\n            }\n\n            if (file_exists($tarfilename)) {\n                unlink($tarfilename);\n            }\n\n            $curl = new Curl();\n            $result = $curl->request('https://github.com/CodePhoenixOrg/PhinkJS/archive/master.tar.gz');\n            $ok = false !== file_put_contents($filename, $result['content']);\n\n            $p = new PharData($filename);\n            $p->decompress();\n\n            if (file_exists($filename)) {\n                unlink($filename);\n            }\n\n            $phar = new PharData($tarfilename);\n            $phar->extractTo($filepath);\n\n            if (file_exists($tarfilename)) {\n                unlink($tarfilename);\n            }\n\n\n            $ok = $ok && rename('PhinkJS-master', 'phinkjs');\n            chmod('phinkjs', 0775);\n        } catch (Exception $ex) {\n            $ok = false;\n            $log = Logger::create();\n            $log->error($ex);\n        }\n\n        return $ok;\n    }\n\n    public static function create(): SetupService\n    {\n        return new SetupService();\n    }\n\n    public function fixRewritBase(): ?string\n    {\n        $result = null;\n        $ok = false;\n\n        if ($ok = file_exists('bootstrap.php')) {\n            $ok = false !== file_put_contents(\\Constants::CONFIG_DIR . 'rewrite_base', \\Constants::REWRITE_BASE);\n\n            if (file_exists('.htaccess') && ($htaccess = file_get_contents('.htaccess'))) {\n                $htaccess = str_replace(PHP_EOL, ';', $htaccess);\n                $text = strtolower($htaccess);\n\n                $ps = strpos($text, 'rewritebase');\n                if ($ps > -1) {\n                    $pe = strpos($htaccess, ' ', $ps);\n                    $rewriteBaseKey = substr($htaccess, $ps, $pe - $ps);\n                    $pe = strpos($htaccess, ';', $ps);\n                    $rewriteBaseEntry = substr($htaccess, $ps, $pe - $ps);\n\n                    $htaccess = str_replace(\n                        $rewriteBaseEntry,\n                        $rewriteBaseKey . ' ' . \\Constants::REWRITE_BASE,\n                        $htaccess\n                    );\n                    $htaccess = str_replace(';', PHP_EOL, $htaccess);\n\n                    $ok = $ok && false !== file_put_contents('.htaccess', $htaccess);\n                }\n            }\n        }\n\n        $result = ($ok) ? \\Constants::REWRITE_BASE : null;\n\n        return $result;\n    }\n\n    public function findFramework(): bool\n    {\n        $ok = false;\n\n        $vendor_dir = \\Constants::FRAMEWORK_ROOT;\n        $portable_dir = 'framework' . DIRECTORY_SEPARATOR;\n        $lib = 'ephect' . DIRECTORY_SEPARATOR . 'bootstrap.php';\n\n        $framework_dir = 'framework';\n        if (file_exists(\\Constants::SITE_ROOT . $vendor_dir . $lib)) {\n            $framework_dir = $vendor_dir;\n        }\n\n        if (file_exists(\\Constants::SITE_ROOT . $portable_dir . $lib)) {\n            $framework_dir = $portable_dir;\n        }\n        $ok = false !== file_put_contents(\\Constants::CONFIG_DIR . 'framework', $framework_dir);\n\n        return $ok;\n    }\n\n    public function makeBootstrap(): bool\n    {\n\n        $ok = true;\n\n        $bootstrap1 = <<<BOOTSTRAP1\n<?php\n\\$is127 = (((\\$host = array_shift(\\$hostPort = explode(':', \\$_SERVER['HTTP_HOST']))) . (isset(\\$hostPort[1]) ? \\$port = ':' . \\$hostPort[1] : \\$port = '') == '127.0.0.1' . \\$port) ? \\$hostname = 'localhost' : \\$hostname = \\$host) !== \\$host;\n\\$isIndex = (((strpos(\\$_SERVER['REQUEST_URI'], 'index.php')  > -1) ? \\$requestUri = str_replace('index.php', '', \\$_SERVER['REQUEST_URI']) : \\$requestUri = \\$_SERVER['REQUEST_URI']) !== \\$_SERVER['REQUEST_URI']);\n\nif(\\$is127 || \\$isIndex) {\n    header('Location: //' . \\$hostname . \\$port . \\$requestUri);\n    exit(302);\n}\n// define('DONT_USE_CONFIG_DIR', '..' . DIRECTORY_SEPARATOR . '..' . DIRECTORY_SEPARATOR . 'config' . DIRECTORY_SEPARATOR);\n// define('FRAMEWORK', trim(file_get_contents(DONT_USE_CONFIG_DIR . 'framework')));\ninclude dirname(__FILE__) . DIRECTORY_SEPARATOR . 'bootstrap.php';\n\nBOOTSTRAP1;\n\n        $bootstrap2 = <<<BOOTSTRAP2\n<?php\n// define('DONT_USE_CONFIG_DIR', '..' . DIRECTORY_SEPARATOR . '..' . DIRECTORY_SEPARATOR . 'config' . DIRECTORY_SEPARATOR);\n// define('FRAMEWORK', trim(file_get_contents(DONT_USE_CONFIG_DIR . 'framework')));\ninclude dirname(__FILE__) . DIRECTORY_SEPARATOR . 'bootstrap.php';\n\nBOOTSTRAP2;\n\n        // include '../../vendor/autoload.php';\n\n        $serverApi = strtolower(PhpInfo::getGeneralSection()->server_api);\n\n        if (strpos($serverApi, 'embedded') > -1 || strpos($serverApi, 'built-in') > -1) {\n            $ok = false !== file_put_contents('bootstrap.php', $bootstrap1);\n        } else {\n            $ok = false !== file_put_contents('bootstrap.php', $bootstrap2);\n        }\n\n        return $ok;\n    }\n\n    public function makeIndex(): bool\n    {\n        $index = <<<INDEX\n<?php\ninclude 'bootstrap.php';\n\nEphect\\Framework\\Modules\\WebApp\\Web\\Application::create();\n\nINDEX;\n\n        return false !== file_put_contents('index.php', $index);\n    }\n}"}
{"instruction": "Write an Ephect domain event", "input": "Based on Ephect source: Bootstrap.php", "output": "<?php\n\nnamespace Ephect\\Modules\\DataAccess;\n\nuse Ephect\\Framework\\Event\\EventDispatcher;\nuse Ephect\\Framework\\Event\\Service\\EventServiceProvider;\nuse Ephect\\Framework\\Modules\\ModuleBootstrapInterface;\nuse Ephect\\Modules\\DataAccess\\Events\\ConnectionOpenerEvent;\nuse Ephect\\Modules\\DataAccess\\Listeners\\ConnectionOpenerListener;\n\nclass Bootstrap implements ModuleBootstrapInterface\n{\n    public function boot(): void\n    {\n        $dispatcher = new EventDispatcher();\n\n        $provider = new EventServiceProvider(\n            $dispatcher,\n            [\n                ConnectionOpenerEvent::class => [\n                    ConnectionOpenerListener::class,\n                ],\n            ],\n        );\n\n        $provider->register();\n    }\n}"}
{"instruction": "Write an Ephect component", "input": "Based on Ephect source: manifest.php", "output": "<?php\n\nreturn [\n    \"tag\" => \"DbalConnection\",\n    \"name\" => \"ephect-io/data-access\",\n    \"entrypoint\" => \\Ephect\\Modules\\Forms\\Components\\Plugin::class,\n    \"templates\" => \"!\",\n    \"description\" => \"Ephect framework database access layer.\",\n    \"version\" => \"0.7.2\",\n];"}
{"instruction": "Write an Ephect component", "input": "Based on Ephect source: manifest.php", "output": "<?php\n\nreturn [\n    \"tag\" => \"DoctrineBridge\",\n    \"name\" => \"ephect-io/doctrine-bridge\",\n    \"entrypoint\" => \\Ephect\\Modules\\Forms\\Components\\Plugin::class,\n    \"templates\" => \"!\",\n    \"description\" => \"Doctrine bridge for Ephect framework.\",\n    \"version\" => \"0.7.2\",\n];"}
{"instruction": "Write an Ephect component", "input": "Based on Ephect source: Bootstrap.php", "output": "<?php\n\nnamespace Ephect\\Modules\\Forms;\n\nuse Ephect\\Framework\\Event\\EventDispatcher;\nuse Ephect\\Framework\\Event\\Service\\EventServiceProvider;\nuse Ephect\\Framework\\Modules\\ModuleBootstrapInterface;\nuse Ephect\\Modules\\Forms\\Events\\ComponentAttributesEvent;\nuse Ephect\\Modules\\Forms\\Events\\ComponentFinishedEvent;\nuse Ephect\\Modules\\Forms\\Events\\PageFinishedEvent;\nuse Ephect\\Modules\\Forms\\Listeners\\ComponentAttributesListener;\nuse Ephect\\Modules\\Forms\\Listeners\\ComponentFinishedListener;\nuse Ephect\\Modules\\Forms\\Listeners\\PageFinishedListener;\n\nclass Bootstrap implements ModuleBootstrapInterface\n{\n    public function boot(): void\n    {\n        $dispatcher = new EventDispatcher();\n\n        $provider = new EventServiceProvider(\n            $dispatcher,\n            [\n                PageFinishedEvent::class => [\n                    PageFinishedListener::class,\n                ],\n                ComponentFinishedEvent::class => [\n                    ComponentFinishedListener::class,\n                ],\n                ComponentAttributesEvent::class => [\n                    ComponentAttributesListener::class,\n                ],\n            ],\n        );\n\n        $provider->register();\n    }\n}"}
{"instruction": "Write an Ephect component", "input": "Based on Ephect source: manifest.php", "output": "<?php\n\nreturn [\n    \"tag\" => \"\",\n    \"name\" => \"ephect-io/forms\",\n    \"entrypoint\" => \\Ephect\\Modules\\Forms\\Components\\Plugin::class,\n    \"templates\" => \"!\",\n    \"description\" => \"Ephect framework components oriented templating system.\",\n    \"version\" => \"0.7.2\",\n];"}
{"instruction": "Write an Ephect component", "input": "Based on Ephect source: manifest.php", "output": "<?php\n\nreturn [\n    \"tag\" => \"\",\n    \"name\" => \"ephect-io/response-header\",\n    \"entrypoint\" => \\Ephect\\Modules\\Forms\\Components\\Plugin::class,\n    \"templates\" => \"!\",\n    \"description\" => \"Ephect framework component that sends custom response headers.\",\n    \"version\" => \"0.7.2\",\n];"}
{"instruction": "Write an Ephect PHP component", "input": "Based on Ephect source: Bootstrap.php", "output": "<?php\n\nnamespace Ephect\\Modules\\Forms;\n\nuse Ephect\\Framework\\Modules\\ModuleBootstrapInterface;\nuse Ephect\\JavaScripts\\Builder\\AjilBuilder;\n\nclass Bootstrap implements ModuleBootstrapInterface\n{\n    public function boot(): void\n    {\n        if(!file_exists(\\Constants::DOCUMENT_ROOT . 'ajil.js')) {\n            AjilBuilder::build();\n        }\n    }\n}"}
{"instruction": "Write an Ephect PHP component", "input": "Based on Ephect source: manifest.php", "output": "<?php\n\nreturn [\n    \"tag\" => \"\",\n    \"name\" => \"ephect-io/javascripts\",\n    \"entrypoint\" => null,\n    \"templates\" => \"!\",\n    \"description\" => \"Ephect framework client side scripts.\",\n    \"version\" => \"0.7.2\",\n];"}
{"instruction": "Write an Ephect component", "input": "Based on Ephect source: manifest.php", "output": "<?php\n\nreturn [\n    \"tag\" => \"\",\n    \"name\" => \"ephect-io/router\",\n    \"entrypoint\" => \\Ephect\\Modules\\Forms\\Components\\Plugin::class,\n    \"templates\" => \"!\",\n    \"description\" => \"Ephect framework module that manages routes like components.\",\n    \"version\" => \"0.7.2\",\n];"}
{"instruction": "Write an Ephect PHP component", "input": "Based on Ephect source: manifest.php", "output": "<?php\n\nreturn [\n    \"tag\" => \"\",\n    \"name\" => \"ephect-io/samples\",\n    \"entrypoint\" => null,\n    \"templates\" => \"!\",\n    \"description\" => \"Ephect framework QuickStart and Skeleton sample applications.\",\n    \"version\" => \"0.7.2\",\n];"}
{"instruction": "Write an Ephect PHP component", "input": "Based on Ephect source: manifest.php", "output": "<?php\n\nreturn [\n    \"tag\" => \"\",\n    \"name\" => \"ephect-io/web-app\",\n    \"entrypoint\" => null,\n    \"templates\" => \"!\",\n    \"description\" => \"Ephect framework module that manages web requests.\",\n    \"version\" => \"0.7.2\",\n];"}
{"instruction": "Write an Ephect component", "input": "Based on Ephect source: manifest.php", "output": "<?php\n\nreturn [\n    \"tag\" => \"WebComponent\",\n    \"name\" => \"ephect-io/web-component\",\n    \"entrypoint\" => \\Ephect\\Modules\\WebComponent\\Module\\WebComponent::class,\n    \"templates\" => \"WebComponents\",\n    \"description\" => \"An Ephect framework module to build web components.\",\n    \"version\" => \"1.0.0\",\n];"}
{"instruction": "Write an Ephect component", "input": "Based on Ephect source: WebComponentZeroConf.php", "output": "<?php\n\nnamespace Ephect\\Modules\\WebComponent\\Attributes;\n\nuse Attribute;\nuse Ephect\\Framework\\Middlewares\\AttributeMiddlewareInterface;\nuse Ephect\\Modules\\WebComponent\\Middlewares\\WebComponentParserMiddleware;\n\n#[Attribute(Attribute::TARGET_FUNCTION)]\nclass WebComponentZeroConf implements AttributeMiddlewareInterface\n{\n    public function getMiddlewares(): array\n    {\n        return [\n            WebComponentParserMiddleware::class,\n        ];\n    }\n}"}
{"instruction": "Write an Ephect component", "input": "Based on Ephect source: Compiler.php", "output": "<?php\n\nnamespace Ephect\\Modules\\WebComponent\\Builder;\n\nuse Ephect\\Framework\\Templates\\TemplateMaker;\nuse Ephect\\Modules\\WebComponent\\Common;\nuse Ephect\\Modules\\WebComponent\\Manifest\\ManifestStructure;\nuse Ephect\\Modules\\WebComponent\\Manifest\\ManifestWriter;\nuse Exception;\n\nclass Compiler\n{\n    /**\n     * Second creation step of the WebComponent\n     *\n     * Create a manifest file include all details passed to the command line\n     *\n     * @param string $tagName\n     * @param string $className\n     * @param string $entrypoint\n     * @param array $arguments\n     * @param string $destDir\n     * @return void\n     * @throws Exception\n     */\n    public function saveManifest(string $tagName, string $className, string $entrypoint, array $arguments, string $destDir): void\n    {\n\n        $struct = new ManifestStructure([\n            'tag' => $tagName,\n            'class' => $className,\n            'entrypoint' => $entrypoint,\n            'arguments' => $arguments,\n        ]);\n\n        $writer = new ManifestWriter($struct, $destDir);\n        $writer->write();\n    }\n\n    /**\n     * Third and last creation step of the WebComponent\n     *\n     * Read templates text, replace the markups and save into user application directory\n     *\n     * @param string $tagName\n     * @param string $className\n     * @param bool $hasBackendProps\n     * @param string $entrypoint\n     * @param array $arguments\n     * @param string $srcDir\n     * @param string $destDir\n     * @return void\n     */\n    public function copyTemplates(\n        string $tagName,\n        string $className,\n        bool $hasBackendProps,\n        string $entrypoint,\n        array $arguments,\n        string $srcDir,\n        string $destDir\n    ): void {\n        $common = new Common();\n        $templatesDir = $common->getModuleSrcDir() . 'Templates' . DIRECTORY_SEPARATOR;\n\n        $classTextMaker = new TemplateMaker($templatesDir . 'Base.class.tpl');\n        $baseElementTextMaker = new TemplateMaker($templatesDir . 'BaseElement.tpl');\n        $baseTextMaker = new TemplateMaker($templatesDir . 'Base.tpl');\n        $componentTextMaker = new TemplateMaker($templatesDir . 'Component.tpl');\n\n        $classTextMaker->make(['Base' => $className, 'entrypoint' => $entrypoint,]);\n\n        $baseTextMaker->make([\n            'Base' => $className,\n            'tag-name' => $tagName,\n            'entrypoint' => $entrypoint,\n            'objectName' => lcfirst($className),\n        ]);\n\n        $baseElementTextMaker->make(['Base' => $className,]);\n\n        $parameters = $arguments;\n        $arguments[] = 'styles';\n        $arguments[] = 'classes';\n\n        if (count($arguments) == 0) {\n            $classTextMaker->make(['DeclaredAttributes' => '',]);\n            $baseElementTextMaker->make(['GetAttributes' => '',]);\n            $baseTextMaker->make(['Attributes' => '',]);\n\n            $classTextMaker->save($destDir . \"$className.class.js\");\n            $baseElementTextMaker->save($destDir . $className . \"Element.js\");\n            $baseTextMaker->save($destDir . \"$className.phtml\");\n\n            return;\n        }\n\n        $properties = '';\n        foreach ($arguments as $property) {\n            $properties .= <<< HTML\n                this.$property\\n\n                HTML;\n            $properties .= '            ';\n        }\n\n        $baseElementTextMaker->make(['Properties' => $properties,]);\n\n        $attributes = array_map(function ($item) {\n            return \"'$item'\";\n        }, $arguments);\n\n        $thisParameters = array_map(function ($item) {\n            return \"this.\" . $item;\n        }, $parameters);\n\n        $declaredAttributes = implode(\", \", $parameters);\n        $attributes = implode(\", \", $attributes);\n\n        $thisAttributeList = implode(\", \", $thisParameters);\n\n        $observeAttributes = <<< HTML\n                static get observeAttributes() {\n                        /**\n                        * Attributes passed inline to the component\n                        */\n                        return [$attributes]\n                    }\n            HTML;\n\n        $baseElementTextMaker->make(['ObserveAttributes' => $observeAttributes,]);\n\n        $getAttributes = '';\n        foreach ($arguments as $attribute) {\n            $getAttributes .= <<< HTML\n                    get $attribute() {\n                            return this.getAttribute('$attribute') ?? null\n                        }\\n\n                HTML;\n            $getAttributes .= '    ';\n        }\n\n        $classTextMaker->make(['DeclaredAttributes' => $declaredAttributes,]);\n        $baseElementTextMaker->make(['GetAttributes' => $getAttributes,]);\n        $baseTextMaker->make(['AttributeList' => $thisAttributeList,]);\n\n        if ($hasBackendProps) {\n            $namespace = \\Constants::CONFIG_NAMESPACE;\n\n            $baseTextMaker->make(['endTemplate' => '<h2>{{ foo }}</h2>',]);\n\n            $funcBody = <<< FUNC_BODY\n            useEffect(function (\\$slot, /* string */ \\$foo) {\n                \\$foo = \"It works!\"; \n            });\n            FUNC_BODY;\n\n            $componentTextMaker->make([\n                'funcNamespace' => $namespace,\n                'funcName' => $className,\n                'funcBody' => $funcBody,\n                'html' => $baseTextMaker->getTemplate(),\n            ]);\n            $baseTextMaker->setTemplate($componentTextMaker->getTemplate());\n        } else {\n            $baseTextMaker->make(['endTemplate' => '',]);\n        }\n\n        $classTextMaker->save($destDir . $className . \\Constants::CLASS_JS_EXTENSION);\n        $baseElementTextMaker->save($destDir . $className . \"Element\" . \\Constants::JS_EXTENSION);\n        $baseTextMaker->save($destDir . \"$className.phtml\");\n    }\n}"}
{"instruction": "Write an Ephect component", "input": "Based on Ephect source: Parser.php", "output": "<?php\n\nnamespace Ephect\\Modules\\WebComponent\\Builder;\n\nuse Ephect\\Modules\\Forms\\Generators\\RawHtmlParser;\n\nclass Parser extends RawHtmlParser\n{\n    private string $template = '';\n    private string $script = '';\n    private string $style = '';\n\n    public function __construct(private readonly string $html)\n    {\n        parent::__construct($this->html);\n    }\n\n    public function doTags(): void\n    {\n        $this->doTag('template');\n        $htmls = $this->getInnerHTML();\n        $this->template = count($htmls) ? $htmls[0] : '';\n\n        $this->doTag('script');\n        $htmls = $this->getInnerHTML();\n        $this->script = count($htmls) ? $htmls[0] : '';\n\n        $this->doTag('style');\n        $htmls = $this->getOuterHTML();\n        foreach ($htmls as $html) {\n            $this->style .= $html . PHP_EOL;\n        }\n    }\n\n    public function getScript($name): string\n    {\n        $heredoc = <<<HTML\n        `\n        $this->style\n        $this->template\n        `\n        HTML;\n        $script = str_replace(\"document.getElementById('$name').innerHTML\", $heredoc, $this->script);\n\n        return $script;\n    }\n}"}
{"instruction": "Write an Ephect component", "input": "Based on Ephect source: Common.php", "output": "<?php\n\nnamespace Ephect\\Modules\\WebComponent;\n\nuse Ephect\\Framework\\Modules\\Utils;\n\nclass Common extends Utils\n{\n    public function __construct()\n    {\n        parent::__construct(__DIR__);\n    }\n\n    public function getCustomWebComponentRoot(): string\n    {\n        $moduleTemplatesDir = $this->getModuleManifest()->getTemplates();\n        $customConfig = file_exists(\\Constants::CONFIG_DIR . 'webcomponents') ?\n            trim(file_get_contents(\\Constants::CONFIG_DIR . 'webcomponents')) : $moduleTemplatesDir;\n        return \\Constants::SRC_ROOT . $customConfig . DIRECTORY_SEPARATOR;\n    }\n}"}
{"instruction": "Write an Ephect component", "input": "Based on Ephect source: ManifestEntity.php", "output": "<?php\n\nnamespace Ephect\\Modules\\WebComponent\\Manifest;\n\nuse Ephect\\Framework\\ElementTrait;\n\nclass ManifestEntity implements ManifestEntityInterface\n{\n    use ElementTrait;\n\n    private string $tag;\n    private string $className;\n    private string $entrypoint;\n    private array $arguments;\n\n    public function __construct(ManifestStructure $structure)\n    {\n        $this->tag = $structure->tag;\n        $this->className = $structure->class;\n        $this->entrypoint = $structure->entrypoint;\n        $this->arguments = $structure->arguments;\n    }\n\n    public function getTag(): string\n    {\n        return $this->tag;\n    }\n\n    public function getClassName(): string\n    {\n        return $this->className;\n    }\n\n    public function getEntrypoint(): string\n    {\n        return $this->entrypoint;\n    }\n\n    public function getArguments(): array\n    {\n        return $this->arguments;\n    }\n\n}"}
{"instruction": "Write an Ephect component", "input": "Based on Ephect source: ManifestEntityInterface.php", "output": "<?php\n\nnamespace Ephect\\Modules\\WebComponent\\Manifest;\n\nuse Ephect\\Framework\\ElementInterface;\n\ninterface ManifestEntityInterface extends ElementInterface\n{\n    public function getTag(): string;\n\n    public function getClassName(): string;\n\n    public function getEntrypoint(): string;\n\n    public function getArguments(): array;\n\n}"}
{"instruction": "Write an Ephect component", "input": "Based on Ephect source: ManifestReader.php", "output": "<?php\n\nnamespace Ephect\\Modules\\WebComponent\\Manifest;\n\nuse Ephect\\Framework\\Utils\\File;\nuse Ephect\\Modules\\WebComponent\\Common;\n\nclass ManifestReader\n{\n    public function __construct(private readonly string $motherUID, private readonly string $name)\n    {\n    }\n\n    public function read(): ManifestEntity\n    {\n\n        $manifestFilename = $this->name . '.' . 'manifest.json';\n        $manifestCache = \\Constants::BUILD_DIR . $this->motherUID . DIRECTORY_SEPARATOR . $manifestFilename;\n\n        if (!file_exists($manifestCache)) {\n            $common = new Common();\n            copy(\n                $common->getCustomWebComponentRoot() . $this->name . DIRECTORY_SEPARATOR . $manifestFilename,\n                $manifestCache\n            );\n        }\n\n        $manifestJson = File::safeRead($manifestCache);\n        $manifest = json_decode($manifestJson, JSON_OBJECT_AS_ARRAY);\n\n        $struct = new ManifestStructure($manifest);\n\n        return new ManifestEntity($struct);\n    }\n}"}
{"instruction": "Write an Ephect component", "input": "Based on Ephect source: ManifestStructure.php", "output": "<?php\n\nnamespace Ephect\\Modules\\WebComponent\\Manifest;\n\nuse Ephect\\Framework\\Structure\\Structure;\n\nclass ManifestStructure extends Structure\n{\n    public string $tag = '';\n    public string $class = '';\n    public string $entrypoint = '';\n    public array $arguments = [];\n}"}
{"instruction": "Write an Ephect component", "input": "Based on Ephect source: ManifestWriter.php", "output": "<?php\n\nnamespace Ephect\\Modules\\WebComponent\\Manifest;\n\nuse Ephect\\Framework\\Utils\\File;\nuse Exception;\n\nclass ManifestWriter\n{\n    public function __construct(private readonly ManifestStructure $struct, private readonly string $directory)\n    {\n    }\n\n    /**\n     * @throws Exception\n     */\n    public function write(): void\n    {\n        $destDir = $this->directory;\n        $name = $this->struct->class;\n\n        if (!File::safeMkDir($destDir)) {\n            throw new Exception(\"$destDir creation failed\");\n        }\n\n        $destDir = realpath($destDir) . DIRECTORY_SEPARATOR;\n        $json = json_encode($this->struct->toArray(), JSON_PRETTY_PRINT);\n\n        File::safeWrite($destDir . DIRECTORY_SEPARATOR . $name . '.manifest.json', $json);\n    }\n}"}
{"instruction": "Write an Ephect component", "input": "Based on Ephect source: WebComponentBuilderMiddleware.php", "output": "<?php\n\nnamespace Ephect\\Modules\\WebComponent\\Middlewares;\n\nuse Ephect\\Framework\\Middlewares\\ApplicationStateMiddlewareInterface;\n\nclass WebComponentBuilderMiddleware implements ApplicationStateMiddlewareInterface\n{\n    public function __invoke(object $arguments)\n    {\n        // TODO: Implement ignite() method.\n        // add web component JS module to the list of scripts to load.\n    }\n\n}"}
{"instruction": "Write an Ephect component", "input": "Based on Ephect source: WebComponentParserMiddleware.php", "output": "<?php\n\nnamespace Ephect\\Modules\\WebComponent\\Middlewares;\n\nuse Ephect\\Framework\\Registry\\StateRegistry;\nuse Ephect\\Modules\\Forms\\Components\\ComponentEntityInterface;\nuse Ephect\\Modules\\Forms\\Middlewares\\ComponentParserMiddlewareInterface;\n\nuse function Ephect\\Hooks\\useState;\n\nclass WebComponentParserMiddleware implements ComponentParserMiddlewareInterface\n{\n    public function parse(ComponentEntityInterface|null $parent, string $motherUID, string $funcName, string $props, array $arguments): void\n    {\n        StateRegistry::loadByMotherUid($motherUID, true);\n        useState([\"middlewares\" => [WebComponentBuilderMiddleware::class => (object)$arguments],]);\n        StateRegistry::saveByMotherUid($motherUID, true);\n        //        StateRegistry::save(true);\n    }\n}"}
{"instruction": "Write an Ephect component", "input": "Based on Ephect source: WebComponent.php", "output": "<?php\n\nnamespace Ephect\\Modules\\WebComponent\\Module;\n\nuse Ephect\\Framework\\Templates\\TemplateMaker;\nuse Ephect\\Modules\\Forms\\Registry\\ComponentRegistry;\nuse Ephect\\Modules\\WebComponent\\Common;\nuse Ephect\\Modules\\Forms\\Application\\ApplicationComponent;\n\nclass WebComponent extends ApplicationComponent\n{\n    public function makeComponent(string $filename, string &$html): void\n    {\n        $info = (object) pathinfo($filename);\n        $namespace = \\Constants::CONFIG_NAMESPACE;\n        $function = $info->filename;\n\n        $common =  new Common();\n\n        $textMaker =  new TemplateMaker(\n            $common->getModuleSrcDir() . 'Templates' . DIRECTORY_SEPARATOR . 'Component.tpl'\n        );\n        $textMaker->make(['funcNamespace' => $namespace, 'funcName' => $function, 'funcBody' => '', 'html' => $html]);\n        $textMaker->save(\\Constants::COPY_DIR . $filename);\n    }\n\n    public function analyse(): void\n    {\n        parent::analyse();\n\n        ComponentRegistry::write($this->getFullyQualifiedFunction(), $this->getSourceFilename());\n        ComponentRegistry::safeWrite($this->getFunction(), $this->getFullyQualifiedFunction());\n        ComponentRegistry::save();\n    }\n\n    public function parse(): void\n    {\n        parent::parse();\n        $this->cacheHtml();\n    }\n}"}
{"instruction": "Write an Ephect component", "input": "Based on Ephect source: WebComponentService.php", "output": "<?php\n\nnamespace Ephect\\Modules\\WebComponent\\Services;\n\nuse DateTime;\nuse Ephect\\Framework\\Utils\\File;\nuse Ephect\\Modules\\Forms\\Components\\ChildrenInterface;\nuse Ephect\\Modules\\WebComponent\\Builder\\Parser;\nuse Ephect\\Modules\\WebComponent\\Common;\nuse Ephect\\Modules\\WebComponent\\Manifest\\ManifestEntity;\nuse Ephect\\Modules\\WebComponent\\Manifest\\ManifestReader;\nuse PHPUnit\\TextUI\\Configuration\\Constant;\n\nfinal class WebComponentService implements WebComponentServiceInterface\n{\n    private readonly string $customWebcomponentRoot;\n    public function __construct(private readonly ChildrenInterface $children)\n    {\n        $common = new Common();\n        $this->customWebcomponentRoot = $common->getCustomWebComponentRoot();\n    }\n\n    public function isPending(): bool\n    {\n        return file_exists(\\Constants::RUNTIME_JS_DIR . $this->children->getName() . '.pending' . \\Constants::JS_EXTENSION);\n    }\n\n    public function markAsPending(): void\n    {\n        $date = new DateTime();\n        $timestamp = $date->getTimestamp();\n        $pendingJs = \\Constants::RUNTIME_JS_DIR . $this->children->getName() . '.pending' . \\Constants::JS_EXTENSION;\n        File::safeWrite($pendingJs, \"const time = $timestamp\");\n    }\n\n    public function getBody(string $tag): ?string\n    {\n        $componentArgsString = '';\n        $props = $this->children->props()->slot;\n        if ($props !== null) {\n            $componentArgs = [];\n            foreach ($props as $key => $value) {\n                if ($key == 'uid') {\n                    continue;\n                }\n                $componentArgs[] = $key . '=\"' . $value . '\"';\n            }\n\n            $componentArgsString = ' ' . implode(\" \", $componentArgs);\n        }\n\n        return \"<$tag$componentArgsString></$tag>\";\n    }\n\n    public function readManifest(): ManifestEntity\n    {\n        $children = $this->children;\n\n        $motherUID = $children->getMotherUID();\n        $name = $children->getName();\n\n        $reader = new ManifestReader($motherUID, $name);\n\n        return $reader->read();\n    }\n\n    public function splitHTML(string $html): void\n    {\n        $name = $this->children->getName();\n\n        $runtimeDir = \\Constants::RUNTIME_JS_DIR . $name . DIRECTORY_SEPARATOR;\n        File::safeMkDir($runtimeDir);\n        $finalJs = $runtimeDir . $name . \\Constants::JS_EXTENSION;\n        $classJs = $name . \\Constants::CLASS_JS_EXTENSION;\n        $elementJs = $name . \"Element\" . \\Constants::JS_EXTENSION;\n\n        $parser = new Parser($html);\n        $parser->doTags();\n        $script = $parser->getScript($name);\n\n        File::safeWrite($finalJs, $script);\n        copy($this->customWebcomponentRoot . $name . DIRECTORY_SEPARATOR . $classJs, $runtimeDir . $classJs);\n        copy($this->customWebcomponentRoot . $name . DIRECTORY_SEPARATOR . $elementJs, $runtimeDir . $elementJs);\n\n        if (file_exists($this->customWebcomponentRoot . $name . DIRECTORY_SEPARATOR . \"lib\")) {\n            $libFiles = File::walkTreeFiltered($this->customWebcomponentRoot . $name . DIRECTORY_SEPARATOR . \"lib\");\n            File::safeMkDir($runtimeDir . 'lib');\n            foreach ($libFiles as $filename) {\n                copy(\n                    $this->customWebcomponentRoot . $name . DIRECTORY_SEPARATOR . 'lib' . $filename,\n                    $runtimeDir . 'lib' . $filename\n                );\n            }\n        }\n    }\n\n    public function storeHTML(string $html): void\n    {\n        $name = $this->children->getName();\n        $finalHTML = $this->customWebcomponentRoot . $name . DIRECTORY_SEPARATOR . $name . Constants::HTML_EXTENSION;\n        File::safeWrite($finalHTML, $html);\n    }\n}"}
{"instruction": "Write an Ephect component", "input": "Based on Ephect source: WebComponentServiceInterface.php", "output": "<?php\n\nnamespace Ephect\\Modules\\WebComponent\\Services;\n\nuse Ephect\\Modules\\WebComponent\\Manifest\\ManifestEntity;\n\ninterface WebComponentServiceInterface\n{\n    public function isPending(): bool;\n\n    public function markAsPending(): void;\n\n    public function getBody(string $tag): ?string;\n\n    public function readManifest(): ManifestEntity;\n\n    public function storeHTML(string $html): void;\n\n}"}
{"instruction": "Write an Ephect component", "input": "Based on Ephect source: Lib.php", "output": "<?php\n\nnamespace Ephect\\Modules\\WebComponent\\Commands\\MakeWebComponent;\n\nuse Ephect\\Framework\\CLI\\Console;\nuse Ephect\\Framework\\CLI\\ConsoleColors;\nuse Ephect\\Framework\\CLI\\Enums\\ConsoleOptionsEnum;\nuse Ephect\\Framework\\Commands\\AbstractCommandLib;\nuse Ephect\\Modules\\WebComponent\\Builder\\Compiler;\nuse Ephect\\Modules\\WebComponent\\Common;\nuse Exception;\n\nclass Lib extends AbstractCommandLib\n{\n    public function createWebcomponentBase(): void\n    {\n        try {\n\n            Console::writeLine(ConsoleColors::getColoredString(\"Creating a new webComponent.\", ConsoleColors::LIGHT_BLUE));\n            Console::writeLine(ConsoleColors::getColoredString(\"Please, answer the following questions.\", ConsoleColors::BLUE));\n            Console::writeLine(ConsoleColors::getColoredString(\"Leave the answer blank to pass to the next question or to abort the process.\", ConsoleColors::BROWN));\n\n            $builder = new Compiler();\n            [$tagName, $className, $hasBackendProps, $entrypoint, $arguments] = $this->readLine();\n\n            $common = new Common();\n            $destDir = $common->getCustomWebComponentRoot() . $className . DIRECTORY_SEPARATOR;\n\n            $builder->saveManifest($tagName, $className, $entrypoint, $arguments, $destDir);\n\n            $srcDir = $common->getModuleSrcDir() . 'Templates' . DIRECTORY_SEPARATOR;\n\n            $builder->copyTemplates($tagName, $className, $hasBackendProps, $entrypoint, $arguments, $srcDir, $destDir);\n\n            Console::writeLine(ConsoleColors::getColoredString(\"WebComponent \", ConsoleColors::BLUE) . \"%s\" . ConsoleColors::getColoredString(\" is available in:\", ConsoleColors::BLUE), $className);\n            Console::writeLine(\"%s\", $destDir);\n        } catch (Exception $ex) {\n            Console::error($ex, ConsoleOptionsEnum::ErrorMessageOnly);\n        }\n    }\n\n    /**\n     * Ask some questions to get the properties of the webComponent\n     *\n     * @return array\n     * @throws Exception\n     */\n    public function readLine(): array\n    {\n        /**\n         * Asking the tag name.\n         */\n        $tagName = Console::readLine(\"Tag name (kebab-case): \");\n        $tagName = strtolower($tagName);\n        if (trim($tagName) == '') {\n            throw new Exception(\"WebComponent tag name must not be empty\");\n        }\n\n        Console::writeLine(ConsoleColors::getColoredString(\"The code of the webComponent will split into one JS module and one HTML template.\", ConsoleColors::BLUE));\n\n        /**\n         * Asking for the class name.\n         */\n        $className = Console::readLine(\"Module class name (PascalCase): \");\n        if (trim($className) == '') {\n            throw new Exception(\"WebComponent class name must not be empty\");\n        }\n\n        /**\n         * Asking whether we encapsulate the webcomponent in a backend function or not.\n         */\n        $hasBackendProps = Console::readYesOrNo(\"Do you need to implement backend props?\");\n\n        /**\n         * Asking for entrypoint.\n         */\n        $entrypoint = Console::readLine(\"Entrypoint in class (camelCase): \");\n        if (trim($entrypoint) == '') {\n            throw new Exception(\"WebComponent entrypoint must not be empty\");\n        }\n\n        /**\n         * Asking for entrypoint arguments.\n         */\n        $next = true;\n        $argIndex = 1;\n        $arguments = [];\n        while ($next) {\n            $arg = Console::readLine(\"Argument $argIndex:\");\n            if (trim($arg) == '') {\n                Console::writeLine(ConsoleColors::getColoredString(\"Ending WebComponent arguments list\", ConsoleColors::LIGHT_BLUE));\n                $next = false;\n                continue;\n            }\n            $arguments[] = $arg;\n            $argIndex++;\n        }\n\n        return [$tagName, $className, $hasBackendProps, $entrypoint, $arguments];\n    }\n\n\n}"}
{"instruction": "Write an Ephect component", "input": "Based on Ephect source: Main.php", "output": "<?php\n\nnamespace Ephect\\Modules\\WebComponent\\Commands\\MakeWebComponent;\n\nuse Ephect\\Framework\\Commands\\AbstractCommand;\nuse Ephect\\Framework\\Commands\\Attributes\\CommandDeclaration;\n\n#[CommandDeclaration(verb: \"make\", subject: \"webcomponent\")]\n#[CommandDeclaration(desc: \"Create the base tree of a webComponent.\")]\nclass Main extends AbstractCommand\n{\n    public function run(): int\n    {\n        $lib = new Lib($this->application);\n        $lib->createWebComponentBase();\n\n        return 0;\n    }\n}"}
{"instruction": "Write an Ephect component", "input": "Based on Ephect source: Builder.php", "output": "<?php\n\nnamespace Ephect\\Modules\\WebApp\\Builder;\n\nuse Ephect\\Framework\\Modules\\ModuleInstaller;\nuse Ephect\\Framework\\Utils\\File;\nuse Ephect\\Modules\\Forms\\Registry\\CodeRegistry;\nuse Ephect\\Modules\\Forms\\Registry\\ComponentRegistry;\nuse Ephect\\Modules\\Forms\\Registry\\PluginRegistry;\nuse Ephect\\Modules\\Routing\\Services\\RouterService;\nuse Ephect\\Modules\\WebApp\\Builder\\Copiers\\TemplatesCopyMaker;\nuse Ephect\\Modules\\WebApp\\Builder\\Descriptors\\ComponentListDescriptor;\nuse Ephect\\Modules\\WebApp\\Builder\\Descriptors\\ModuleListDescriptor;\nuse Ephect\\Modules\\WebApp\\Builder\\Descriptors\\PluginListDescriptor;\nuse Ephect\\Modules\\WebApp\\Builder\\Finders\\PagesFinder;\nuse Ephect\\Modules\\WebApp\\Builder\\Finders\\RoutesFinder;\nuse Ephect\\Modules\\WebApp\\Builder\\Registerer\\PageRegisterer;\nuse Ephect\\Modules\\WebApp\\Builder\\Strategy\\BuildByNameStrategy;\nuse Ephect\\Modules\\WebApp\\Builder\\Strategy\\BuildByRouteStrategy;\nuse Exception;\n\nclass Builder\n{\n    protected array $list = [];\n    protected array $routes = [];\n\n    public static function purgeCopies(): void\n    {\n        File::delTree(\\Constants::COPY_DIR);\n    }\n\n    /**\n     * Register all components of the application\n     *\n     * @return void\n     */\n    public function describeComponents(): void\n    {\n        if (!ComponentRegistry::load()) {\n            File::safeMkDir(\\Constants::CACHE_DIR);\n            File::safeMkDir(\\Constants::COPY_DIR);\n            File::safeMkDir(\\Constants::BUILD_DIR);\n            File::safeMkDir(\\Constants::STATIC_DIR);\n\n            $copier = new TemplatesCopyMaker();\n            $copier->makeCopies(true); // make unique copies\n\n            //            UniqueCodeRegistry::load();\n            //            $descriptor = new UniqueComponentListDescriptor();\n            //            $descriptor->describe();\n            //            UniqueCodeRegistry::save();\n\n            CodeRegistry::load();\n\n            $descriptor = new ComponentListDescriptor();\n            $components = $descriptor->describe();\n            $this->list = [...$this->list, ...$components];\n\n            //            CodeRegistry::save();\n            //            ComponentRegistry::save();\n        }\n\n        if (!PluginRegistry::load()) {\n            [$filename, $modulePaths] = ModuleInstaller::readModulePaths();\n            foreach ($modulePaths as $path) {\n                if (str_starts_with($path, 'vendor')) {\n                    $path = realpath(siteRoot() . $path);\n                }\n                $moduleSrcPathFile = $path . DIRECTORY_SEPARATOR . \\Constants::REL_CONFIG_DIR . \\Constants::REL_CONFIG_APP;\n                $moduleSrcPath = file_exists($moduleSrcPathFile)\n                    ? $path . DIRECTORY_SEPARATOR . file_get_contents($moduleSrcPathFile)\n                    : $path . DIRECTORY_SEPARATOR . \\Constants::REL_CONFIG_APP;\n                $moduleSrcPath = is_dir($moduleSrcPath) ? $moduleSrcPath : $path . DIRECTORY_SEPARATOR;\n\n\n                $descriptor = new ModuleListDescriptor($path);\n                $moduleComponents = $descriptor->describe($moduleSrcPath);\n                $this->list = [...$this->list, ...$moduleComponents];\n            }\n\n            /**\n             * Describe builtin modules\n             */\n            $descriptor = new PluginListDescriptor();\n            $plugins = $descriptor->describe();\n            $this->list = [...$this->list, ...$plugins];\n\n            CodeRegistry::save();\n            PluginRegistry::save();\n            ComponentRegistry::save();\n        }\n    }\n\n    public function preparePagesList(): void\n    {\n        $pagesFinder = new PagesFinder();\n        $pagesList = $pagesFinder->find();\n\n        $pagesRegisterer = new PageRegisterer();\n        $pagesRegisterer->register($pagesList);\n    }\n\n    public function prepareRoutedComponents(): void\n    {\n        CodeRegistry::load();\n        ComponentRegistry::load();\n\n        $routes = (new RoutesFinder())->find();\n        // TODO: check if it works\n        //        $fqApp = ComponentRegistry::read('App');\n        $fqApp = 'App';\n\n        array_unshift($routes, $fqApp);\n\n        foreach ($routes as $route) {\n            $fqRoute = ComponentRegistry::read($route);\n            $comp = $this->list[$fqRoute];\n\n            // $comp->copyComponents($this->list);\n        }\n\n        $this->routes = $routes;\n    }\n\n    /**\n     * @throws Exception\n     */\n    public function buildAllRoutes(): void\n    {\n        (new BuildByNameStrategy())->build('App');\n        // TODO: check if it works\n        $this->routes = RouterService::findRouteNames();\n\n        $buildByRoute = new BuildByRouteStrategy();\n        foreach ($this->routes as $route) {\n            $buildByRoute->build($route);\n        }\n    }\n}"}
{"instruction": "Write an Ephect PHP component", "input": "Based on Ephect source: PageRegistry.php", "output": "<?php\n\nnamespace Ephect\\Modules\\WebApp\\Registry;\n\nuse Ephect\\Framework\\Registry\\AbstractStaticRegistry;\n\nclass PageRegistry extends AbstractStaticRegistry\n{\n    private static ?PageRegistry $instance = null;\n\n    public static function reset(): void\n    {\n        self::$instance = new PageRegistry();\n        unlink(self::$instance->getCacheFilename());\n    }\n\n    public static function getInstance(): PageRegistry\n    {\n        if (self::$instance === null) {\n            self::$instance = new PageRegistry();\n        }\n\n        return self::$instance;\n    }\n}"}
{"instruction": "Write an Ephect component", "input": "Based on Ephect source: BuildService.php", "output": "<?php\n\nnamespace Ephect\\Modules\\WebApp\\Services;\n\nuse Ephect\\Modules\\WebApp\\Builder\\Builder;\n\nclass BuildService\n{\n    public function build(): Builder\n    {\n        $builder = new Builder();\n        $builder->describeComponents();\n        $builder->preparePagesList();\n        $builder->prepareRoutedComponents();\n\n        return $builder;\n    }\n}"}
{"instruction": "Write an Ephect component", "input": "Based on Ephect source: Application.php", "output": "<?php\n\nnamespace Ephect\\Modules\\WebApp\\Web;\n\nuse Ephect\\Framework\\CLI\\Console;\nuse Ephect\\Framework\\Core\\AbstractApplication;\nuse Ephect\\Framework\\Core\\ConstantsMaker;\nuse Ephect\\Framework\\Registry\\FrameworkRegistry;\nuse Ephect\\Framework\\Registry\\HooksRegistry;\nuse Ephect\\Framework\\Registry\\StateRegistry;\nuse Ephect\\Modules\\Forms\\Components\\Component;\nuse Ephect\\Modules\\Forms\\Registry\\CacheRegistry;\nuse Ephect\\Modules\\Forms\\Registry\\ComponentRegistry;\nuse Ephect\\Modules\\Forms\\Registry\\PluginRegistry;\nuse Ephect\\Modules\\WebApp\\Services\\BuildService;\n\nclass Application extends AbstractApplication\n{\n    private string $html = '';\n\n    public static function create(...$params): self\n    {\n        self::$instance = new Application();\n        self::$instance->run(...$params);\n\n        return self::$instance;\n    }\n\n    public function run(...$params): int\n    {\n        $this->loadInFile();\n        StateRegistry::load();\n        if (!ComponentRegistry::load()) {\n            $service = new BuildService();\n            $service->build();\n        }\n\n        CacheRegistry::load();\n        PluginRegistry::load();\n        FrameworkRegistry::load();\n        FrameworkRegistry::registerBuiltComponents();\n        FrameworkRegistry::save();\n\n        $this->execute();\n\n        return 0;\n    }\n\n    /**\n     * @throws \\ReflectionException\n     */\n    protected function execute(): int\n    {\n        $app = new Component('App');\n\n        //        ob_start();\n        $app->render();\n        //        $this->html = ob_get_clean();\n\n        return 0;\n    }\n\n    public function getHtml(): string\n    {\n        return $this->html;\n    }\n\n    public function displayConstants(): array\n    {\n        $maker = new ConstantsMaker();\n        $constants = $maker->list();\n        StateRegistry::writeItem('console', ['buffer' => $constants]);\n\n        Console::Log('Application constants are :');\n        $maker->log();\n\n        return $constants;\n    }\n\n\n}"}
{"instruction": "Write an Ephect command handler", "input": "Based on Ephect source: Lib.php", "output": "<?php\n\nnamespace Ephect\\Modules\\WebApp\\Commands\\Build;\n\nuse Ephect\\Framework\\Commands\\AbstractCommandLib;\nuse Ephect\\Modules\\WebApp\\Builder\\Builder;\nuse Ephect\\Modules\\WebApp\\Services\\BuildService;\n\nclass Lib extends AbstractCommandLib\n{\n    public function build(): void\n    {\n        $application = $this->parent;\n\n        $application->clearRuntime();\n        $application->clearLogs();\n\n        $service = new BuildService();\n        $builder = $service->build();\n\n        $builder->buildAllRoutes();\n\n    }\n}"}
{"instruction": "Write an Ephect PHP component", "input": "Based on Ephect source: Logo.php", "output": "<?php\n\nreturn <<< LOGO\n\u001b[38;5;16m                             \u001b[0m\u001b[38;5;16m \u001b[0m\u001b[38;5;16m \u001b[0m\u001b[38;5;59m\u2588\u001b[0m\u001b[38;5;59m\u2588\u001b[0m\u001b[38;5;16m \u001b[0m\u001b[38;5;16m \u001b[0m\u001b[38;5;16m                             \u001b[0m\n\u001b[38;5;16m                          \u001b[0m\u001b[38;5;16m \u001b[0m\u001b[38;5;58m \u001b[0m\u001b[38;5;95m\u2588\u001b[0m\u001b[38;5;96m\u2588\u001b[0m\u001b[38;5;133m\u2588\u001b[0m\u001b[38;5;164m\u2588\u001b[0m\u001b[38;5;92m\u2588\u001b[0m\u001b[38;5;97m\u2588\u001b[0m\u001b[38;5;96m\u2588\u001b[0m\u001b[38;5;59m\u2588\u001b[0m\u001b[38;5;58m\u2588\u001b[0m\u001b[38;5;16m \u001b[0m\u001b[38;5;16m                          \u001b[0m\n\u001b[38;5;16m                      \u001b[0m\u001b[38;5;16m \u001b[0m\u001b[38;5;16m \u001b[0m\u001b[38;5;59m\u2588\u001b[0m\u001b[38;5;96m\u2588\u001b[0m\u001b[38;5;133m\u2588\u001b[0m\u001b[38;5;170m\u2588\u001b[0m\u001b[38;5;201m\u2588\u001b[0m\u001b[38;5;201m\u2588\u001b[0m\u001b[38;5;201m\u2588\u001b[0m\u001b[38;5;201m\u2588\u001b[0m\u001b[38;5;93m\u2588\u001b[0m\u001b[38;5;93m\u2588\u001b[0m\u001b[38;5;93m\u2588\u001b[0m\u001b[38;5;92m\u2588\u001b[0m\u001b[38;5;98m\u2588\u001b[0m\u001b[38;5;97m\u2588\u001b[0m\u001b[38;5;96m\u2588\u001b[0m\u001b[38;5;59m\u2588\u001b[0m\u001b[38;5;16m \u001b[0m\u001b[38;5;16m \u001b[0m\u001b[38;5;16m                      \u001b[0m\n\u001b[38;5;16m                   \u001b[0m\u001b[38;5;16m \u001b[0m\u001b[38;5;16m \u001b[0m\u001b[38;5;59m\u2588\u001b[0m\u001b[38;5;102m\u2588\u001b[0m\u001b[38;5;133m\u2588\u001b[0m\u001b[38;5;164m\u2588\u001b[0m\u001b[38;5;201m\u2588\u001b[0m\u001b[38;5;201m\u2588\u001b[0m\u001b[38;5;201m\u2588\u001b[0m\u001b[38;5;201m\u2588\u001b[0m\u001b[38;5;201m\u2588\u001b[0m\u001b[38;5;201m\u2588\u001b[0m\u001b[38;5;171m\u2588\u001b[0m\u001b[38;5;135m\u2588\u001b[0m\u001b[38;5;129m\u2588\u001b[0m\u001b[38;5;93m\u2588\u001b[0m\u001b[38;5;93m\u2588\u001b[0m\u001b[38;5;93m\u2588\u001b[0m\u001b[38;5;93m\u2588\u001b[0m\u001b[38;5;93m\u2588\u001b[0m\u001b[38;5;92m\u2588\u001b[0m\u001b[38;5;97m\u2588\u001b[0m\u001b[38;5;96m\u2588\u001b[0m\u001b[38;5;59m\u2588\u001b[0m\u001b[38;5;16m \u001b[0m\u001b[38;5;16m \u001b[0m\u001b[38;5;16m                   \u001b[0m\n\u001b[38;5;16m               \u001b[0m\u001b[38;5;16m \u001b[0m\u001b[38;5;16m \u001b[0m\u001b[38;5;59m\u2588\u001b[0m\u001b[38;5;96m\u2588\u001b[0m\u001b[38;5;133m\u2588\u001b[0m\u001b[38;5;170m\u2588\u001b[0m\u001b[38;5;201m\u2588\u001b[0m\u001b[38;5;201m\u2588\u001b[0m\u001b[38;5;201m\u2588\u001b[0m\u001b[38;5;201m\u2588\u001b[0m\u001b[38;5;201m\u2588\u001b[0m\u001b[38;5;201m\u2588\u001b[0m\u001b[38;5;165m\u2588\u001b[0m\u001b[38;5;177m\u2588\u001b[0m\u001b[38;5;189m\u2588\u001b[0m\u001b[38;5;195m\u2588\u001b[0m\u001b[38;5;195m\u2588\u001b[0m\u001b[38;5;195m\u2588\u001b[0m\u001b[38;5;195m\u2588\u001b[0m\u001b[38;5;189m\u2588\u001b[0m\u001b[38;5;105m\u2588\u001b[0m\u001b[38;5;99m\u2588\u001b[0m\u001b[38;5;135m\u2588\u001b[0m\u001b[38;5;129m\u2588\u001b[0m\u001b[38;5;129m\u2588\u001b[0m\u001b[38;5;93m\u2588\u001b[0m\u001b[38;5;93m\u2588\u001b[0m\u001b[38;5;92m\u2588\u001b[0m\u001b[38;5;92m\u2588\u001b[0m\u001b[38;5;97m\u2588\u001b[0m\u001b[38;5;96m\u2588\u001b[0m\u001b[38;5;59m\u2588\u001b[0m\u001b[38;5;16m \u001b[0m\u001b[38;5;16m \u001b[0m\u001b[38;5;16m               \u001b[0m\n\u001b[38;5;16m            \u001b[0m\u001b[38;5;16m \u001b[0m\u001b[38;5;16m \u001b[0m\u001b[38;5;59m\u2588\u001b[0m\u001b[38;5;96m\u2588\u001b[0m\u001b[38;5;133m\u2588\u001b[0m\u001b[38;5;170m\u2588\u001b[0m\u001b[38;5;201m\u2588\u001b[0m\u001b[38;5;201m\u2588\u001b[0m\u001b[38;5;201m\u2588\u001b[0m\u001b[38;5;201m\u2588\u001b[0m\u001b[38;5;201m\u2588\u001b[0m\u001b[38;5;201m\u2588\u001b[0m\u001b[38;5;171m\u2588\u001b[0m\u001b[38;5;183m\u2588\u001b[0m\u001b[38;5;225m\u2588\u001b[0m\u001b[38;5;231m\u2588\u001b[0m\u001b[38;5;231m\u2588\u001b[0m\u001b[38;5;231m\u2588\u001b[0m\u001b[38;5;225m\u2588\u001b[0m\u001b[38;5;225m\u2588\u001b[0m\u001b[38;5;225m\u2588\u001b[0m\u001b[38;5;219m\u2588\u001b[0m\u001b[38;5;219m\u2588\u001b[0m\u001b[38;5;219m\u2588\u001b[0m\u001b[38;5;219m\u2588\u001b[0m\u001b[38;5;183m\u2588\u001b[0m\u001b[38;5;183m\u2588\u001b[0m\u001b[38;5;183m\u2588\u001b[0m\u001b[38;5;183m\u2588\u001b[0m\u001b[38;5;183m\u2588\u001b[0m\u001b[38;5;177m\u2588\u001b[0m\u001b[38;5;135m\u2588\u001b[0m\u001b[38;5;129m\u2588\u001b[0m\u001b[38;5;93m\u2588\u001b[0m\u001b[38;5;92m\u2588\u001b[0m\u001b[38;5;97m\u2588\u001b[0m\u001b[38;5;96m\u2588\u001b[0m\u001b[38;5;59m\u2588\u001b[0m\u001b[38;5;16m \u001b[0m\u001b[38;5;16m \u001b[0m\u001b[38;5;16m            \u001b[0m\n\u001b[38;5;16m        \u001b[0m\u001b[38;5;16m \u001b[0m\u001b[38;5;16m \u001b[0m\u001b[38;5;59m\u2588\u001b[0m\u001b[38;5;102m\u2588\u001b[0m\u001b[38;5;133m\u2588\u001b[0m\u001b[38;5;170m\u2588\u001b[0m\u001b[38;5;201m\u2588\u001b[0m\u001b[38;5;201m\u2588\u001b[0m\u001b[38;5;201m\u2588\u001b[0m\u001b[38;5;201m\u2588\u001b[0m\u001b[38;5;201m\u2588\u001b[0m\u001b[38;5;201m\u2588\u001b[0m\u001b[38;5;201m\u2588\u001b[0m\u001b[38;5;177m\u2588\u001b[0m\u001b[38;5;189m\u2588\u001b[0m\u001b[38;5;231m\u2588\u001b[0m\u001b[38;5;231m\u2588\u001b[0m\u001b[38;5;225m\u2588\u001b[0m\u001b[38;5;219m\u2588\u001b[0m\u001b[38;5;213m\u2588\u001b[0m\u001b[38;5;207m\u2588\u001b[0m\u001b[38;5;201m\u2588\u001b[0m\u001b[38;5;201m\u2588\u001b[0m\u001b[38;5;201m\u2588\u001b[0m\u001b[38;5;201m\u2588\u001b[0m\u001b[38;5;201m\u2588\u001b[0m\u001b[38;5;201m\u2588\u001b[0m\u001b[38;5;165m\u2588\u001b[0m\u001b[38;5;129m\u2588\u001b[0m\u001b[38;5;93m\u2588\u2588\u001b[0m\u001b[38;5;93m\u2588\u001b[0m\u001b[38;5;129m\u2588\u001b[0m\u001b[38;5;135m\u2588\u001b[0m\u001b[38;5;135m\u2588\u001b[0m\u001b[38;5;177m\u2588\u001b[0m\u001b[38;5;183m\u2588\u001b[0m\u001b[38;5;189m\u2588\u001b[0m\u001b[38;5;183m\u2588\u001b[0m\u001b[38;5;135m\u2588\u001b[0m\u001b[38;5;93m\u2588\u001b[0m\u001b[38;5;92m\u2588\u001b[0m\u001b[38;5;91m\u2588\u001b[0m\u001b[38;5;97m\u2588\u001b[0m\u001b[38;5;96m\u2588\u001b[0m\u001b[38;5;59m\u2588\u001b[0m\u001b[38;5;16m \u001b[0m\u001b[38;5;16m \u001b[0m\u001b[38;5;16m        \u001b[0m\n\u001b[38;5;16m     \u001b[0m\u001b[38;5;16m \u001b[0m\u001b[38;5;16m \u001b[0m\u001b[38;5;59m\u2588\u001b[0m\u001b[38;5;96m\u2588\u001b[0m\u001b[38;5;133m\u2588\u001b[0m\u001b[38;5;170m\u2588\u001b[0m\u001b[38;5;201m\u2588\u001b[0m\u001b[38;5;201m\u2588\u001b[0m\u001b[38;5;201m\u2588\u001b[0m\u001b[38;5;201m\u2588\u001b[0m\u001b[38;5;201m\u2588\u001b[0m\u001b[38;5;201m\u2588\u001b[0m\u001b[38;5;171m\u2588\u001b[0m\u001b[38;5;177m\u2588\u001b[0m\u001b[38;5;225m\u2588\u001b[0m\u001b[38;5;231m\u2588\u001b[0m\u001b[38;5;231m\u2588\u001b[0m\u001b[38;5;225m\u2588\u001b[0m\u001b[38;5;213m\u2588\u001b[0m\u001b[38;5;201m\u2588\u001b[0m\u001b[38;5;201m\u2588\u001b[0m\u001b[38;5;165m\u2588\u001b[0m\u001b[38;5;165m\u2588\u001b[0m\u001b[38;5;129m\u2588\u001b[0m\u001b[38;5;129m\u2588\u001b[0m\u001b[38;5;129m\u2588\u001b[0m\u001b[38;5;129m\u2588\u001b[0m\u001b[38;5;93m\u2588\u001b[0m\u001b[38;5;93m\u2588\u001b[0m\u001b[38;5;93m\u2588\u001b[0m\u001b[38;5;93m\u2588\u001b[0m\u001b[38;5;93m\u2588\u001b[0m\u001b[38;5;93m\u2588\u2588\u001b[0m\u001b[38;5;93m\u2588\u001b[0m\u001b[38;5;93m\u2588\u001b[0m\u001b[38;5;93m\u2588\u001b[0m\u001b[38;5;93m\u2588\u001b[0m\u001b[38;5;93m\u2588\u001b[0m\u001b[38;5;93m\u2588\u001b[0m\u001b[38;5;129m\u2588\u001b[0m\u001b[38;5;141m\u2588\u001b[0m\u001b[38;5;183m\u2588\u001b[0m\u001b[38;5;189m\u2588\u001b[0m\u001b[38;5;177m\u2588\u001b[0m\u001b[38;5;93m\u2588\u001b[0m\u001b[38;5;93m\u2588\u001b[0m\u001b[38;5;92m\u2588\u001b[0m\u001b[38;5;92m\u2588\u001b[0m\u001b[38;5;97m\u2588\u001b[0m\u001b[38;5;96m\u2588\u001b[0m\u001b[38;5;59m\u2588\u001b[0m\u001b[38;5;16m \u001b[0m\u001b[38;5;16m \u001b[0m\u001b[38;5;16m     \u001b[0m\n\u001b[38;5;16m    \u001b[0m\u001b[38;5;16m \u001b[0m\u001b[38;5;102m\u2588\u001b[0m\u001b[38;5;133m\u2588\u001b[0m\u001b[38;5;165m\u2588\u001b[0m\u001b[38;5;201m\u2588\u001b[0m\u001b[38;5;201m\u2588\u001b[0m\u001b[38;5;201m\u2588\u001b[0m\u001b[38;5;201m\u2588\u001b[0m\u001b[38;5;201m\u2588\u001b[0m\u001b[38;5;201m\u2588\u001b[0m\u001b[38;5;213m\u2588\u001b[0m\u001b[38;5;219m\u2588\u001b[0m\u001b[38;5;189m\u2588\u001b[0m\u001b[38;5;195m\u2588\u001b[0m\u001b[38;5;195m\u2588\u001b[0m\u001b[38;5;231m\u2588\u001b[0m\u001b[38;5;219m\u2588\u001b[0m\u001b[38;5;201m\u2588\u001b[0m\u001b[38;5;201m\u2588\u001b[0m\u001b[38;5;165m\u2588\u001b[0m\u001b[38;5;129m\u2588\u001b[0m\u001b[38;5;129m\u2588\u001b[0m\u001b[38;5;93m\u2588\u001b[0m\u001b[38;5;93m\u2588\u2588\u001b[0m\u001b[38;5;93m\u2588\u001b[0m\u001b[38;5;93m\u2588\u001b[0m\u001b[38;5;93m\u2588\u001b[0m\u001b[38;5;93m\u2588\u001b[0m\u001b[38;5;93m\u2588\u001b[0m\u001b[38;5;93m\u2588\u2588\u001b[0m\u001b[38;5;93m\u2588\u001b[0m\u001b[38;5;93m\u2588\u001b[0m\u001b[38;5;93m\u2588\u001b[0m\u001b[38;5;93m\u2588\u2588\u001b[0m\u001b[38;5;93m\u2588\u001b[0m\u001b[38;5;93m\u2588\u001b[0m\u001b[38;5;93m\u2588\u001b[0m\u001b[38;5;129m\u2588\u001b[0m\u001b[38;5;93m\u2588\u001b[0m\u001b[38;5;93m\u2588\u001b[0m\u001b[38;5;93m\u2588\u001b[0m\u001b[38;5;135m\u2588\u001b[0m\u001b[38;5;183m\u2588\u001b[0m\u001b[38;5;225m\u2588\u001b[0m\u001b[38;5;177m\u2588\u001b[0m\u001b[38;5;93m\u2588\u001b[0m\u001b[38;5;93m\u2588\u001b[0m\u001b[38;5;129m\u2588\u001b[0m\u001b[38;5;93m\u2588\u001b[0m\u001b[38;5;92m\u2588\u001b[0m\u001b[38;5;96m\u2588\u001b[0m\u001b[38;5;102m\u2588\u001b[0m\u001b[38;5;16m \u001b[0m\u001b[38;5;16m    \u001b[0m\n\u001b[38;5;16m    \u001b[0m\u001b[38;5;16m \u001b[0m\u001b[38;5;102m\u2588\u001b[0m\u001b[38;5;128m\u2588\u001b[0m\u001b[38;5;165m\u2588\u001b[0m\u001b[38;5;165m\u2588\u001b[0m\u001b[38;5;201m\u2588\u001b[0m\u001b[38;5;165m\u2588\u001b[0m\u001b[38;5;177m\u2588\u001b[0m\u001b[38;5;189m\u2588\u001b[0m\u001b[38;5;189m\u2588\u001b[0m\u001b[38;5;159m\u2588\u001b[0m\u001b[38;5;123m\u2588\u001b[0m\u001b[38;5;159m\u2588\u001b[0m\u001b[38;5;231m\u2588\u001b[0m\u001b[38;5;219m\u2588\u001b[0m\u001b[38;5;201m\u2588\u001b[0m\u001b[38;5;201m\u2588\u001b[0m\u001b[38;5;165m\u2588\u001b[0m\u001b[38;5;129m\u2588\u001b[0m\u001b[38;5;93m\u2588\u001b[0m\u001b[38;5;93m\u2588\u001b[0m\u001b[38;5;93m\u2588\u001b[0m\u001b[38;5;93m\u2588\u001b[0m\u001b[38;5;93m\u2588\u001b[0m\u001b[38;5;129m\u2588\u001b[0m\u001b[38;5;129m\u2588\u001b[0m\u001b[38;5;135m\u2588\u001b[0m\u001b[38;5;177m\u2588\u001b[0m\u001b[38;5;147m\u2588\u001b[0m\u001b[38;5;147m\u2588\u001b[0m\u001b[38;5;189m\u2588\u001b[0m\u001b[38;5;183m\u2588\u001b[0m\u001b[38;5;147m\u2588\u001b[0m\u001b[38;5;141m\u2588\u001b[0m\u001b[38;5;177m\u2588\u001b[0m\u001b[38;5;135m\u2588\u001b[0m\u001b[38;5;129m\u2588\u001b[0m\u001b[38;5;93m\u2588\u001b[0m\u001b[38;5;93m\u2588\u001b[0m\u001b[38;5;93m\u2588\u001b[0m\u001b[38;5;129m\u2588\u001b[0m\u001b[38;5;129m\u2588\u001b[0m\u001b[38;5;129m\u2588\u2588\u001b[0m\u001b[38;5;93m\u2588\u001b[0m\u001b[38;5;93m\u2588\u001b[0m\u001b[38;5;129m\u2588\u001b[0m\u001b[38;5;189m\u2588\u001b[0m\u001b[38;5;225m\u2588\u001b[0m\u001b[38;5;135m\u2588\u001b[0m\u001b[38;5;92m\u2588\u001b[0m\u001b[38;5;54m\u2588\u001b[0m\u001b[38;5;54m\u2588\u001b[0m\u001b[38;5;53m\u2588\u001b[0m\u001b[38;5;102m\u2588\u001b[0m\u001b[38;5;16m \u001b[0m\u001b[38;5;16m    \u001b[0m\n\u001b[38;5;16m    \u001b[0m\u001b[38;5;16m \u001b[0m\u001b[38;5;102m\u2588\u001b[0m\u001b[38;5;128m\u2588\u001b[0m\u001b[38;5;165m\u2588\u001b[0m\u001b[38;5;165m\u2588\u001b[0m\u001b[38;5;165m\u2588\u001b[0m\u001b[38;5;171m\u2588\u001b[0m\u001b[38;5;231m\u2588\u001b[0m\u001b[38;5;117m\u2588\u001b[0m\u001b[38;5;75m\u2588\u001b[0m\u001b[38;5;75m\u2588\u001b[0m\u001b[38;5;159m\u2588\u001b[0m\u001b[38;5;231m\u2588\u001b[0m\u001b[38;5;207m\u2588\u001b[0m\u001b[38;5;201m\u2588\u001b[0m\u001b[38;5;201m\u2588\u001b[0m\u001b[38;5;129m\u2588\u001b[0m\u001b[38;5;93m\u2588\u001b[0m\u001b[38;5;129m\u2588\u001b[0m\u001b[38;5;129m\u2588\u001b[0m\u001b[38;5;93m\u2588\u001b[0m\u001b[38;5;93m\u2588\u001b[0m\u001b[38;5;135m\u2588\u001b[0m\u001b[38;5;183m\u2588\u001b[0m\u001b[38;5;189m\u2588\u001b[0m\u001b[38;5;195m\u2588\u001b[0m\u001b[38;5;153m\u2588\u001b[0m\u001b[38;5;153m\u2588\u001b[0m\u001b[38;5;117m\u2588\u001b[0m\u001b[38;5;117m\u2588\u001b[0m\u001b[38;5;117m\u2588\u001b[0m\u001b[38;5;117m\u2588\u001b[0m\u001b[38;5;117m\u2588\u001b[0m\u001b[38;5;117m\u2588\u001b[0m\u001b[38;5;153m\u2588\u001b[0m\u001b[38;5;153m\u2588\u001b[0m\u001b[38;5;195m\u2588\u001b[0m\u001b[38;5;189m\u2588\u001b[0m\u001b[38;5;177m\u2588\u001b[0m\u001b[38;5;129m\u2588\u001b[0m\u001b[38;5;93m\u2588\u001b[0m\u001b[38;5;129m\u2588\u001b[0m\u001b[38;5;129m\u2588\u2588\u001b[0m\u001b[38;5;129m\u2588\u001b[0m\u001b[38;5;129m\u2588\u001b[0m\u001b[38;5;93m\u2588\u001b[0m\u001b[38;5;93m\u2588\u001b[0m\u001b[38;5;177m\u2588\u001b[0m\u001b[38;5;225m\u2588\u001b[0m\u001b[38;5;104m\u2588\u001b[0m\u001b[38;5;54m\u2588\u001b[0m\u001b[38;5;53m\u2588\u001b[0m\u001b[38;5;53m\u2588\u001b[0m\u001b[38;5;102m\u2588\u001b[0m\u001b[38;5;16m \u001b[0m\u001b[38;5;16m    \u001b[0m\n\u001b[38;5;16m    \u001b[0m\u001b[38;5;16m \u001b[0m\u001b[38;5;102m\u2588\u001b[0m\u001b[38;5;128m\u2588\u001b[0m\u001b[38;5;165m\u2588\u001b[0m\u001b[38;5;165m\u2588\u001b[0m\u001b[38;5;165m\u2588\u001b[0m\u001b[38;5;171m\u2588\u001b[0m\u001b[38;5;231m\u2588\u001b[0m\u001b[38;5;111m\u2588\u001b[0m\u001b[38;5;75m\u2588\u001b[0m\u001b[38;5;153m\u2588\u001b[0m\u001b[38;5;231m\u2588\u001b[0m\u001b[38;5;207m\u2588\u001b[0m\u001b[38;5;201m\u2588\u001b[0m\u001b[38;5;165m\u2588\u001b[0m\u001b[38;5;129m\u2588\u001b[0m\u001b[38;5;93m\u2588\u001b[0m\u001b[38;5;129m\u2588\u001b[0m\u001b[38;5;129m\u2588\u001b[0m\u001b[38;5;93m\u2588\u001b[0m\u001b[38;5;135m\u2588\u001b[0m\u001b[38;5;183m\u2588\u001b[0m\u001b[38;5;189m\u2588\u001b[0m\u001b[38;5;153m\u2588\u001b[0m\u001b[38;5;111m\u2588\u001b[0m\u001b[38;5;75m\u2588\u001b[0m\u001b[38;5;75m\u2588\u2588\u001b[0m\u001b[38;5;75m\u2588\u001b[0m\u001b[38;5;75m\u2588\u001b[0m\u001b[38;5;111m\u2588\u001b[0m\u001b[38;5;111m\u2588\u001b[0m\u001b[38;5;111m\u2588\u001b[0m\u001b[38;5;111m\u2588\u001b[0m\u001b[38;5;111m\u2588\u001b[0m\u001b[38;5;111m\u2588\u001b[0m\u001b[38;5;111m\u2588\u001b[0m\u001b[38;5;111m\u2588\u001b[0m\u001b[38;5;153m\u2588\u001b[0m\u001b[38;5;189m\u2588\u001b[0m\u001b[38;5;183m\u2588\u001b[0m\u001b[38;5;129m\u2588\u001b[0m\u001b[38;5;129m\u2588\u001b[0m\u001b[38;5;129m\u2588\u001b[0m\u001b[38;5;93m\u2588\u001b[0m\u001b[38;5;129m\u2588\u001b[0m\u001b[38;5;129m\u2588\u001b[0m\u001b[38;5;129m\u2588\u001b[0m\u001b[38;5;135m\u2588\u001b[0m\u001b[38;5;183m\u2588\u001b[0m\u001b[38;5;189m\u2588\u001b[0m\u001b[38;5;62m\u2588\u001b[0m\u001b[38;5;54m\u2588\u001b[0m\u001b[38;5;53m\u2588\u001b[0m\u001b[38;5;102m\u2588\u001b[0m\u001b[38;5;16m \u001b[0m\u001b[38;5;16m    \u001b[0m\n\u001b[38;5;16m    \u001b[0m\u001b[38;5;16m \u001b[0m\u001b[38;5;102m\u2588\u001b[0m\u001b[38;5;128m\u2588\u001b[0m\u001b[38;5;165m\u2588\u001b[0m\u001b[38;5;165m\u2588\u001b[0m\u001b[38;5;165m\u2588\u001b[0m\u001b[38;5;171m\u2588\u001b[0m\u001b[38;5;231m\u2588\u001b[0m\u001b[38;5;111m\u2588\u001b[0m\u001b[38;5;147m\u2588\u001b[0m\u001b[38;5;231m\u2588\u001b[0m\u001b[38;5;207m\u2588\u001b[0m\u001b[38;5;201m\u2588\u001b[0m\u001b[38;5;165m\u2588\u001b[0m\u001b[38;5;129m\u2588\u001b[0m\u001b[38;5;129m\u2588\u001b[0m\u001b[38;5;129m\u2588\u001b[0m\u001b[38;5;129m\u2588\u001b[0m\u001b[38;5;93m\u2588\u001b[0m\u001b[38;5;177m\u2588\u001b[0m\u001b[38;5;231m\u2588\u001b[0m\u001b[38;5;147m\u2588\u001b[0m\u001b[38;5;105m\u2588\u001b[0m\u001b[38;5;105m\u2588\u001b[0m\u001b[38;5;111m\u2588\u001b[0m\u001b[38;5;147m\u2588\u001b[0m\u001b[38;5;153m\u2588\u001b[0m\u001b[38;5;189m\u2588\u001b[0m\u001b[38;5;189m\u2588\u001b[0m\u001b[38;5;147m\u2588\u001b[0m\u001b[38;5;111m\u2588\u001b[0m\u001b[38;5;111m\u2588\u001b[0m\u001b[38;5;105m\u2588\u001b[0m\u001b[38;5;105m\u2588\u001b[0m\u001b[38;5;105m\u2588\u001b[0m\u001b[38;5;105m\u2588\u001b[0m\u001b[38;5;105m\u2588\u001b[0m\u001b[38;5;105m\u2588\u001b[0m\u001b[38;5;105m\u2588\u001b[0m\u001b[38;5;105m\u2588\u001b[0m\u001b[38;5;153m\u2588\u001b[0m\u001b[38;5;189m\u2588\u001b[0m\u001b[38;5;183m\u2588\u001b[0m\u001b[38;5;141m\u2588\u001b[0m\u001b[38;5;141m\u2588\u001b[0m\u001b[38;5;141m\u2588\u001b[0m\u001b[38;5;183m\u2588\u001b[0m\u001b[38;5;189m\u2588\u001b[0m\u001b[38;5;231m\u2588\u001b[0m\u001b[38;5;141m\u2588\u001b[0m\u001b[38;5;54m\u2588\u001b[0m\u001b[38;5;53m\u2588\u001b[0m\u001b[38;5;53m\u2588\u001b[0m\u001b[38;5;53m\u2588\u001b[0m\u001b[38;5;102m\u2588\u001b[0m\u001b[38;5;16m \u001b[0m\u001b[38;5;16m    \u001b[0m\n\u001b[38;5;16m    \u001b[0m\u001b[38;5;16m \u001b[0m\u001b[38;5;102m\u2588\u001b[0m\u001b[38;5;128m\u2588\u001b[0m\u001b[38;5;165m\u2588\u001b[0m\u001b[38;5;165m\u2588\u001b[0m\u001b[38;5;165m\u2588\u001b[0m\u001b[38;5;171m\u2588\u001b[0m\u001b[38;5;231m\u2588\u001b[0m\u001b[38;5;105m\u2588\u001b[0m\u001b[38;5;189m\u2588\u001b[0m\u001b[38;5;219m\u2588\u001b[0m\u001b[38;5;201m\u2588\u001b[0m\u001b[38;5;201m\u2588\u001b[0m\u001b[38;5;129m\u2588\u001b[0m\u001b[38;5;93m\u2588\u001b[0m\u001b[38;5;129m\u2588\u001b[0m\u001b[38;5;129m\u2588\u001b[0m\u001b[38;5;93m\u2588\u001b[0m\u001b[38;5;177m\u2588\u001b[0m\u001b[38;5;231m\u2588\u001b[0m\u001b[38;5;105m\u2588\u001b[0m\u001b[38;5;105m\u2588\u001b[0m\u001b[38;5;147m\u2588\u001b[0m\u001b[38;5;195m\u2588\u001b[0m\u001b[38;5;189m\u2588\u001b[0m\u001b[38;5;177m\u2588\u001b[0m\u001b[38;5;171m\u2588\u001b[0m\u001b[38;5;207m\u2588\u001b[0m\u001b[38;5;207m\u2588\u001b[0m\u001b[38;5;171m\u2588\u001b[0m\u001b[38;5;183m\u2588\u001b[0m\u001b[38;5;189m\u2588\u001b[0m\u001b[38;5;189m\u2588\u001b[0m\u001b[38;5;147m\u2588\u001b[0m\u001b[38;5;105m\u2588\u001b[0m\u001b[38;5;105m\u2588\u001b[0m\u001b[38;5;105m\u2588\u001b[0m\u001b[38;5;147m\u2588\u001b[0m\u001b[38;5;147m\u2588\u001b[0m\u001b[38;5;105m\u2588\u001b[0m\u001b[38;5;105m\u2588\u001b[0m\u001b[38;5;105m\u2588\u001b[0m\u001b[38;5;105m\u2588\u001b[0m\u001b[38;5;105m\u2588\u001b[0m\u001b[38;5;105m\u2588\u001b[0m\u001b[38;5;105m\u2588\u001b[0m\u001b[38;5;105m\u2588\u001b[0m\u001b[38;5;105m\u2588\u001b[0m\u001b[38;5;231m\u2588\u001b[0m\u001b[38;5;135m\u2588\u001b[0m\u001b[38;5;53m\u2588\u001b[0m\u001b[38;5;53m\u2588\u001b[0m\u001b[38;5;53m\u2588\u001b[0m\u001b[38;5;53m\u2588\u001b[0m\u001b[38;5;102m\u2588\u001b[0m\u001b[38;5;16m \u001b[0m\u001b[38;5;16m    \u001b[0m\n\u001b[38;5;16m    \u001b[0m\u001b[38;5;16m \u001b[0m\u001b[38;5;102m\u2588\u001b[0m\u001b[38;5;128m\u2588\u001b[0m\u001b[38;5;165m\u2588\u001b[0m\u001b[38;5;165m\u2588\u001b[0m\u001b[38;5;165m\u2588\u001b[0m\u001b[38;5;171m\u2588\u001b[0m\u001b[38;5;231m\u2588\u001b[0m\u001b[38;5;147m\u2588\u001b[0m\u001b[38;5;231m\u2588\u001b[0m\u001b[38;5;207m\u2588\u001b[0m\u001b[38;5;201m\u2588\u001b[0m\u001b[38;5;165m\u2588\u001b[0m\u001b[38;5;93m\u2588\u001b[0m\u001b[38;5;129m\u2588\u2588\u001b[0m\u001b[38;5;93m\u2588\u001b[0m\u001b[38;5;129m\u2588\u001b[0m\u001b[38;5;231m\u2588\u001b[0m\u001b[38;5;141m\u2588\u001b[0m\u001b[38;5;99m\u2588\u001b[0m\u001b[38;5;147m\u2588\u001b[0m\u001b[38;5;225m\u2588\u001b[0m\u001b[38;5;135m\u2588\u001b[0m\u001b[38;5;129m\u2588\u001b[0m\u001b[38;5;129m\u2588\u001b[0m\u001b[38;5;129m\u2588\u001b[0m\u001b[38;5;165m\u2588\u001b[0m\u001b[38;5;201m\u2588\u001b[0m\u001b[38;5;201m\u2588\u2588\u001b[0m\u001b[38;5;201m\u2588\u001b[0m\u001b[38;5;207m\u2588\u001b[0m\u001b[38;5;183m\u2588\u001b[0m\u001b[38;5;183m\u2588\u001b[0m\u001b[38;5;183m\u2588\u001b[0m\u001b[38;5;183m\u2588\u001b[0m\u001b[38;5;177m\u2588\u001b[0m\u001b[38;5;231m\u2588\u001b[0m\u001b[38;5;189m\u2588\u001b[0m\u001b[38;5;99m\u2588\u001b[0m\u001b[38;5;105m\u2588\u001b[0m\u001b[38;5;105m\u2588\u001b[0m\u001b[38;5;105m\u2588\u001b[0m\u001b[38;5;105m\u2588\u001b[0m\u001b[38;5;105m\u2588\u001b[0m\u001b[38;5;99m\u2588\u001b[0m\u001b[38;5;105m\u2588\u001b[0m\u001b[38;5;231m\u2588\u001b[0m\u001b[38;5;135m\u2588\u001b[0m\u001b[38;5;53m\u2588\u001b[0m\u001b[38;5;53m\u2588\u001b[0m\u001b[38;5;53m\u2588\u001b[0m\u001b[38;5;53m\u2588\u001b[0m\u001b[38;5;102m\u2588\u001b[0m\u001b[38;5;16m \u001b[0m\u001b[38;5;16m    \u001b[0m\n\u001b[38;5;16m    \u001b[0m\u001b[38;5;16m \u001b[0m\u001b[38;5;102m\u2588\u001b[0m\u001b[38;5;128m\u2588\u001b[0m\u001b[38;5;165m\u2588\u001b[0m\u001b[38;5;165m\u2588\u001b[0m\u001b[38;5;165m\u2588\u001b[0m\u001b[38;5;171m\u2588\u001b[0m\u001b[38;5;231m\u2588\u001b[0m\u001b[38;5;141m\u2588\u001b[0m\u001b[38;5;231m\u2588\u001b[0m\u001b[38;5;207m\u2588\u001b[0m\u001b[38;5;201m\u2588\u001b[0m\u001b[38;5;129m\u2588\u001b[0m\u001b[38;5;129m\u2588\u001b[0m\u001b[38;5;129m\u2588\u001b[0m\u001b[38;5;129m\u2588\u001b[0m\u001b[38;5;93m\u2588\u001b[0m\u001b[38;5;135m\u2588\u001b[0m\u001b[38;5;225m\u2588\u001b[0m\u001b[38;5;99m\u2588\u001b[0m\u001b[38;5;141m\u2588\u001b[0m\u001b[38;5;231m\u2588\u001b[0m\u001b[38;5;177m\u2588\u001b[0m\u001b[38;5;177m\u2588\u001b[0m\u001b[38;5;183m\u2588\u001b[0m\u001b[38;5;183m\u2588\u001b[0m\u001b[38;5;177m\u2588\u001b[0m\u001b[38;5;129m\u2588\u001b[0m\u001b[38;5;93m\u2588\u001b[0m\u001b[38;5;129m\u2588\u001b[0m\u001b[38;5;165m\u2588\u001b[0m\u001b[38;5;201m\u2588\u001b[0m\u001b[38;5;201m\u2588\u001b[0m\u001b[38;5;201m\u2588\u001b[0m\u001b[38;5;201m\u2588\u001b[0m\u001b[38;5;201m\u2588\u001b[0m\u001b[38;5;201m\u2588\u001b[0m\u001b[38;5;165m\u2588\u001b[0m\u001b[38;5;231m\u2588\u001b[0m\u001b[38;5;147m\u2588\u001b[0m\u001b[38;5;99m\u2588\u001b[0m\u001b[38;5;99m\u2588\u2588\u2588\u2588\u2588\u001b[0m\u001b[38;5;99m\u2588\u001b[0m\u001b[38;5;141m\u2588\u001b[0m\u001b[38;5;231m\u2588\u001b[0m\u001b[38;5;135m\u2588\u001b[0m\u001b[38;5;53m\u2588\u001b[0m\u001b[38;5;53m\u2588\u001b[0m\u001b[38;5;53m\u2588\u001b[0m\u001b[38;5;53m\u2588\u001b[0m\u001b[38;5;102m\u2588\u001b[0m\u001b[38;5;16m \u001b[0m\u001b[38;5;16m    \u001b[0m\n\u001b[38;5;16m    \u001b[0m\u001b[38;5;16m \u001b[0m\u001b[38;5;102m\u2588\u001b[0m\u001b[38;5;128m\u2588\u001b[0m\u001b[38;5;165m\u2588\u001b[0m\u001b[38;5;165m\u2588\u001b[0m\u001b[38;5;165m\u2588\u001b[0m\u001b[38;5;171m\u2588\u001b[0m\u001b[38;5;225m\u2588\u001b[0m\u001b[38;5;141m\u2588\u001b[0m\u001b[38;5;231m\u2588\u001b[0m\u001b[38;5;201m\u2588\u001b[0m\u001b[38;5;201m\u2588\u001b[0m\u001b[38;5;129m\u2588\u001b[0m\u001b[38;5;129m\u2588\u001b[0m\u001b[38;5;129m\u2588\u001b[0m\u001b[38;5;129m\u2588\u001b[0m\u001b[38;5;129m\u2588\u001b[0m\u001b[38;5;135m\u2588\u001b[0m\u001b[38;5;225m\u2588\u001b[0m\u001b[38;5;99m\u2588\u001b[0m\u001b[38;5;141m\u2588\u001b[0m\u001b[38;5;183m\u2588\u001b[0m\u001b[38;5;183m\u2588\u001b[0m\u001b[38;5;183m\u2588\u001b[0m\u001b[38;5;135m\u2588\u001b[0m\u001b[38;5;135m\u2588\u001b[0m\u001b[38;5;183m\u2588\u001b[0m\u001b[38;5;225m\u2588\u001b[0m\u001b[38;5;183m\u2588\u001b[0m\u001b[38;5;171m\u2588\u001b[0m\u001b[38;5;129m\u2588\u001b[0m\u001b[38;5;93m\u2588\u001b[0m\u001b[38;5;129m\u2588\u001b[0m\u001b[38;5;129m\u2588\u001b[0m\u001b[38;5;129m\u2588\u001b[0m\u001b[38;5;129m\u2588\u001b[0m\u001b[38;5;165m\u2588\u001b[0m\u001b[38;5;225m\u2588\u001b[0m\u001b[38;5;183m\u2588\u001b[0m\u001b[38;5;99m\u2588\u001b[0m\u001b[38;5;99m\u2588\u001b[0m\u001b[38;5;99m\u2588\u2588\u2588\u001b[0m\u001b[38;5;99m\u2588\u001b[0m\u001b[38;5;99m\u2588\u001b[0m\u001b[38;5;99m\u2588\u001b[0m\u001b[38;5;135m\u2588\u001b[0m\u001b[38;5;225m\u2588\u001b[0m\u001b[38;5;171m\u2588\u001b[0m\u001b[38;5;53m\u2588\u001b[0m\u001b[38;5;53m\u2588\u001b[0m\u001b[38;5;53m\u2588\u001b[0m\u001b[38;5;53m\u2588\u001b[0m\u001b[38;5;102m\u2588\u001b[0m\u001b[38;5;16m \u001b[0m\u001b[38;5;16m    \u001b[0m\n\u001b[38;5;16m    \u001b[0m\u001b[38;5;16m \u001b[0m\u001b[38;5;102m\u2588\u001b[0m\u001b[38;5;128m\u2588\u001b[0m\u001b[38;5;165m\u2588\u001b[0m\u001b[38;5;165m\u2588\u001b[0m\u001b[38;5;165m\u2588\u001b[0m\u001b[38;5;171m\u2588\u001b[0m\u001b[38;5;225m\u2588\u001b[0m\u001b[38;5;141m\u2588\u001b[0m\u001b[38;5;231m\u2588\u001b[0m\u001b[38;5;207m\u2588\u001b[0m\u001b[38;5;201m\u2588\u001b[0m\u001b[38;5;165m\u2588\u001b[0m\u001b[38;5;129m\u2588\u001b[0m\u001b[38;5;129m\u2588\u2588\u001b[0m\u001b[38;5;129m\u2588\u001b[0m\u001b[38;5;129m\u2588\u001b[0m\u001b[38;5;231m\u2588\u001b[0m\u001b[38;5;135m\u2588\u001b[0m\u001b[38;5;99m\u2588\u001b[0m\u001b[38;5;99m\u2588\u001b[0m\u001b[38;5;99m\u2588\u001b[0m\u001b[38;5;99m\u2588\u001b[0m\u001b[38;5;99m\u2588\u001b[0m\u001b[38;5;99m\u2588\u001b[0m\u001b[38;5;99m\u2588\u001b[0m\u001b[38;5;99m\u2588\u001b[0m\u001b[38;5;141m\u2588\u001b[0m\u001b[38;5;183m\u2588\u001b[0m\u001b[38;5;183m\u2588\u2588\u001b[0m\u001b[38;5;177m\u2588\u001b[0m\u001b[38;5;177m\u2588\u001b[0m\u001b[38;5;177m\u2588\u001b[0m\u001b[38;5;183m\u2588\u001b[0m\u001b[38;5;183m\u2588\u001b[0m\u001b[38;5;141m\u2588\u001b[0m\u001b[38;5;99m\u2588\u001b[0m\u001b[38;5;99m\u2588\u001b[0m\u001b[38;5;99m\u2588\u2588\u2588\u001b[0m\u001b[38;5;99m\u2588\u001b[0m\u001b[38;5;99m\u2588\u001b[0m\u001b[38;5;99m\u2588\u001b[0m\u001b[38;5;99m\u2588\u001b[0m\u001b[38;5;135m\u2588\u001b[0m\u001b[38;5;225m\u2588\u001b[0m\u001b[38;5;171m\u2588\u001b[0m\u001b[38;5;53m\u2588\u001b[0m\u001b[38;5;53m\u2588\u001b[0m\u001b[38;5;53m\u2588\u001b[0m\u001b[38;5;53m\u2588\u001b[0m\u001b[38;5;102m\u2588\u001b[0m\u001b[38;5;16m \u001b[0m\u001b[38;5;16m    \u001b[0m\n\u001b[38;5;16m    \u001b[0m\u001b[38;5;16m \u001b[0m\u001b[38;5;102m\u2588\u001b[0m\u001b[38;5;128m\u2588\u001b[0m\u001b[38;5;165m\u2588\u001b[0m\u001b[38;5;165m\u2588\u001b[0m\u001b[38;5;165m\u2588\u001b[0m\u001b[38;5;171m\u2588\u001b[0m\u001b[38;5;225m\u2588\u001b[0m\u001b[38;5;135m\u2588\u001b[0m\u001b[38;5;225m\u2588\u001b[0m\u001b[38;5;219m\u2588\u001b[0m\u001b[38;5;201m\u2588\u001b[0m\u001b[38;5;201m\u2588\u001b[0m\u001b[38;5;129m\u2588\u001b[0m\u001b[38;5;129m\u2588\u001b[0m\u001b[38;5;129m\u2588\u001b[0m\u001b[38;5;129m\u2588\u001b[0m\u001b[38;5;129m\u2588\u001b[0m\u001b[38;5;177m\u2588\u001b[0m\u001b[38;5;225m\u2588\u001b[0m\u001b[38;5;135m\u2588\u001b[0m\u001b[38;5;93m\u2588\u001b[0m\u001b[38;5;135m\u2588\u001b[0m\u001b[38;5;135m\u2588\u2588\u001b[0m\u001b[38;5;135m\u2588\u2588\u2588\u001b[0m\u001b[38;5;93m\u2588\u001b[0m\u001b[38;5;93m\u2588\u001b[0m\u001b[38;5;129m\u2588\u001b[0m\u001b[38;5;135m\u2588\u001b[0m\u001b[38;5;135m\u2588\u001b[0m\u001b[38;5;135m\u2588\u001b[0m\u001b[38;5;135m\u2588\u001b[0m\u001b[38;5;135m\u2588\u001b[0m\u001b[38;5;93m\u2588\u001b[0m\u001b[38;5;93m\u2588\u001b[0m\u001b[38;5;135m\u2588\u001b[0m\u001b[38;5;93m\u2588\u001b[0m\u001b[38;5;93m\u2588\u001b[0m\u001b[38;5;93m\u2588\u001b[0m\u001b[38;5;99m\u2588\u001b[0m\u001b[38;5;135m\u2588\u001b[0m\u001b[38;5;135m\u2588\u001b[0m\u001b[38;5;135m\u2588\u001b[0m\u001b[38;5;93m\u2588\u001b[0m\u001b[38;5;135m\u2588\u001b[0m\u001b[38;5;225m\u2588\u001b[0m\u001b[38;5;171m\u2588\u001b[0m\u001b[38;5;53m\u2588\u001b[0m\u001b[38;5;53m\u2588\u001b[0m\u001b[38;5;53m\u2588\u001b[0m\u001b[38;5;53m\u2588\u001b[0m\u001b[38;5;102m\u2588\u001b[0m\u001b[38;5;16m \u001b[0m\u001b[38;5;16m    \u001b[0m\n\u001b[38;5;16m    \u001b[0m\u001b[38;5;16m \u001b[0m\u001b[38;5;102m\u2588\u001b[0m\u001b[38;5;128m\u2588\u001b[0m\u001b[38;5;165m\u2588\u001b[0m\u001b[38;5;165m\u2588\u001b[0m\u001b[38;5;165m\u2588\u001b[0m\u001b[38;5;171m\u2588\u001b[0m\u001b[38;5;225m\u2588\u001b[0m\u001b[38;5;129m\u2588\u001b[0m\u001b[38;5;171m\u2588\u001b[0m\u001b[38;5;231m\u2588\u001b[0m\u001b[38;5;207m\u2588\u001b[0m\u001b[38;5;201m\u2588\u001b[0m\u001b[38;5;165m\u2588\u001b[0m\u001b[38;5;129m\u2588\u001b[0m\u001b[38;5;129m\u2588\u001b[0m\u001b[38;5;129m\u2588\u001b[0m\u001b[38;5;129m\u2588\u001b[0m\u001b[38;5;129m\u2588\u001b[0m\u001b[38;5;213m\u2588\u001b[0m\u001b[38;5;225m\u2588\u001b[0m\u001b[38;5;135m\u2588\u001b[0m\u001b[38;5;129m\u2588\u001b[0m\u001b[38;5;129m\u2588\u001b[0m\u001b[38;5;129m\u2588\u001b[0m\u001b[38;5;129m\u2588\u001b[0m\u001b[38;5;129m\u2588\u2588\u001b[0m\u001b[38;5;129m\u2588\u001b[0m\u001b[38;5;129m\u2588\u2588\u001b[0m\u001b[38;5;129m\u2588\u001b[0m\u001b[38;5;129m\u2588\u001b[0m\u001b[38;5;129m\u2588\u001b[0m\u001b[38;5;129m\u2588\u001b[0m\u001b[38;5;129m\u2588\u001b[0m\u001b[38;5;129m\u2588\u001b[0m\u001b[38;5;129m\u2588\u001b[0m\u001b[38;5;129m\u2588\u001b[0m\u001b[38;5;129m\u2588\u001b[0m\u001b[38;5;177m\u2588\u001b[0m\u001b[38;5;183m\u2588\u001b[0m\u001b[38;5;219m\u2588\u001b[0m\u001b[38;5;219m\u2588\u001b[0m\u001b[38;5;177m\u2588\u001b[0m\u001b[38;5;183m\u2588\u001b[0m\u001b[38;5;177m\u2588\u001b[0m\u001b[38;5;183m\u2588\u001b[0m\u001b[38;5;231m\u2588\u001b[0m\u001b[38;5;171m\u2588\u001b[0m\u001b[38;5;53m\u2588\u001b[0m\u001b[38;5;53m\u2588\u001b[0m\u001b[38;5;53m\u2588\u001b[0m\u001b[38;5;53m\u2588\u001b[0m\u001b[38;5;102m\u2588\u001b[0m\u001b[38;5;16m \u001b[0m\u001b[38;5;16m    \u001b[0m\n\u001b[38;5;16m    \u001b[0m\u001b[38;5;16m \u001b[0m\u001b[38;5;102m\u2588\u001b[0m\u001b[38;5;127m\u2588\u001b[0m\u001b[38;5;165m\u2588\u001b[0m\u001b[38;5;165m\u2588\u001b[0m\u001b[38;5;165m\u2588\u001b[0m\u001b[38;5;207m\u2588\u001b[0m\u001b[38;5;225m\u2588\u001b[0m\u001b[38;5;129m\u2588\u001b[0m\u001b[38;5;129m\u2588\u001b[0m\u001b[38;5;177m\u2588\u001b[0m\u001b[38;5;225m\u2588\u001b[0m\u001b[38;5;201m\u2588\u001b[0m\u001b[38;5;201m\u2588\u001b[0m\u001b[38;5;129m\u2588\u001b[0m\u001b[38;5;128m\u2588\u001b[0m\u001b[38;5;128m\u2588\u001b[0m\u001b[38;5;128m\u2588\u001b[0m\u001b[38;5;129m\u2588\u001b[0m\u001b[38;5;201m\u2588\u001b[0m\u001b[38;5;207m\u2588\u001b[0m\u001b[38;5;219m\u2588\u001b[0m\u001b[38;5;219m\u2588\u001b[0m\u001b[38;5;171m\u2588\u001b[0m\u001b[38;5;129m\u2588\u001b[0m\u001b[38;5;129m\u2588\u001b[0m\u001b[38;5;129m\u2588\u001b[0m\u001b[38;5;129m\u2588\u001b[0m\u001b[38;5;129m\u2588\u001b[0m\u001b[38;5;129m\u2588\u001b[0m\u001b[38;5;129m\u2588\u001b[0m\u001b[38;5;129m\u2588\u2588\u001b[0m\u001b[38;5;129m\u2588\u001b[0m\u001b[38;5;129m\u2588\u001b[0m\u001b[38;5;129m\u2588\u001b[0m\u001b[38;5;129m\u2588\u001b[0m\u001b[38;5;129m\u2588\u001b[0m\u001b[38;5;177m\u2588\u001b[0m\u001b[38;5;219m\u2588\u001b[0m\u001b[38;5;219m\u2588\u001b[0m\u001b[38;5;207m\u2588\u001b[0m\u001b[38;5;165m\u2588\u001b[0m\u001b[38;5;129m\u2588\u001b[0m\u001b[38;5;129m\u2588\u001b[0m\u001b[38;5;129m\u2588\u001b[0m\u001b[38;5;129m\u2588\u001b[0m\u001b[38;5;171m\u2588\u001b[0m\u001b[38;5;171m\u2588\u001b[0m\u001b[38;5;128m\u2588\u001b[0m\u001b[38;5;53m\u2588\u001b[0m\u001b[38;5;53m\u2588\u001b[0m\u001b[38;5;53m\u2588\u001b[0m\u001b[38;5;53m\u2588\u001b[0m\u001b[38;5;102m\u2588\u001b[0m\u001b[38;5;16m \u001b[0m\u001b[38;5;16m    \u001b[0m\n\u001b[38;5;16m    \u001b[0m\u001b[38;5;16m \u001b[0m\u001b[38;5;102m\u2588\u001b[0m\u001b[38;5;127m\u2588\u001b[0m\u001b[38;5;165m\u2588\u001b[0m\u001b[38;5;164m\u2588\u001b[0m\u001b[38;5;165m\u2588\u001b[0m\u001b[38;5;207m\u2588\u001b[0m\u001b[38;5;225m\u2588\u001b[0m\u001b[38;5;171m\u2588\u001b[0m\u001b[38;5;129m\u2588\u001b[0m\u001b[38;5;129m\u2588\u001b[0m\u001b[38;5;177m\u2588\u001b[0m\u001b[38;5;219m\u2588\u001b[0m\u001b[38;5;165m\u2588\u001b[0m\u001b[38;5;129m\u2588\u001b[0m\u001b[38;5;128m\u2588\u001b[0m\u001b[38;5;128m\u2588\u2588\u001b[0m\u001b[38;5;128m\u2588\u001b[0m\u001b[38;5;129m\u2588\u001b[0m\u001b[38;5;165m\u2588\u001b[0m\u001b[38;5;201m\u2588\u001b[0m\u001b[38;5;207m\u2588\u001b[0m\u001b[38;5;219m\u2588\u001b[0m\u001b[38;5;219m\u2588\u001b[0m\u001b[38;5;219m\u2588\u001b[0m\u001b[38;5;177m\u2588\u001b[0m\u001b[38;5;171m\u2588\u001b[0m\u001b[38;5;171m\u2588\u001b[0m\u001b[38;5;129m\u2588\u2588\u2588\u001b[0m\u001b[38;5;129m\u2588\u001b[0m\u001b[38;5;171m\u2588\u001b[0m\u001b[38;5;177m\u2588\u001b[0m\u001b[38;5;177m\u2588\u001b[0m\u001b[38;5;219m\u2588\u001b[0m\u001b[38;5;219m\u2588\u001b[0m\u001b[38;5;213m\u2588\u001b[0m\u001b[38;5;207m\u2588\u001b[0m\u001b[38;5;201m\u2588\u001b[0m\u001b[38;5;129m\u2588\u001b[0m\u001b[38;5;129m\u2588\u001b[0m\u001b[38;5;128m\u2588\u001b[0m\u001b[38;5;128m\u2588\u001b[0m\u001b[38;5;128m\u2588\u001b[0m\u001b[38;5;128m\u2588\u001b[0m\u001b[38;5;92m\u2588\u001b[0m\u001b[38;5;129m\u2588\u001b[0m\u001b[38;5;92m\u2588\u001b[0m\u001b[38;5;53m\u2588\u001b[0m\u001b[38;5;53m\u2588\u001b[0m\u001b[38;5;53m\u2588\u001b[0m\u001b[38;5;53m\u2588\u001b[0m\u001b[38;5;102m\u2588\u001b[0m\u001b[38;5;16m \u001b[0m\u001b[38;5;16m    \u001b[0m\n\u001b[38;5;16m    \u001b[0m\u001b[38;5;16m \u001b[0m\u001b[38;5;102m\u2588\u001b[0m\u001b[38;5;128m\u2588\u001b[0m\u001b[38;5;165m\u2588\u001b[0m\u001b[38;5;165m\u2588\u001b[0m\u001b[38;5;128m\u2588\u001b[0m\u001b[38;5;129m\u2588\u001b[0m\u001b[38;5;171m\u2588\u001b[0m\u001b[38;5;213m\u2588\u001b[0m\u001b[38;5;219m\u2588\u001b[0m\u001b[38;5;177m\u2588\u001b[0m\u001b[38;5;171m\u2588\u001b[0m\u001b[38;5;171m\u2588\u001b[0m\u001b[38;5;219m\u2588\u001b[0m\u001b[38;5;171m\u2588\u001b[0m\u001b[38;5;129m\u2588\u001b[0m\u001b[38;5;128m\u2588\u001b[0m\u001b[38;5;128m\u2588\u001b[0m\u001b[38;5;128m\u2588\u001b[0m\u001b[38;5;128m\u2588\u001b[0m\u001b[38;5;128m\u2588\u001b[0m\u001b[38;5;129m\u2588\u001b[0m\u001b[38;5;129m\u2588\u001b[0m\u001b[38;5;165m\u2588\u001b[0m\u001b[38;5;201m\u2588\u001b[0m\u001b[38;5;207m\u2588\u001b[0m\u001b[38;5;207m\u2588\u001b[0m\u001b[38;5;213m\u2588\u001b[0m\u001b[38;5;213m\u2588\u001b[0m\u001b[38;5;213m\u2588\u001b[0m\u001b[38;5;219m\u2588\u001b[0m\u001b[38;5;213m\u2588\u001b[0m\u001b[38;5;213m\u2588\u001b[0m\u001b[38;5;213m\u2588\u001b[0m\u001b[38;5;213m\u2588\u001b[0m\u001b[38;5;207m\u2588\u001b[0m\u001b[38;5;201m\u2588\u001b[0m\u001b[38;5;201m\u2588\u001b[0m\u001b[38;5;165m\u2588\u001b[0m\u001b[38;5;129m\u2588\u001b[0m\u001b[38;5;128m\u2588\u001b[0m\u001b[38;5;128m\u2588\u001b[0m\u001b[38;5;128m\u2588\u001b[0m\u001b[38;5;128m\u2588\u001b[0m\u001b[38;5;128m\u2588\u001b[0m\u001b[38;5;128m\u2588\u001b[0m\u001b[38;5;128m\u2588\u001b[0m\u001b[38;5;128m\u2588\u001b[0m\u001b[38;5;128m\u2588\u001b[0m\u001b[38;5;91m\u2588\u001b[0m\u001b[38;5;54m\u2588\u001b[0m\u001b[38;5;53m\u2588\u001b[0m\u001b[38;5;53m\u2588\u001b[0m\u001b[38;5;53m\u2588\u001b[0m\u001b[38;5;102m\u2588\u001b[0m\u001b[38;5;16m \u001b[0m\u001b[38;5;16m    \u001b[0m\n\u001b[38;5;16m    \u001b[0m\u001b[38;5;16m \u001b[0m\u001b[38;5;102m\u2588\u001b[0m\u001b[38;5;133m\u2588\u001b[0m\u001b[38;5;128m\u2588\u001b[0m\u001b[38;5;128m\u2588\u001b[0m\u001b[38;5;128m\u2588\u001b[0m\u001b[38;5;128m\u2588\u001b[0m\u001b[38;5;128m\u2588\u001b[0m\u001b[38;5;129m\u2588\u001b[0m\u001b[38;5;129m\u2588\u001b[0m\u001b[38;5;171m\u2588\u001b[0m\u001b[38;5;213m\u2588\u001b[0m\u001b[38;5;213m\u2588\u001b[0m\u001b[38;5;213m\u2588\u001b[0m\u001b[38;5;219m\u2588\u001b[0m\u001b[38;5;219m\u2588\u001b[0m\u001b[38;5;171m\u2588\u001b[0m\u001b[38;5;129m\u2588\u001b[0m\u001b[38;5;128m\u2588\u001b[0m\u001b[38;5;128m\u2588\u001b[0m\u001b[38;5;128m\u2588\u001b[0m\u001b[38;5;128m\u2588\u001b[0m\u001b[38;5;128m\u2588\u001b[0m\u001b[38;5;128m\u2588\u001b[0m\u001b[38;5;128m\u2588\u001b[0m\u001b[38;5;129m\u2588\u001b[0m\u001b[38;5;129m\u2588\u001b[0m\u001b[38;5;129m\u2588\u001b[0m\u001b[38;5;165m\u2588\u001b[0m\u001b[38;5;165m\u2588\u001b[0m\u001b[38;5;165m\u2588\u001b[0m\u001b[38;5;165m\u2588\u001b[0m\u001b[38;5;165m\u2588\u001b[0m\u001b[38;5;165m\u2588\u001b[0m\u001b[38;5;129m\u2588\u001b[0m\u001b[38;5;129m\u2588\u001b[0m\u001b[38;5;129m\u2588\u001b[0m\u001b[38;5;128m\u2588\u001b[0m\u001b[38;5;128m\u2588\u001b[0m\u001b[38;5;128m\u2588\u001b[0m\u001b[38;5;128m\u2588\u001b[0m\u001b[38;5;128m\u2588\u001b[0m\u001b[38;5;128m\u2588\u001b[0m\u001b[38;5;128m\u2588\u001b[0m\u001b[38;5;128m\u2588\u001b[0m\u001b[38;5;128m\u2588\u001b[0m\u001b[38;5;91m\u2588\u001b[0m\u001b[38;5;91m\u2588\u001b[0m\u001b[38;5;54m\u2588\u001b[0m\u001b[38;5;54m\u2588\u001b[0m\u001b[38;5;54m\u2588\u001b[0m\u001b[38;5;54m\u2588\u001b[0m\u001b[38;5;54m\u2588\u001b[0m\u001b[38;5;96m\u2588\u001b[0m\u001b[38;5;102m\u2588\u001b[0m\u001b[38;5;16m \u001b[0m\u001b[38;5;16m    \u001b[0m\n\u001b[38;5;16m     \u001b[0m\u001b[38;5;16m \u001b[0m\u001b[38;5;58m\u2588\u001b[0m\u001b[38;5;59m\u2588\u001b[0m\u001b[38;5;96m\u2588\u001b[0m\u001b[38;5;97m\u2588\u001b[0m\u001b[38;5;128m\u2588\u001b[0m\u001b[38;5;128m\u2588\u001b[0m\u001b[38;5;128m\u2588\u001b[0m\u001b[38;5;128m\u2588\u001b[0m\u001b[38;5;128m\u2588\u001b[0m\u001b[38;5;128m\u2588\u001b[0m\u001b[38;5;129m\u2588\u001b[0m\u001b[38;5;129m\u2588\u001b[0m\u001b[38;5;171m\u2588\u001b[0m\u001b[38;5;213m\u2588\u001b[0m\u001b[38;5;225m\u2588\u001b[0m\u001b[38;5;225m\u2588\u001b[0m\u001b[38;5;177m\u2588\u001b[0m\u001b[38;5;165m\u2588\u001b[0m\u001b[38;5;129m\u2588\u001b[0m\u001b[38;5;128m\u2588\u001b[0m\u001b[38;5;128m\u2588\u001b[0m\u001b[38;5;128m\u2588\u001b[0m\u001b[38;5;128m\u2588\u001b[0m\u001b[38;5;128m\u2588\u2588\u001b[0m\u001b[38;5;128m\u2588\u001b[0m\u001b[38;5;128m\u2588\u001b[0m\u001b[38;5;128m\u2588\u001b[0m\u001b[38;5;128m\u2588\u2588\u2588\u001b[0m\u001b[38;5;128m\u2588\u001b[0m\u001b[38;5;128m\u2588\u001b[0m\u001b[38;5;128m\u2588\u001b[0m\u001b[38;5;128m\u2588\u001b[0m\u001b[38;5;128m\u2588\u001b[0m\u001b[38;5;128m\u2588\u001b[0m\u001b[38;5;128m\u2588\u001b[0m\u001b[38;5;128m\u2588\u001b[0m\u001b[38;5;128m\u2588\u001b[0m\u001b[38;5;92m\u2588\u001b[0m\u001b[38;5;91m\u2588\u001b[0m\u001b[38;5;54m\u2588\u001b[0m\u001b[38;5;54m\u2588\u001b[0m\u001b[38;5;54m\u2588\u001b[0m\u001b[38;5;54m\u2588\u001b[0m\u001b[38;5;90m\u2588\u001b[0m\u001b[38;5;90m\u2588\u001b[0m\u001b[38;5;96m\u2588\u001b[0m\u001b[38;5;96m\u2588\u001b[0m\u001b[38;5;59m\u2588\u001b[0m\u001b[38;5;16m \u001b[0m\u001b[38;5;16m \u001b[0m\u001b[38;5;16m     \u001b[0m\n\u001b[38;5;16m        \u001b[0m\u001b[38;5;16m \u001b[0m\u001b[38;5;16m \u001b[0m\u001b[38;5;59m\u2588\u001b[0m\u001b[38;5;102m\u2588\u001b[0m\u001b[38;5;97m\u2588\u001b[0m\u001b[38;5;97m\u2588\u001b[0m\u001b[38;5;128m\u2588\u001b[0m\u001b[38;5;128m\u2588\u001b[0m\u001b[38;5;128m\u2588\u001b[0m\u001b[38;5;128m\u2588\u001b[0m\u001b[38;5;128m\u2588\u001b[0m\u001b[38;5;128m\u2588\u001b[0m\u001b[38;5;129m\u2588\u001b[0m\u001b[38;5;171m\u2588\u001b[0m\u001b[38;5;219m\u2588\u001b[0m\u001b[38;5;225m\u2588\u001b[0m\u001b[38;5;225m\u2588\u001b[0m\u001b[38;5;213m\u2588\u001b[0m\u001b[38;5;171m\u2588\u001b[0m\u001b[38;5;165m\u2588\u001b[0m\u001b[38;5;129m\u2588\u001b[0m\u001b[38;5;129m\u2588\u001b[0m\u001b[38;5;128m\u2588\u001b[0m\u001b[38;5;128m\u2588\u001b[0m\u001b[38;5;128m\u2588\u001b[0m\u001b[38;5;128m\u2588\u001b[0m\u001b[38;5;128m\u2588\u2588\u001b[0m\u001b[38;5;128m\u2588\u001b[0m\u001b[38;5;128m\u2588\u001b[0m\u001b[38;5;128m\u2588\u001b[0m\u001b[38;5;128m\u2588\u001b[0m\u001b[38;5;128m\u2588\u001b[0m\u001b[38;5;128m\u2588\u001b[0m\u001b[38;5;128m\u2588\u001b[0m\u001b[38;5;91m\u2588\u001b[0m\u001b[38;5;91m\u2588\u001b[0m\u001b[38;5;54m\u2588\u001b[0m\u001b[38;5;54m\u2588\u001b[0m\u001b[38;5;54m\u2588\u001b[0m\u001b[38;5;54m\u2588\u001b[0m\u001b[38;5;90m\u2588\u001b[0m\u001b[38;5;96m\u2588\u001b[0m\u001b[38;5;96m\u2588\u001b[0m\u001b[38;5;102m\u2588\u001b[0m\u001b[38;5;59m\u2588\u001b[0m\u001b[38;5;16m \u001b[0m\u001b[38;5;16m \u001b[0m\u001b[38;5;16m        \u001b[0m\n\u001b[38;5;16m            \u001b[0m\u001b[38;5;16m \u001b[0m\u001b[38;5;16m \u001b[0m\u001b[38;5;59m\u2588\u001b[0m\u001b[38;5;96m\u2588\u001b[0m\u001b[38;5;133m\u2588\u001b[0m\u001b[38;5;128m\u2588\u001b[0m\u001b[38;5;128m\u2588\u001b[0m\u001b[38;5;128m\u2588\u001b[0m\u001b[38;5;128m\u2588\u001b[0m\u001b[38;5;128m\u2588\u001b[0m\u001b[38;5;128m\u2588\u001b[0m\u001b[38;5;129m\u2588\u001b[0m\u001b[38;5;165m\u2588\u001b[0m\u001b[38;5;177m\u2588\u001b[0m\u001b[38;5;219m\u2588\u001b[0m\u001b[38;5;225m\u2588\u001b[0m\u001b[38;5;225m\u2588\u001b[0m\u001b[38;5;213m\u2588\u001b[0m\u001b[38;5;213m\u2588\u001b[0m\u001b[38;5;207m\u2588\u001b[0m\u001b[38;5;207m\u2588\u001b[0m\u001b[38;5;207m\u2588\u001b[0m\u001b[38;5;177m\u2588\u001b[0m\u001b[38;5;177m\u2588\u001b[0m\u001b[38;5;207m\u2588\u001b[0m\u001b[38;5;129m\u2588\u001b[0m\u001b[38;5;128m\u2588\u001b[0m\u001b[38;5;92m\u2588\u001b[0m\u001b[38;5;91m\u2588\u001b[0m\u001b[38;5;91m\u2588\u001b[0m\u001b[38;5;54m\u2588\u001b[0m\u001b[38;5;54m\u2588\u001b[0m\u001b[38;5;54m\u2588\u001b[0m\u001b[38;5;54m\u2588\u001b[0m\u001b[38;5;90m\u2588\u001b[0m\u001b[38;5;96m\u2588\u001b[0m\u001b[38;5;96m\u2588\u001b[0m\u001b[38;5;59m\u2588\u001b[0m\u001b[38;5;16m \u001b[0m\u001b[38;5;16m \u001b[0m\u001b[38;5;16m            \u001b[0m\n\u001b[38;5;16m               \u001b[0m\u001b[38;5;16m \u001b[0m\u001b[38;5;16m \u001b[0m\u001b[38;5;59m\u2588\u001b[0m\u001b[38;5;96m\u2588\u001b[0m\u001b[38;5;97m\u2588\u001b[0m\u001b[38;5;133m\u2588\u001b[0m\u001b[38;5;128m\u2588\u001b[0m\u001b[38;5;128m\u2588\u001b[0m\u001b[38;5;128m\u2588\u001b[0m\u001b[38;5;128m\u2588\u001b[0m\u001b[38;5;128m\u2588\u001b[0m\u001b[38;5;128m\u2588\u001b[0m\u001b[38;5;129m\u2588\u001b[0m\u001b[38;5;171m\u2588\u001b[0m\u001b[38;5;207m\u2588\u001b[0m\u001b[38;5;213m\u2588\u001b[0m\u001b[38;5;213m\u2588\u001b[0m\u001b[38;5;213m\u2588\u001b[0m\u001b[38;5;219m\u2588\u001b[0m\u001b[38;5;213m\u2588\u001b[0m\u001b[38;5;134m\u2588\u001b[0m\u001b[38;5;127m\u2588\u001b[0m\u001b[38;5;91m\u2588\u001b[0m\u001b[38;5;54m\u2588\u001b[0m\u001b[38;5;54m\u2588\u001b[0m\u001b[38;5;54m\u2588\u001b[0m\u001b[38;5;54m\u2588\u001b[0m\u001b[38;5;90m\u2588\u001b[0m\u001b[38;5;96m\u2588\u001b[0m\u001b[38;5;96m\u2588\u001b[0m\u001b[38;5;96m\u2588\u001b[0m\u001b[38;5;59m\u2588\u001b[0m\u001b[38;5;16m \u001b[0m\u001b[38;5;16m \u001b[0m\u001b[38;5;16m               \u001b[0m\n\u001b[38;5;16m                   \u001b[0m\u001b[38;5;16m \u001b[0m\u001b[38;5;16m \u001b[0m\u001b[38;5;59m\u2588\u001b[0m\u001b[38;5;102m\u2588\u001b[0m\u001b[38;5;97m\u2588\u001b[0m\u001b[38;5;128m\u2588\u001b[0m\u001b[38;5;128m\u2588\u001b[0m\u001b[38;5;128m\u2588\u001b[0m\u001b[38;5;128m\u2588\u001b[0m\u001b[38;5;128m\u2588\u001b[0m\u001b[38;5;128m\u2588\u001b[0m\u001b[38;5;129m\u2588\u001b[0m\u001b[38;5;165m\u2588\u001b[0m\u001b[38;5;128m\u2588\u001b[0m\u001b[38;5;91m\u2588\u001b[0m\u001b[38;5;90m\u2588\u001b[0m\u001b[38;5;54m\u2588\u001b[0m\u001b[38;5;54m\u2588\u001b[0m\u001b[38;5;54m\u2588\u001b[0m\u001b[38;5;90m\u2588\u001b[0m\u001b[38;5;90m\u2588\u001b[0m\u001b[38;5;96m\u2588\u001b[0m\u001b[38;5;96m\u2588\u001b[0m\u001b[38;5;59m\u2588\u001b[0m\u001b[38;5;16m \u001b[0m\u001b[38;5;16m \u001b[0m\u001b[38;5;16m                   \u001b[0m\n\u001b[38;5;16m                      \u001b[0m\u001b[38;5;16m \u001b[0m\u001b[38;5;16m \u001b[0m\u001b[38;5;59m\u2588\u001b[0m\u001b[38;5;96m\u2588\u001b[0m\u001b[38;5;97m\u2588\u001b[0m\u001b[38;5;133m\u2588\u001b[0m\u001b[38;5;128m\u2588\u001b[0m\u001b[38;5;128m\u2588\u001b[0m\u001b[38;5;128m\u2588\u001b[0m\u001b[38;5;128m\u2588\u001b[0m\u001b[38;5;91m\u2588\u001b[0m\u001b[38;5;54m\u2588\u001b[0m\u001b[38;5;54m\u2588\u001b[0m\u001b[38;5;90m\u2588\u001b[0m\u001b[38;5;96m\u2588\u001b[0m\u001b[38;5;96m\u2588\u001b[0m\u001b[38;5;96m\u2588\u001b[0m\u001b[38;5;59m\u2588\u001b[0m\u001b[38;5;16m \u001b[0m\u001b[38;5;16m \u001b[0m\u001b[38;5;16m                      \u001b[0m\n\u001b[38;5;16m                          \u001b[0m\u001b[38;5;16m \u001b[0m\u001b[38;5;59m \u001b[0m\u001b[38;5;96m\u2588\u001b[0m\u001b[38;5;96m\u2588\u001b[0m\u001b[38;5;97m\u2588\u001b[0m\u001b[38;5;128m\u2588\u001b[0m\u001b[38;5;90m\u2588\u001b[0m\u001b[38;5;96m\u2588\u001b[0m\u001b[38;5;96m\u2588\u001b[0m\u001b[38;5;95m\u2588\u001b[0m\u001b[38;5;59m\u2588\u001b[0m\u001b[38;5;16m \u001b[0m\u001b[38;5;16m                          \u001b[0m\n\u001b[38;5;16m                             \u001b[0m\u001b[38;5;16m \u001b[0m\u001b[38;5;16m \u001b[0m\u001b[38;5;59m\u2588\u001b[0m\u001b[38;5;59m\u2588\u001b[0m\u001b[38;5;16m \u001b[0m\u001b[38;5;16m \u001b[0m\u001b[38;5;16m                             \u001b[0m\nLOGO;"}
{"instruction": "Write an Ephect command handler", "input": "Based on Ephect source: Main.php", "output": "<?php\n\nnamespace Ephect\\Modules\\WebApp\\Commands\\Build;\n\nuse Ephect\\Framework\\Commands\\AbstractCommand;\nuse Ephect\\Framework\\Commands\\Attributes\\CommandDeclaration;\n\n#[CommandDeclaration(verb: \"build\")]\n#[CommandDeclaration(desc: \"Build the application.\")]\nclass Main extends AbstractCommand\n{\n    public function run(): int\n    {\n        $principal = include_once __DIR__ . DIRECTORY_SEPARATOR  . \"Logo.php\";\n        echo $principal . PHP_EOL;\n\n        $use = new Lib($this->application);\n        $use->build();\n\n        return 0;\n    }\n}"}
{"instruction": "Write an Ephect PHP component", "input": "Based on Ephect source: TemplatesCopier.php", "output": "<?php\n\nnamespace Ephect\\Modules\\WebApp\\Builder\\Copiers;\n\nuse Ephect\\Framework\\Utils\\File;\nuse Ephect\\Modules\\WebApp\\Builder\\Copiers\\Strategy\\CopierStrategyInterface;\n\nclass TemplatesCopier\n{\n    public static function copy(CopierStrategyInterface $copier, string $path, bool $noDepth = false): void\n    {\n        $fileList = File::walkTreeFiltered($path, ['phtml'], $noDepth);\n        foreach ($fileList as $key => $compFile) {\n            $copier->copy($path, $key, $compFile);\n        }\n    }\n}"}
{"instruction": "Write an Ephect PHP component", "input": "Based on Ephect source: TemplatesCopyMaker.php", "output": "<?php\n\nnamespace Ephect\\Modules\\WebApp\\Builder\\Copiers;\n\nuse Ephect\\Modules\\WebApp\\Builder\\Copiers\\Strategy\\CopiersFactory;\n\nclass TemplatesCopyMaker\n{\n    public function makeCopies(bool $asUnique = false)\n    {\n        $copier = CopiersFactory::createCopier($asUnique);\n\n        TemplatesCopier::copy($copier, \\Constants::SRC_ROOT, true);\n        TemplatesCopier::copy($copier, \\Constants::CUSTOM_PAGES_ROOT);\n        TemplatesCopier::copy($copier, \\Constants::CUSTOM_COMPONENTS_ROOT);\n    }\n\n}"}
{"instruction": "Write an Ephect component", "input": "Based on Ephect source: ComponentDescriptor.php", "output": "<?php\n\nnamespace Ephect\\Modules\\WebApp\\Builder\\Descriptors;\n\nuse Ephect\\Framework\\Utils\\File;\nuse Ephect\\Modules\\Forms\\Components\\Component;\nuse Ephect\\Modules\\Forms\\Components\\ComponentEntity;\nuse Ephect\\Modules\\Forms\\Registry\\CodeRegistry;\nuse Ephect\\Modules\\Forms\\Registry\\ComponentRegistry;\nuse Ephect\\Modules\\Forms\\Generators\\ComponentParser;\nuse Ephect\\Modules\\Forms\\Generators\\ParserService;\nuse Ephect\\Modules\\WebApp\\Registry\\PageRegistry;\n\nclass ComponentDescriptor implements DescriptorInterface\n{\n    public function describe(string $sourceDir, string $filename): array\n    {\n        $relativeFile =\n            str_replace(\\Constants::APP_ROOT, '', $sourceDir) .\n            str_replace(pathinfo($filename, PATHINFO_EXTENSION), 'php', $filename);\n        File::safeCopy($sourceDir . $filename, \\Constants::COPY_DIR . $relativeFile);\n\n        $comp = new Component();\n        $comp->load($relativeFile);\n\n        $parser = new ParserService();\n        $parser->doEmptyComponents($comp);\n        if ($parser->getResult() === true) {\n            $html = $parser->getHtml();\n            File::safeWrite(\\Constants::COPY_DIR . $relativeFile, $html);\n            $comp->load($relativeFile);\n        }\n\n        $comp->analyse();\n\n        $uid = $comp->getUID();\n        $pageFile = PageRegistry::read($comp->getFullyQualifiedFunction());\n        $pageUid = $pageFile !== null ? PageRegistry::read($pageFile) : null;\n        if ($pageUid !== null) {\n            $uid = $pageUid;\n        }\n\n        $parser = new ComponentParser($comp);\n        $struct = $parser->doDeclaration($uid);\n        $decl = $struct->toArray();\n\n        CodeRegistry::write($comp->getFullyQualifiedFunction(), $decl);\n        ComponentRegistry::write($relativeFile, $uid);\n        ComponentRegistry::write($comp->getUID(), $comp->getFullyQualifiedFunction());\n\n        $entity = ComponentEntity::buildFromArray($struct->composition);\n        $comp->add($entity);\n\n        return [$comp->getFullyQualifiedFunction(), $comp];\n    }\n}"}
{"instruction": "Write an Ephect component", "input": "Based on Ephect source: ComponentListDescriptor.php", "output": "<?php\n\nnamespace Ephect\\Modules\\WebApp\\Builder\\Descriptors;\n\nuse Ephect\\Framework\\Modules\\ModuleInstaller;\nuse Ephect\\Framework\\Modules\\ModuleManifestReader;\nuse Ephect\\Framework\\Utils\\File;\n\nuse function siteSrcPath;\n\nclass ComponentListDescriptor implements ComponentListDescriptorInterface\n{\n    public function describe(string $templateDir = ''): array\n    {\n        $result = [];\n\n        $descriptor = new ComponentDescriptor();\n\n        $bootstrapList = File::walkTreeFiltered(\\Constants::SRC_ROOT, ['phtml'], true);\n        foreach ($bootstrapList as $key => $compFile) {\n            [$fqcn, $comp] = $descriptor->describe(\\Constants::SRC_ROOT, $compFile);\n            $result[$fqcn] = $comp;\n        }\n\n        $pagesList = File::walkTreeFiltered(\\Constants::CUSTOM_PAGES_ROOT, ['phtml']);\n        foreach ($pagesList as $key => $pageFile) {\n            [$fqcn, $comp] = $descriptor->describe(\\Constants::CUSTOM_PAGES_ROOT, $pageFile);\n            $result[$fqcn] = $comp;\n        }\n\n        $componentsList = File::walkTreeFiltered(\\Constants::CUSTOM_COMPONENTS_ROOT, ['phtml']);\n        foreach ($componentsList as $key => $compFile) {\n            [$fqcn, $comp] = $descriptor->describe(\\Constants::CUSTOM_COMPONENTS_ROOT, $compFile);\n            $result[$fqcn] = $comp;\n        }\n\n        [$filename, $modulePaths] = ModuleInstaller::readModulePaths();\n        foreach ($modulePaths as $path) {\n            if (str_starts_with($path, 'vendor')) {\n                $path = realpath(siteRoot() . $path);\n            }\n            $moduleConfigDir = $path . DIRECTORY_SEPARATOR . \\Constants::REL_CONFIG_DIR;\n            $moduleConfigDir = is_dir($moduleConfigDir) ? $moduleConfigDir : $path;\n\n            $manifestReader = new ModuleManifestReader();\n            $manifest = $manifestReader->read($moduleConfigDir);\n\n            $configTemplatesDir = $manifest->getTemplates();\n            $configTemplatesDir = $configTemplatesDir === null\n                ? $configTemplatesDir\n                : siteSrcPath() . $configTemplatesDir;\n\n            if ($configTemplatesDir !== null && file_exists($configTemplatesDir)) {\n                $componentsList = File::walkTreeFiltered($configTemplatesDir, ['phtml']);\n                foreach ($componentsList as $key => $compFile) {\n                    [$fqcn, $comp] = $descriptor->describe($configTemplatesDir, $compFile);\n                    $result[$fqcn] = $comp;\n                }\n            }\n        }\n\n        return $result;\n    }\n}"}
{"instruction": "Write an Ephect component", "input": "Based on Ephect source: ComponentListDescriptorInterface.php", "output": "<?php\n\nnamespace Ephect\\Modules\\WebApp\\Builder\\Descriptors;\n\ninterface ComponentListDescriptorInterface\n{\n    public function describe(string $templateDir = ''): array;\n\n}"}
{"instruction": "Write an Ephect PHP component", "input": "Based on Ephect source: DescriptorInterface.php", "output": "<?php\n\nnamespace Ephect\\Modules\\WebApp\\Builder\\Descriptors;\n\ninterface DescriptorInterface\n{\n    public function describe(string $sourceDir, string $filename): array;\n\n}"}
{"instruction": "Write an Ephect component", "input": "Based on Ephect source: ModuleDescriptor.php", "output": "<?php\n\nnamespace Ephect\\Modules\\WebApp\\Builder\\Descriptors;\n\nuse Constants;\nuse Ephect\\Framework\\Modules\\ModuleManifestReader;\nuse Ephect\\Framework\\Utils\\File;\nuse Ephect\\Modules\\Forms\\Components\\ComponentInterface;\nuse Ephect\\Modules\\WebApp\\Builder\\Parsers\\ParserFactory;\nuse Exception;\n\nclass ModuleDescriptor implements DescriptorInterface\n{\n    public function __construct(private readonly string $modulePath)\n    {\n    }\n\n    /**\n     * @throws \\ErrorException\n     * @throws \\JsonException\n     * @throws Exception\n     */\n    public function describe(string $sourceDir, string $filename): array\n    {\n        $relativeFile =\n            str_replace(\\Constants::EPHECT_ROOT, '', $sourceDir) .\n            str_replace(pathinfo($filename, PATHINFO_EXTENSION), 'php', $filename);\n        File::safeCopy($sourceDir . $filename, \\Constants::COPY_DIR . $relativeFile);\n\n        $manifestDir = realpath($this->modulePath . DIRECTORY_SEPARATOR . \\Constants::REL_CONFIG_DIR);\n        $manifestDir = is_dir($manifestDir) ? $manifestDir : $this->modulePath;\n\n        $reader = new ModuleManifestReader();\n        $manifest = $reader->read($manifestDir);\n\n        $moduleEntrypoint = $manifest->getEntrypoint();\n\n        if ($moduleEntrypoint == null) {\n            return [null, null];\n        }\n\n        if (!in_array(ComponentInterface::class, class_implements($moduleEntrypoint))) {\n            throw new Exception(\"Module entry point must implement \" . ComponentInterface::class . \" or be null.\");\n        }\n\n        $parser = ParserFactory::createParser($moduleEntrypoint, $relativeFile);\n\n        return $parser->parse();\n\n    }\n}"}
{"instruction": "Write an Ephect component", "input": "Based on Ephect source: ModuleListDescriptor.php", "output": "<?php\n\nnamespace Ephect\\Modules\\WebApp\\Builder\\Descriptors;\n\nuse Ephect\\Framework\\Utils\\File;\nuse Ephect\\Modules\\Forms\\Components\\ComponentInterface;\n\nclass ModuleListDescriptor implements ComponentListDescriptorInterface\n{\n    public function __construct(private readonly string $modulePath)\n    {\n    }\n\n    public function describe(string $templateDir = ''): array\n    {\n        $result = [];\n\n        $descriptor = new ModuleDescriptor($this->modulePath);\n        $moduleTemplateList = File::walkTreeFiltered($templateDir, ['phtml']);\n        foreach ($moduleTemplateList as $key => $moduleTemplate) {\n            [$fqcn, $comp] = $descriptor->describe($templateDir, $moduleTemplate);\n            if (is_string($fqcn) && $comp instanceof ComponentInterface) {\n                $result[$fqcn] = $comp;\n            }\n        }\n\n        return $result;\n    }\n}"}
{"instruction": "Write an Ephect component", "input": "Based on Ephect source: PluginDescriptor.php", "output": "<?php\n\nnamespace Ephect\\Modules\\WebApp\\Builder\\Descriptors;\n\nuse Ephect\\Framework\\Utils\\File;\nuse Ephect\\Modules\\Forms\\Components\\Plugin;\nuse Ephect\\Modules\\Forms\\Registry\\PluginRegistry;\n\nclass PluginDescriptor implements DescriptorInterface\n{\n    public function describe(string $sourceDir, string $filename): array\n    {\n        $relativeFile =\n            str_replace(\\Constants::EPHECT_ROOT, '', $sourceDir) .\n            str_replace(pathinfo($filename, PATHINFO_EXTENSION), 'php', $filename);\n        File::safeCopy($sourceDir . $filename, \\Constants::COPY_DIR . $relativeFile);\n\n        $plugin = new Plugin();\n        $plugin->load($relativeFile);\n        $plugin->analyse();\n\n        PluginRegistry::write($filename, $plugin->getUID());\n        PluginRegistry::write($plugin->getUID(), $plugin->getFullyQualifiedFunction());\n\n        return [$plugin->getFullyQualifiedFunction(), $plugin];\n    }\n}"}
{"instruction": "Write an Ephect component", "input": "Based on Ephect source: PluginListDescriptor.php", "output": "<?php\n\nnamespace Ephect\\Modules\\WebApp\\Builder\\Descriptors;\n\nuse Ephect\\Framework\\Utils\\File;\n\nclass PluginListDescriptor implements ComponentListDescriptorInterface\n{\n    public function describe(string $templateDir = ''): array\n    {\n        $result = [];\n\n        $descriptor = new PluginDescriptor();\n        $pluginList = File::walkTreeFiltered(\\Constants::PLUGINS_ROOT, ['phtml']);\n        foreach ($pluginList as $key => $pluginFile) {\n            $descriptor->describe(\\Constants::PLUGINS_ROOT, $pluginFile);\n        }\n\n        return $result;\n    }\n}"}
{"instruction": "Write an Ephect component", "input": "Based on Ephect source: UniqueComponentDescriptor.php", "output": "<?php\n\nnamespace Ephect\\Modules\\WebApp\\Builder\\Descriptors;\n\nuse Ephect\\Framework\\Crypto\\Crypto;\nuse Ephect\\Framework\\ElementUtils;\nuse Ephect\\Framework\\Logger\\Logger;\nuse Ephect\\Framework\\Middlewares\\AttributeMiddlewareInterface;\nuse Ephect\\Framework\\Registry\\MiddlewareRegistry;\nuse Ephect\\Framework\\Registry\\StateRegistry;\nuse Ephect\\Framework\\Utils\\File;\nuse Ephect\\Modules\\Forms\\Components\\Component;\nuse Ephect\\Modules\\Forms\\Components\\ComponentDeclaration;\nuse Ephect\\Modules\\Forms\\Components\\ComponentDeclarationInterface;\nuse Ephect\\Modules\\Forms\\Components\\ComponentEntity;\nuse Ephect\\Modules\\Forms\\Components\\ComponentEntityInterface;\nuse Ephect\\Modules\\Forms\\Middlewares\\ComponentParserMiddlewareInterface;\nuse Ephect\\Modules\\Forms\\Registry\\ComponentRegistry;\nuse Ephect\\Modules\\Forms\\Registry\\UniqueCodeRegistry;\nuse Ephect\\Modules\\Forms\\Generators\\ComponentParser;\nuse Ephect\\Modules\\Forms\\Generators\\ParserService;\nuse ReflectionClass;\n\nclass UniqueComponentDescriptor implements DescriptorInterface\n{\n    /**\n     * @param string $sourceDir\n     * @param string $filename\n     * @return array|null[]\n     * @throws \\ReflectionException\n     */\n    public function describe(string $sourceDir, string $filename): array\n    {\n\n        [\n            $namespace,\n            $functionName,\n            $parameters,\n            $returnedType,\n            $startsAt\n        ] = ElementUtils::getFunctionDefinitionFromFile($sourceDir . $filename);\n\n        if ($functionName == '') {\n            return [null, null];\n        }\n\n        include_once $sourceDir . $filename;\n\n        $fqFuncName = $namespace . '\\\\' . $functionName;\n\n        $ref = new \\ReflectionFunction($fqFuncName);\n        $refParameters = $ref->getParameters();\n        $refAttributes = $ref->getAttributes();\n        $refReturnType = $ref->getReturnType();\n\n        $arguments = array_map(function ($parameter) {\n            return $parameter->getName();\n        }, $refParameters);\n\n        $attributes = array_map(function ($attribute) {\n            return [\n                'name' => get_class($attribute->newInstance()),\n                'arguments' => $attribute->getArguments(),\n            ];\n        }, $refAttributes);\n\n        $comp = new Component();\n        $comp->load($sourceDir . $filename);\n\n        $fullCopyFilename = str_replace(\\Constants::UNIQUE_DIR, \\Constants::COPY_DIR, $fullFilename);\n\n        $parser = new ParserService();\n        $parser->doEmptyComponents($comp);\n        if ($parser->getResult() === true) {\n            $html = $parser->getHtml();\n            File::safeWrite(\\Constants::COPY_DIR . $filename, $html);\n            $comp->load(\\Constants::COPY_DIR . $filename);\n        }\n\n        $comp->analyse();\n\n        $uid = $comp->getUID();\n        $parser = new ComponentParser($comp);\n        $struct = $parser->doDeclaration($uid);\n        $decl = $struct->toArray();\n        $declaration = new ComponentDeclaration($struct);\n\n        $decl = [\n            'uid' => Crypto::createOID(),\n            'type' => 'function',\n            'name' => $functionName,\n            'arguments' => $arguments,\n            'attributes' => $attributes,\n            'returnType' => $refReturnType->getName(),\n            'composition' => $decl['composition'],\n        ];\n\n        //TODO: register middlewares if any\n        $this->registerMiddlewares($uid, $declaration);\n\n        //TODO: register events if any\n\n        UniqueCodeRegistry::write($comp->getFullyQualifiedFunction(), $decl);\n        ComponentRegistry::write($filename, $uid);\n        ComponentRegistry::write($comp->getUID(), $comp->getFullyQualifiedFunction());\n\n        $entity = ComponentEntity::buildFromArray($struct->composition);\n        $comp->add($entity);\n\n        return [$comp->getFullyQualifiedFunction(), $comp];\n    }\n\n    /**\n     * @throws \\ReflectionException\n     */\n    public function registerMiddlewares(\n        string $motherUID,\n        ComponentDeclarationInterface $declaration,\n    ): void {\n\n        Logger::create()->dump(__METHOD__ . '::declaration', $declaration);\n\n        /**\n         * Mandatory test: Parent is not always null!\n         */\n        if (!$declaration->hasAttributes()) {\n            return;\n        }\n\n        $attrs = $declaration->getAttributes();\n\n        $middlewaresList = [];\n        foreach ($attrs as $attr) {\n            if (!isset($attr['name'])) {\n                continue;\n            }\n\n            $attr = (object)$attr;\n\n            if (count($attr->arguments) > 0) {\n                $attrNew = new $attr->name(...$attr->arguments);\n            } else {\n                $attrNew = new $attr->name();\n            }\n\n            if ($attrNew instanceof AttributeMiddlewareInterface) {\n                $middlewaresList[$attr->name] = [\n                    $attr->arguments,\n                    $attrNew->getMiddlewares(),\n                ];\n            }\n        }\n\n        if (count($middlewaresList)) {\n            foreach ($middlewaresList as $key => $value) {\n                [$arguments, $middlewares] = $value;\n                foreach ($middlewares as $middlewareClass) {\n                    $middleware = new $middlewareClass();\n                    if ($middleware instanceof ComponentParserMiddlewareInterface) {\n                        MiddlewareRegistry::write($middlewareClass, $arguments);\n                    }\n\n                    MiddlewareRegistry::save();\n                }\n            }\n        }\n    }\n\n}"}
{"instruction": "Write an Ephect component", "input": "Based on Ephect source: UniqueComponentListDescriptor.php", "output": "<?php\n\nnamespace Ephect\\Modules\\WebApp\\Builder\\Descriptors;\n\nuse Ephect\\Framework\\Utils\\File;\n\nclass UniqueComponentListDescriptor implements ComponentListDescriptorInterface\n{\n    public function describe(string $templateDir = ''): array\n    {\n        $result = [];\n\n        $descriptor = new UniqueComponentDescriptor();\n\n        $bootstrapList = File::walkTreeFiltered(\\Constants::UNIQUE_DIR, ['php'], true);\n        foreach ($bootstrapList as $key => $compFile) {\n            [$fqcn, $comp] = $descriptor->describe(\\Constants::UNIQUE_DIR, $compFile);\n            if ($fqcn === null) {\n                continue;\n            }\n            $result[$fqcn] = $comp;\n        }\n\n        return $result;\n    }\n}"}
{"instruction": "Write an Ephect PHP component", "input": "Based on Ephect source: FinderInterface.php", "output": "<?php\n\nnamespace Ephect\\Modules\\WebApp\\Builder\\Finders;\n\ninterface FinderInterface\n{\n    public function find(): array;\n}"}
{"instruction": "Write an Ephect PHP component", "input": "Based on Ephect source: PagesFinder.php", "output": "<?php\n\nnamespace Ephect\\Modules\\WebApp\\Builder\\Finders;\n\nuse Ephect\\Framework\\Utils\\File;\n\nclass PagesFinder implements FinderInterface\n{\n    public function find(): array\n    {\n        $result = [];\n\n        $pagesList = File::walkTreeFiltered(\\Constants::CUSTOM_PAGES_ROOT, ['phtml']);\n        foreach ($pagesList as $key => $pageFile) {\n            $result[] = $pageFile;\n        }\n        return $result;\n    }\n}"}
{"instruction": "Write an Ephect component", "input": "Based on Ephect source: RoutesFinder.php", "output": "<?php\n\nnamespace Ephect\\Modules\\WebApp\\Builder\\Finders;\n\nuse Ephect\\Modules\\Forms\\Components\\ComponentDeclaration;\nuse Ephect\\Modules\\Forms\\Components\\ComponentDeclarationStructure;\nuse Ephect\\Modules\\Forms\\Components\\ComponentEntity;\nuse Ephect\\Modules\\Forms\\Registry\\CodeRegistry;\nuse Ephect\\Modules\\Forms\\Registry\\ComponentRegistry;\nuse Ephect\\Modules\\Routing\\Builder\\RouteBuilder;\n\nclass RoutesFinder implements FinderInterface\n{\n    public function find(): array\n    {\n        $result = [];\n\n        $items = CodeRegistry::items();\n\n        $root = $this->findRouter($items, 'App');\n        if ($root !== null) {\n            $routes = $root->items();\n            foreach ($routes as $route) {\n                $props = (object)$route->props();\n                $rb = new RouteBuilder($props);\n                $re = $rb->build();\n\n                $result[] = $re->getRedirect();\n            }\n        }\n\n        if ($root === null) {\n            $root = $this->findFirstComponent($items, 'App');\n            // array_push($result, $root->getName());\n        }\n\n        return array_unique($result);\n    }\n\n    private function findRouter(array $items, string $name): ?ComponentEntity\n    {\n        $class = ComponentRegistry::read($name);\n        $list = $items[$class];\n\n        $struct = new ComponentDeclarationStructure($list);\n\n        $composition = $struct->composition;\n\n        $router = null;\n        foreach ($composition as $child) {\n            $name = $child['name'];\n            if ($name == 'Router') {\n                $router = ComponentEntity::buildFromArray($composition);\n\n                break;\n            }\n\n            $router = $this->findRouter($items, $name);\n            if ($router !== null) {\n                break;\n            }\n        }\n\n        return $router;\n    }\n\n    private function findFirstComponent(array $items, string $name): ?ComponentEntity\n    {\n        $class = ComponentRegistry::read($name);\n\n        $list = $items[$class];\n        $struct = new ComponentDeclarationStructure($list);\n        $decl = new ComponentDeclaration($struct);\n\n        return $decl->getComposition();\n    }\n}"}
{"instruction": "Write an Ephect component", "input": "Based on Ephect source: ModuleParser.php", "output": "<?php\n\nnamespace Ephect\\Modules\\WebApp\\Builder\\Parsers;\n\nuse Ephect\\Modules\\Forms\\Components\\ComponentEntity;\nuse Ephect\\Modules\\Forms\\Registry\\CodeRegistry;\nuse Ephect\\Modules\\Forms\\Registry\\ComponentRegistry;\nuse Ephect\\Modules\\Forms\\Generators\\ComponentParser;\n\nclass ModuleParser implements ParserTypeInterface\n{\n    public function __construct(private readonly string $moduleEntrypointClass, private readonly string $filename)\n    {\n    }\n\n    public function parse(): array\n    {\n        $comp = new $this->moduleEntrypointClass();\n        $comp->load($this->filename);\n        $comp->analyse();\n\n        $uid = $comp->getUID();\n        $parser = new ComponentParser($comp);\n        $struct = $parser->doDeclaration($uid);\n        $decl = $struct->toArray();\n\n        CodeRegistry::write($comp->getFullyQualifiedFunction(), $decl);\n        ComponentRegistry::write($this->filename, $uid);\n        ComponentRegistry::write($uid, $comp->getFullyQualifiedFunction());\n\n        $entity = ComponentEntity::buildFromArray($struct->composition);\n        $comp->add($entity);\n\n        return [$comp->getFullyQualifiedFunction(), $comp];\n    }\n}"}
{"instruction": "Write an Ephect component", "input": "Based on Ephect source: ParserFactory.php", "output": "<?php\n\nnamespace Ephect\\Modules\\WebApp\\Builder\\Parsers;\n\nuse Ephect\\Modules\\Forms\\Components\\Plugin;\n\nclass ParserFactory\n{\n    public static function createParser(string $moduleEntrypointClass, string $filename): ParserTypeInterface\n    {\n        return match ($moduleEntrypointClass) {\n            Plugin::class => new PluginParser($filename),\n            default => new ModuleParser($moduleEntrypointClass, $filename),\n        };\n    }\n}"}
{"instruction": "Write an Ephect PHP component", "input": "Based on Ephect source: ParserTypeInterface.php", "output": "<?php\n\nnamespace Ephect\\Modules\\WebApp\\Builder\\Parsers;\n\ninterface ParserTypeInterface\n{\n    public function parse(): array;\n}"}
{"instruction": "Write an Ephect component", "input": "Based on Ephect source: PluginParser.php", "output": "<?php\n\nnamespace Ephect\\Modules\\WebApp\\Builder\\Parsers;\n\nuse Ephect\\Modules\\Forms\\Components\\Plugin;\nuse Ephect\\Modules\\Forms\\Registry\\PluginRegistry;\n\nclass PluginParser implements ParserTypeInterface\n{\n    public function __construct(private readonly string $filename)\n    {\n    }\n\n    public function parse(): array\n    {\n        $plugin = new Plugin();\n        $plugin->load($this->filename);\n        $plugin->analyse();\n\n        PluginRegistry::write($this->filename, $plugin->getUID());\n        PluginRegistry::write($plugin->getUID(), $plugin->getFullyQualifiedFunction());\n\n        return [$plugin->getFullyQualifiedFunction(), $plugin];\n    }\n}"}
{"instruction": "Write an Ephect PHP component", "input": "Based on Ephect source: PageRegisterer.php", "output": "<?php\n\nnamespace Ephect\\Modules\\WebApp\\Builder\\Registerer;\n\nuse Ephect\\Framework\\Crypto\\Crypto;\nuse Ephect\\Framework\\ElementUtils;\nuse Ephect\\Modules\\WebApp\\Registry\\PageRegistry;\n\nclass PageRegisterer implements RegistererInterface\n{\n    public function register(array $values): void\n    {\n        PageRegistry::load();\n        foreach ($values as $page) {\n            $uid = Crypto::createOID();\n            $filename = \\Constants::CUSTOM_PAGES_ROOT . $page;\n\n            [\n                $namespace,\n                $functionName,\n                $parameters,\n                $returnedType,\n                $startsAt\n            ] = ElementUtils::getFunctionDefinitionFromFile($filename);\n\n            if ($startsAt == -1) {\n                $info = (object)pathinfo($filename);\n                $namespace = \\Constants::CONFIG_NAMESPACE;\n                $functionName = $info->filename;\n            }\n\n            $className = $namespace . '\\\\' . $functionName;\n            PageRegistry::write($uid, $className);\n            PageRegistry::write($className, $page);\n            PageRegistry::write($page, $uid);\n        }\n        PageRegistry::save();\n    }\n}"}
{"instruction": "Write an Ephect PHP component", "input": "Based on Ephect source: RegistererInterface.php", "output": "<?php\n\nnamespace Ephect\\Modules\\WebApp\\Builder\\Registerer;\n\ninterface RegistererInterface\n{\n    public function register(array $values): void;\n}"}
{"instruction": "Write an Ephect PHP component", "input": "Based on Ephect source: BuiderStrategyInterface.php", "output": "<?php\n\nnamespace Ephect\\Modules\\WebApp\\Builder\\Strategy;\n\ninterface BuiderStrategyInterface\n{\n    public function build(string $route): void;\n}"}
{"instruction": "Write an Ephect component", "input": "Based on Ephect source: BuildByNameStrategy.php", "output": "<?php\n\nnamespace Ephect\\Modules\\WebApp\\Builder\\Strategy;\n\nuse DateTime;\nuse Ephect\\Framework\\CLI\\Console;\nuse Ephect\\Framework\\CLI\\ConsoleColors;\nuse Ephect\\Framework\\Utils\\File;\nuse Ephect\\Modules\\Forms\\Components\\Component;\nuse Ephect\\Modules\\Forms\\Registry\\PluginRegistry;\nuse Ephect\\Modules\\Routing\\Services\\RouterService;\nuse Throwable;\n\nclass BuildByNameStrategy implements BuiderStrategyInterface\n{\n    public function build(string $route): void\n    {\n        PluginRegistry::load();\n\n        Console::write(\"Compiling %s ... \", ConsoleColors::getColoredString($route, ConsoleColors::LIGHT_CYAN));\n        Console::getLogger()->info(\"Compiling %s ... \", $route);\n\n        $comp = new Component($route);\n        $filename = $comp->getFlattenSourceFilename();\n\n        $html = '';\n        $error = '';\n\n        try {\n            $time_start = microtime(true);\n\n            $functionArgs = $route === 'App' ? [] : RouterService::findRouteArguments($route);\n\n            ob_start();\n            $comp->render($functionArgs);\n            $html = ob_get_clean();\n\n            $time_end = microtime(true);\n\n            $duration = $time_end - $time_start;\n\n            $utime = sprintf('%.3f', $duration);\n            $raw_time = DateTime::createFromFormat('u.u', $utime);\n            $duration = substr($raw_time->format('u'), 0, 3);\n\n            Console::writeLine(\"%s\", ConsoleColors::getColoredString($duration . \"ms\", ConsoleColors::RED));\n        } catch (Throwable $ex) {\n            $error = Console::formatException($ex);\n        }\n\n        if ($error !== '') {\n            Console::writeLine(\n                \"FATAL ERROR!%s %s\",\n                PHP_EOL,\n                ConsoleColors::getColoredString(\n                    $error,\n                    ConsoleColors::WHITE,\n                    ConsoleColors::BACKGROUND_RED\n                )\n            );\n        }\n\n        File::safeWrite(\\Constants::STATIC_DIR . $filename, $html);\n    }\n}"}
{"instruction": "Write an Ephect PHP component", "input": "Based on Ephect source: BuildByRouteStrategy.php", "output": "<?php\n\nnamespace Ephect\\Modules\\WebApp\\Builder\\Strategy;\n\nuse DateTime;\nuse Ephect\\Framework\\CLI\\Console;\nuse Ephect\\Framework\\CLI\\ConsoleColors;\nuse Ephect\\Framework\\Utils\\File;\nuse Ephect\\Framework\\Web\\Curl;\nuse Ephect\\Modules\\Routing\\Services\\RouterService;\nuse Exception;\n\nclass BuildByRouteStrategy implements BuiderStrategyInterface\n{\n    /**\n     * @throws Exception\n     */\n    public function build($route = 'Default'): void\n    {\n        // TODO: check if it works\n        //        $fqRouteParts = explode('\\\\', $route);\n        //        $route = array_pop($fqRouteParts);\n\n        $port = trim(File::safeRead(\\Constants::CONFIG_DIR . 'dev_port') ?? '80');\n\n        if ($route === 'App') {\n            return;\n        }\n\n        $queryString = $route === 'Default' ? '/' : RouterService::findRouteQueryString($route);\n        if ($queryString === null) {\n            return;\n        }\n\n        $filename = \"$route.html\";\n        $outputFilename = \"$route.out\";\n\n        Console::write(\"Compiling %s, \", ConsoleColors::getColoredString($route, ConsoleColors::LIGHT_CYAN));\n        Console::write(\"requesting %s ... \", ConsoleColors::getColoredString(\n            \\Constants::CONFIG_HOSTNAME . \":$port\" . $queryString,\n            ConsoleColors::LIGHT_GREEN\n        ));\n\n        $curl = new Curl();\n        $time_start = microtime(true);\n\n        $headers[] = 'Accept: text/html,application/xhtml+xml,application/xml;q=0.9,image/avif,image/webp,*/*;q=0.8';\n        $headers[] = 'Accept-Encoding: gzip, deflate, br';\n        $headers[] = 'Connection: keep-alive';\n        if (isset($_COOKIE['PHPSESSID'])) {\n            $headers[] = \"Cookie: PHPSESSID={$_COOKIE['PHPSESSID']};\";\n        }\n        $headers[] = 'Upgrade-Insecure-Requests: 1';\n        $headers[] = 'Sec-Fetch-Dest: document';\n        $headers[] = 'Sec-Fetch-Mode: navigate';\n        $headers[] = 'Sec-Fetch-Site: cross-site';\n        $headers[] = 'Pragma: no-cache';\n        $headers[] = 'Cache-Control: no-cache';\n\n        ob_start();\n        $curl->request(\\Constants::CONFIG_HOSTNAME . \":$port\" . $queryString, $headers);\n        ob_get_clean();\n\n        $time_end = microtime(true);\n\n        $duration = $time_end - $time_start;\n\n        $utime = sprintf('%.3f', $duration);\n        $raw_time = DateTime::createFromFormat('u.u', $utime);\n        $duration = substr($raw_time->format('u'), 0, 3);\n\n        Console::writeLine(\"%s\", ConsoleColors::getColoredString($duration . \"ms\", ConsoleColors::RED));\n    }\n}"}
{"instruction": "Write an Ephect PHP component", "input": "Based on Ephect source: CopierStrategyInterface.php", "output": "<?php\n\nnamespace Ephect\\Modules\\WebApp\\Builder\\Copiers\\Strategy;\n\ninterface CopierStrategyInterface\n{\n    public function copy(string $path, string $key, string $filename): void;\n\n}"}
{"instruction": "Write an Ephect PHP component", "input": "Based on Ephect source: CopiersFactory.php", "output": "<?php\n\nnamespace Ephect\\Modules\\WebApp\\Builder\\Copiers\\Strategy;\n\nclass CopiersFactory\n{\n    public static function createCopier(bool $asUnique = false): CopierStrategyInterface\n    {\n        return match ($asUnique) {\n            true => new CopyAsUniqueStrategy(),\n            false => new CopyAsIsStrategy(),\n        };\n    }\n}"}
{"instruction": "Write an Ephect PHP component", "input": "Based on Ephect source: CopyAsIsStrategy.php", "output": "<?php\n\nnamespace Ephect\\Modules\\WebApp\\Builder\\Copiers\\Strategy;\n\nuse Ephect\\Framework\\Utils\\File;\n\nclass CopyAsIsStrategy implements CopierStrategyInterface\n{\n    public function __construct()\n    {\n        File::safeMkDir(\\Constants::COPY_DIR);\n    }\n\n    public function copy(string $path, string $key, string $filename): void\n    {\n        $root = pathinfo($path, PATHINFO_FILENAME) . DIRECTORY_SEPARATOR;\n        $stdFile = str_replace(pathinfo($filename, PATHINFO_EXTENSION), 'php', $filename);\n\n        if ($root === \\Constants::APP_DIR) {\n            $root = DIRECTORY_SEPARATOR;\n        }\n\n        $dirname = pathinfo($stdFile, PATHINFO_DIRNAME) . DIRECTORY_SEPARATOR;\n        $basename = pathinfo($stdFile, PATHINFO_BASENAME);\n        File::safeMkDir(\\Constants::COPY_DIR . $root . $dirname);\n        copy($path . $dirname . $basename, \\Constants::COPY_DIR . $root . $dirname . $basename);\n    }\n}"}
{"instruction": "Write an Ephect component", "input": "Based on Ephect source: CopyAsUniqueStrategy.php", "output": "<?php\n\nnamespace Ephect\\Modules\\WebApp\\Builder\\Copiers\\Strategy;\n\nuse Ephect\\Framework\\ElementUtils;\nuse Ephect\\Framework\\Utils\\File;\nuse Ephect\\Modules\\Forms\\Components\\Component;\n\nclass CopyAsUniqueStrategy implements CopierStrategyInterface\n{\n    private string $uniqueDomain = '';\n    public function __construct()\n    {\n        $this->uniqueDomain = \"Unique\" . uniqid();\n        File::safeMkDir(\\Constants::UNIQUE_DIR);\n    }\n\n    public function copy(string $path, string $key, string $filename): void\n    {\n        $root = pathinfo($path, PATHINFO_FILENAME) . DIRECTORY_SEPARATOR;\n\n        if ($root === \\Constants::APP_DIR) {\n            $root = DIRECTORY_SEPARATOR;\n        }\n\n        $dirname = pathinfo($filename, PATHINFO_DIRNAME) . DIRECTORY_SEPARATOR;\n        $basename = pathinfo($filename, PATHINFO_BASENAME);\n        File::safeMkDir(\\Constants::UNIQUE_DIR . $root . $dirname);\n        $contents = file_get_contents($path . $dirname . $basename);\n\n        [\n            $namespace,\n            $functionName,\n            $parameters,\n            $returnedType,\n            $startsAt\n        ] = ElementUtils::getFunctionDefinition($contents);\n\n        if ($startsAt == -1) {\n            $comp = Component::createByHtml($contents);\n            $comp->makeComponent($filename, $contents);\n        }\n\n        $contents = str_replace('namespace ' . \\Constants::CONFIG_NAMESPACE, 'namespace ' .  $this->uniqueDomain, $contents);\n        $contents = preg_replace('/^use ' . \\Constants::CONFIG_NAMESPACE . '/m', 'use ' .  $this->uniqueDomain, $contents);\n        $contents = preg_replace(\n            '/^use function ' . \\Constants::CONFIG_NAMESPACE . '/m',\n            'use function ' .  $this->uniqueDomain,\n            $contents\n        );\n        $actualFilename = \\Constants::UNIQUE_DIR . $root . $dirname . $basename;\n\n        File::safeWrite(str_replace(pathinfo($actualFilename, PATHINFO_EXTENSION), 'php', $actualFilename), $contents);\n    }\n}"}
{"instruction": "Write an Ephect command handler", "input": "Based on Ephect source: Common.php", "output": "<?php\n\nnamespace Ephect\\Modules\\Samples\\Commands;\n\nuse Constants;\nuse Ephect\\Framework\\CLI\\Console;\nuse Ephect\\Framework\\CLI\\ConsoleColors;\nuse Ephect\\Framework\\Modules\\ModuleManifestEntity;\nuse Ephect\\Framework\\Modules\\ModuleManifestReader;\nuse Ephect\\Framework\\Utils\\File;\n\nclass Common\n{\n    public static function getModuleDir()\n    {\n        return  dirname(__DIR__, 2) . DIRECTORY_SEPARATOR;\n    }\n\n    public static function getModuleSrcDir()\n    {\n        return  dirname(__DIR__) . DIRECTORY_SEPARATOR;\n    }\n\n    public static function getModuleConfDir()\n    {\n        return  dirname(__DIR__, 2) . DIRECTORY_SEPARATOR . Constants::REL_CONFIG_DIR;\n    }\n\n    public static function getModuleManifest(): ModuleManifestEntity\n    {\n        $manifestReader = new ModuleManifestReader();\n        return $manifestReader->read(Common::getModuleConfDir());\n    }\n\n    public function createCommonTrees(): void\n    {\n        $common = self::getModuleSrcDir() . 'Assets' . DIRECTORY_SEPARATOR . 'Common';\n\n        Console::writeLine(ConsoleColors::getColoredString(\"Publishing Common files...\", ConsoleColors::BLUE));\n        \n        $this->publishConfigFiles($common);\n        $this->publishAppFiles($common);\n    }\n\n    private function publishConfigFiles(string $commonDir): void\n    {\n        File::safeMkDir(Constants::CONFIG_DIR);\n        $destDir = realpath(Constants::CONFIG_DIR);\n\n        $srcDir = $commonDir . DIRECTORY_SEPARATOR . 'config';\n\n        $this->publishFiles($srcDir, $destDir);\n    }\n\n    private function publishAppFiles(string $commonDir): void\n    {\n        $srcDir = $commonDir . DIRECTORY_SEPARATOR . 'app';\n\n        File::safeMkDir(siteSrcPath());\n        $destDir = realpath(siteSrcPath());\n\n        $this->publishFiles($srcDir, $destDir);\n    }\n\n    public function publishFiles(string $srcDir, string $destDir): void\n    {\n        if (!file_exists($srcDir)) {\n            Console::writeLine(\"Stopping! source dir %s does not exist.\", $srcDir);\n            return;\n        }\n\n        if (!file_exists($destDir)) {\n            Console::writeLine(\"Stopping! destination dir %s does not exist.\", $destDir);\n            return;\n        }\n\n        $tree = File::walkTreeFiltered($srcDir);\n        Console::writeLine(ConsoleColors::getColoredString(\"Source directory: $srcDir\", ConsoleColors::GREEN));\n        Console::writeLine(ConsoleColors::getColoredString(\"Destination directory: $destDir\", ConsoleColors::GREEN));\n        foreach ($tree as $filePath) {\n            Console::writeLine(\"Copying file: %s\", $filePath);\n            File::safeWrite($destDir . $filePath, '');\n            copy($srcDir . $filePath, $destDir . $filePath);\n        }\n    }\n\n    public function requireTree(string $treePath): object\n    {\n        $tree = File::walkTreeFiltered($treePath, ['php']);\n        $result = ['path' => $treePath, 'tree' => $tree];\n\n        return (object)$result;\n    }\n\n    public function displayTree($path): void\n    {\n        $tree = File::walkTreeFiltered($path);\n        Console::writeLine($tree);\n    }\n}"}
{"instruction": "Write an Ephect command handler", "input": "Based on Ephect source: Lib.php", "output": "<?php\n\nnamespace Ephect\\Modules\\Samples\\Commands\\MakeQuickStart;\n\nuse Ephect\\Framework\\CLI\\Console;\nuse Ephect\\Framework\\CLI\\ConsoleColors;\nuse Ephect\\Framework\\Commands\\AbstractCommandLib;\nuse Ephect\\Framework\\Utils\\File;\nuse Ephect\\Framework\\Modules\\Utils;\nuse Ephect\\Modules\\Samples\\Commands\\Common;\n\nclass Lib extends AbstractCommandLib\n{\n    public function createQuickstart(): void\n    {\n        Console::writeLine(ConsoleColors::getColoredString(\"Publishing Skeleton files...\", ConsoleColors::BLUE));\n\n        $utils = new Utils(dirname(__DIR__));\n\n        $sample = $utils->getModuleSrcDir() . 'Assets' . DIRECTORY_SEPARATOR . 'QuickStart';\n\n        File::safeMkDir(siteSrcPath());\n        $destDir = realpath(siteSrcPath());\n\n        $common = new Common();\n        $common->publishFiles($sample, $destDir);\n    }\n}"}
{"instruction": "Write an Ephect command handler", "input": "Based on Ephect source: Main.php", "output": "<?php\n\nnamespace Ephect\\Modules\\Samples\\Commands\\MakeQuickStart;\n\nuse Ephect\\Framework\\Commands\\AbstractCommand;\nuse Ephect\\Framework\\Commands\\Attributes\\CommandDeclaration;\nuse Ephect\\Modules\\Samples\\Commands\\Common;\nuse Ephect\\Modules\\Samples\\Commands\\MakeQuickStart\\Lib;\n\n#[CommandDeclaration(verb: \"make\", subject: \"quickstart\")]\n#[CommandDeclaration(desc: \"Create the quickstart application tree.\")]\nclass Main extends AbstractCommand\n{\n    public function run(): int\n    {\n        $use = new Common();\n        $use->createCommonTrees();\n\n        $lib = new Lib($this->application);\n        $lib->createQuickstart();\n\n        return 0;\n    }\n}"}
{"instruction": "Write an Ephect command handler", "input": "Based on Ephect source: Lib.php", "output": "<?php\n\nnamespace Ephect\\Modules\\Samples\\Commands\\MakeSkeleton;\n\nuse Ephect\\Framework\\CLI\\Console;\nuse Ephect\\Framework\\CLI\\ConsoleColors;\nuse Ephect\\Framework\\Commands\\AbstractCommandLib;\nuse Ephect\\Framework\\Utils\\File;\nuse Ephect\\Framework\\Modules\\Utils;\nuse Ephect\\Modules\\Samples\\Commands\\Common;\n\nclass Lib extends AbstractCommandLib\n{\n    public function makeSkeleton(): void\n    {\n\n        $utils = new Utils(dirname(__DIR__));\n\n        Console::writeLine(ConsoleColors::getColoredString(\"Publishing QuickStart files...\", ConsoleColors::BLUE));\n\n        $sample = $utils->getModuleSrcDir() . 'Assets' . DIRECTORY_SEPARATOR . 'Skeleton';\n\n        File::safeMkDir(siteSrcPath());\n        $destDir = realpath(siteSrcPath());\n\n        $common = new Common();\n        $common->publishFiles($sample, $destDir);    \n    }\n}"}
{"instruction": "Write an Ephect command handler", "input": "Based on Ephect source: Main.php", "output": "<?php\n\nnamespace Ephect\\Modules\\Samples\\Commands\\MakeSkeleton;\n\nuse Ephect\\Framework\\Commands\\AbstractCommand;\nuse Ephect\\Framework\\Commands\\Attributes\\CommandDeclaration;\nuse Ephect\\Modules\\Samples\\Commands\\Common;\nuse Ephect\\Modules\\Samples\\Commands\\MakeSkeleton\\Lib;\n\n#[CommandDeclaration(verb: \"make\", subject: \"skeleton\")]\n#[CommandDeclaration(desc: \"Create the skeleton application tree.\")]\nclass Main extends AbstractCommand\n{\n    public function run(): int\n    {\n        $use = new Common();\n        $use->createCommonTrees();\n        $lib = new Lib($this->application);\n        $lib->makeSkeleton();\n\n        return 0;\n    }\n}"}
{"instruction": "Write an Ephect command handler", "input": "Based on Ephect source: Main.php", "output": "<?php\n\nnamespace QuickStart\\Commands\\Hello;\n\nuse Ephect\\Framework\\CLI\\Console;\nuse Ephect\\Framework\\Commands\\AbstractCommand;\nuse Ephect\\Framework\\Commands\\Attributes\\CommandDeclaration;\n\n#[CommandDeclaration(verb: \"say\", subject: \"hello\")]\n#[CommandDeclaration(desc: \"Say hello.\")]\nclass Main extends AbstractCommand\n{\n    public function run(): int\n    {\n        $data = 'world';\n        $data = $this->application->getArgi(2, $data);\n        Console::writeLine(\"Hello %s!\", $data);\n\n        return 0;\n    }\n}"}
{"instruction": "Write an Ephect component", "input": "Based on Ephect source: modulesPaths.php", "output": "<?php\n\nreturn [\n    \\Constants::EPHECT_ROOT . 'Modules/DataAccess',\n    \\Constants::EPHECT_ROOT . 'Modules/Forms',\n    \\Constants::EPHECT_ROOT . 'Modules/Http',\n    \\Constants::EPHECT_ROOT . 'Modules/JavaScripts',\n    \\Constants::EPHECT_ROOT . 'Modules/Routing',\n    \\Constants::EPHECT_ROOT . 'Modules/Samples',\n    \\Constants::EPHECT_ROOT . 'Modules/WebApp',\n    \\Constants::EPHECT_ROOT . 'Modules/WebComponent',\n]\n;"}
{"instruction": "Write an Ephect PHP component", "input": "Based on Ephect source: bootstrap.php", "output": "<?php\n\ninclude '../vendor/autoload.php';"}
{"instruction": "Write an Ephect PHP component", "input": "Based on Ephect source: index.php", "output": "<?php\ninclude dirname(__FILE__, 2) . DIRECTORY_SEPARATOR . 'bootstrap.php';\nEphect\\Modules\\WebApp\\Web\\Application::create();"}
{"instruction": "Write an Ephect PHP component", "input": "Based on Ephect source: info.php", "output": "<?php\n\nphpinfo();"}
{"instruction": "Write an Ephect PHP component", "input": "Based on Ephect source: RouteMiddleware.php", "output": "<?php\n\nnamespace Ephect\\Modules\\Routing\\Attributes;\n\nuse Attribute;\nuse Ephect\\Framework\\Middlewares\\AttributeMiddlewareInterface;\nuse Ephect\\Modules\\Routing\\Middlewares\\RouteParserMiddleware;\n\n#[Attribute(Attribute::TARGET_FUNCTION)]\nclass RouteMiddleware implements AttributeMiddlewareInterface\n{\n    public function getMiddlewares(): array\n    {\n        return [RouteParserMiddleware::class];\n    }\n}"}
{"instruction": "Write an Ephect PHP component", "input": "Based on Ephect source: RouteInterface.php", "output": "<?php\n\nnamespace Ephect\\Modules\\Routing\\Base;\n\nuse Ephect\\Framework\\ElementInterface;\n\ninterface RouteInterface extends ElementInterface\n{\n    public function getMethod(): string;\n\n    public function getRule(): string;\n\n    public function getNormalized(): string;\n\n    public function getRedirect(): string;\n\n    public function getTranslation(): string;\n\n    public function getError(): int;\n\n    public function isExact(): bool;\n\n    public function getMiddlewares(): array;\n}"}
{"instruction": "Write an Ephect PHP component", "input": "Based on Ephect source: RouteStructure.php", "output": "<?php\n\nnamespace Ephect\\Modules\\Routing\\Base;\n\nuse Ephect\\Framework\\Structure\\Structure;\n\nclass RouteStructure extends Structure\n{\n    public string $uid = '';\n    public string $method = '';\n    public string $rule = '';\n    public string $normalized = '';\n    public string $redirect = '';\n    public string $translation = '';\n    public string $error = '';\n    public string $exact = '';\n    public array $middlewares = [];\n}"}
{"instruction": "Write an Ephect component", "input": "Based on Ephect source: RouteBuilder.php", "output": "<?php\n\nnamespace Ephect\\Modules\\Routing\\Builder;\n\nuse Ephect\\Framework\\ElementUtils;\nuse Ephect\\Modules\\Forms\\Components\\Children;\nuse Ephect\\Modules\\Routing\\Base\\RouteInterface;\nuse Ephect\\Modules\\Routing\\Base\\RouteStructure;\nuse Ephect\\Modules\\Routing\\Entities\\RouteEntity;\nuse Ephect\\Modules\\Forms\\Builders\\AbstractBuilder;\nuse Ephect\\Modules\\WebApp\\Registry\\PageRegistry;\n\nclass RouteBuilder extends AbstractBuilder\n{\n    private Children|null $children = null;\n\n    public function __construct(object $props)\n    {\n        parent::__construct($props, RouteStructure::class);\n    }\n\n    public function build(): RouteInterface\n    {\n        $route = parent::buildEx(RouteEntity::class);\n        $route = $this->translateQueryStringRoute($route);\n        $route = $this->translateNamedArgumentsRoute($route);\n\n        return $route;\n    }\n    /**\n     * @throws \\Exception\n     */\n    public static function normalizeRedirect(string $redirect): string\n    {\n        $redirect = ElementUtils::normalizeClassname($redirect);\n        $pageFilename = PageRegistry::read($redirect);\n\n        if ($pageFilename === null) {\n            throw new \\Exception(\"Redirect component [$redirect] not found\");\n        }\n\n        return $redirect;\n    }\n\n    /**\n     * @throws \\Exception\n     */\n    private function translateQueryStringRoute(RouteInterface $route): RouteInterface\n    {\n\n        $rule = $route->getRule();\n\n        $re = '/[a-z]+=(\\(\\.\\*\\)|\\(\\.\\+\\)|\\(\\\\\\\\w\\+\\))/m';\n        $re = '/(\\(\\.\\*\\)|\\(\\.\\+\\)|\\(\\\\\\\\w\\+\\))/m';\n\n        preg_match_all($re, $rule, $matches, PREG_SET_ORDER, 0);\n\n        $translated = $rule;\n\n        $c = count($matches);\n        for ($i = 0; $i < $c; $i++) {\n            $match = preg_quote($matches[$i][0]);\n            $argn = $i + 1;\n            $translated = preg_replace('/' . $match . '/m', '\\\\$' . $argn, $translated, 1);\n        }\n\n        if ($translated === $rule && $translated !== '/') {\n            $re = '/(\\W*)(\\w+)(.*)/m';\n            $subst = '/$2';\n\n            $translated = preg_replace($re, $subst, $rule);\n\n            /**\n             * TODO: watch out how it behaves in more use cases\n             */\n            //             if ($translated === $rule) {\n            //                 return $route;\n            //             }\n        }\n\n        $redirect = $route->getRedirect();\n        // TODO: check if it works\n        //$redirect = self::normalizeRedirect($redirect);\n\n        $struct = new RouteStructure([\n            'method' => $route->getMethod(),\n            'rule' => $rule,\n            'normalized' => $rule,\n            'redirect' => $redirect,\n            'translation' => $translated,\n            'error' => $route->getError(),\n            'exact' => $route->isExact()\n        ]);\n\n        return new RouteEntity($struct);\n    }\n\n    private function translateNamedArgumentsRoute(RouteInterface $route): RouteInterface\n    {\n        $rule = $route->getRule();\n\n        $re = '/(\\(\\w+\\))/m';\n        $subst = '(\\\\\\\\S+)';\n\n        $normalized = preg_replace($re, $subst, $rule);\n\n        if ($normalized === $rule) {\n            return $route;\n        }\n\n        $re = '/([^(]+)?(\\/\\(([\\w\\-]+)\\))/m';\n        preg_match_all($re, $rule, $matches, PREG_SET_ORDER, 0);\n\n        $translated = $rule;\n\n        $c = count($matches);\n        for ($i = 0; $i < $c; $i++) {\n            $argn = $i + 1;\n            $match = preg_quote($matches[$i][2]);\n            $subst = ($i === 0 ? '?' : '&') . $matches[$i][3] . '=\\\\$' . $argn;\n            $translated = preg_replace('@' . $match . '@m', $subst, $translated, 1);\n        }\n\n        $redirect = $route->getRedirect();\n        // TODO: check if it works\n        //$redirect = self::normalizeRedirect($redirect);\n\n        $struct = new RouteStructure([\n            'method' => $route->getMethod(),\n            'rule' => $normalized,\n            'normalized' => $rule,\n            'redirect' => $redirect,\n            'translation' => $translated,\n            'error' => $route->getError(),\n            'exact' => $route->isExact()\n        ]);\n\n        return new RouteEntity($struct);\n    }\n\n}"}
{"instruction": "Write an Ephect PHP component", "input": "Based on Ephect source: RouteEntity.php", "output": "<?php\n\nnamespace Ephect\\Modules\\Routing\\Entities;\n\nuse Ephect\\Framework\\ElementTrait;\nuse Ephect\\Framework\\Entity\\Entity;\nuse Ephect\\Modules\\Routing\\Base\\RouteInterface;\nuse Ephect\\Modules\\Routing\\Base\\RouteStructure;\n\nclass RouteEntity extends Entity implements RouteInterface\n{\n    use ElementTrait;\n\n    private string $method = '';\n    private string $rule = '';\n    private string $normalized = '';\n    private string $redirect = '';\n    private string $translation = '';\n    private int $error = 0;\n    private bool $exact = false;\n    private array $middlewares = [];\n\n    public function __construct(RouteStructure $struct)\n    {\n        parent::__construct($struct);\n\n        $this->method = $struct->method;\n        $this->rule = $struct->rule;\n        $this->normalized = $struct->normalized;\n        $this->redirect = $struct->redirect;\n        $this->translation = $struct->translation;\n        $this->error = (int)$struct->error;\n        $this->exact = $struct->exact !== 'true' ?: true;\n        $this->middlewares = $struct->middlewares;\n\n    }\n\n    public function getMethod(): string\n    {\n        return $this->method;\n    }\n\n    public function getRule(): string\n    {\n        return $this->rule;\n    }\n\n    public function getNormalized(): string\n    {\n        return $this->normalized;\n    }\n\n    public function getRedirect(): string\n    {\n        return $this->redirect;\n    }\n\n    public function getTranslation(): string\n    {\n        return $this->translation;\n    }\n\n    public function getError(): int\n    {\n        return $this->error;\n    }\n\n    public function isExact(): bool\n    {\n        return $this->exact;\n    }\n\n    public function getMiddlewares(): array\n    {\n        return $this->middlewares;\n    }\n\n\n}"}
{"instruction": "Write an Ephect component", "input": "Based on Ephect source: RouteParserMiddleware.php", "output": "<?php\n\nnamespace Ephect\\Modules\\Routing\\Middlewares;\n\nuse Ephect\\Framework\\Middlewares\\AttributeMiddlewareInterface;\nuse Ephect\\Modules\\Forms\\Components\\ComponentDeclaration;\nuse Ephect\\Modules\\Forms\\Components\\ComponentEntityInterface;\nuse Ephect\\Modules\\Forms\\Middlewares\\ComponentParserMiddlewareInterface;\nuse Ephect\\Modules\\Forms\\Registry\\ComponentRegistry;\nuse Ephect\\Modules\\Routing\\Attributes\\RouteMiddleware;\nuse Ephect\\Modules\\Routing\\Base\\RouteStructure;\nuse Ephect\\Modules\\Routing\\Entities\\RouteEntity;\nuse Ephect\\Modules\\Routing\\Registry\\RouteRegistry;\nuse Exception;\n\nclass RouteParserMiddleware implements ComponentParserMiddlewareInterface\n{\n    public function parse(\n        ComponentEntityInterface|null $parent,\n        string $motherUID,\n        string $funcName,\n        string $props,\n        array $arguments\n    ): void {\n        if ($parent == null || $parent->getName() != 'Route') {\n            return;\n        }\n\n        $filename = $motherUID . DIRECTORY_SEPARATOR . ComponentRegistry::read($funcName);\n\n        $route = new RouteEntity(new RouteStructure($parent->props()));\n        $middlewareHtml = \"function() {\\n\\tinclude_once \\\\Constants::BUILD_DIR . '$filename';\\n\\t\\$fn = \\\\{$funcName}($props); \\$fn();\\n}\\n\";\n\n        $decl = ComponentDeclaration::byName($funcName);\n        $attrs = $decl->getAttributes();\n\n        foreach ($attrs as $attr) {\n            if (!isset($attr['name'])) {\n                continue;\n            }\n\n            $attr = (object)$attr;\n\n            if (count($attr->arguments) > 0) {\n                $attrNew = new $attr->name(...$attr->arguments);\n            } else {\n                $attrNew = new $attr->name();\n            }\n\n            if ($attrNew instanceof AttributeMiddlewareInterface) {\n                $middlewaresList[$attr->name] = [\n                    $attr->arguments,\n                    $attrNew->getMiddlewares(),\n                ];\n            }\n        }\n        $isMiddleware = false;\n        foreach ($attrs as $attr) {\n            if (!isset($attr['name'])) {\n                continue;\n            }\n            $attr = (object)$attr;\n\n            $isMiddleware = $attr->name == RouteMiddleware::class;\n            if ($isMiddleware) {\n                break;\n            }\n        }\n\n        if (!count($attrs) || !$isMiddleware) {\n            throw new Exception(\"$funcName is not a route middleware\");\n        }\n        RouteRegistry::load();\n        $methodRegistry = RouteRegistry::read($route->getMethod()) ?: [];\n\n        if (isset($methodRegistry[$route->getRule()])) {\n            $methodRegistry[$route->getRule()]['middlewares'][] = $middlewareHtml;\n        } else {\n            $methodRegistry[$route->getRule()] = [\n                'rule' => $route->getRule(),\n                'redirect' => $route->getRedirect(),\n                'error' => $route->getError(),\n                'exact' => $route->isExact(),\n                'middlewares' => [$middlewareHtml,],\n                'translate' => $route->getRule(),\n                'normal' => $route->getRule(),\n            ];\n        }\n\n        RouteRegistry::write($route->getMethod(), $methodRegistry);\n        RouteRegistry::save();\n    }\n}"}
{"instruction": "Write an Ephect PHP component", "input": "Based on Ephect source: HttpErrorRegistry.php", "output": "<?php\n\nnamespace Ephect\\Modules\\Routing\\Registry;\n\nuse Ephect\\Framework\\Registry\\AbstractStaticRegistry;\nuse Ephect\\Framework\\Registry\\RegistryInterface;\n\nclass HttpErrorRegistry extends AbstractStaticRegistry\n{\n    private static ?HttpErrorRegistry $instance = null;\n\n    public static function reset(): void\n    {\n        self::$instance = new HttpErrorRegistry();\n        unlink(self::$instance->getCacheFilename());\n    }\n\n    public static function getInstance(): HttpErrorRegistry\n    {\n        if (self::$instance === null) {\n            self::$instance = new HttpErrorRegistry();\n        }\n\n        return self::$instance;\n    }\n}"}
{"instruction": "Write an Ephect PHP component", "input": "Based on Ephect source: RouteRegistry.php", "output": "<?php\n\nnamespace Ephect\\Modules\\Routing\\Registry;\n\nuse Ephect\\Framework\\Registry\\AbstractStaticRegistry;\nuse Ephect\\Framework\\Registry\\RegistryInterface;\n\nclass RouteRegistry extends AbstractStaticRegistry\n{\n    private static ?RouteRegistry $instance = null;\n\n    public static function addMiddleware(string $middleware): void\n    {\n        self::getInstance()->__addMiddleware($middleware);\n    }\n\n    public function __addMiddleware(string $middleware): void\n    {\n        $this->__write('middlewares', $middleware);\n    }\n\n    public static function getInstance(): RouteRegistry\n    {\n        if (self::$instance === null) {\n            self::$instance = new RouteRegistry();\n        }\n\n        return self::$instance;\n    }\n\n    public static function reset(): void\n    {\n        self::$instance = new RouteRegistry();\n        unlink(self::$instance->getCacheFilename());\n    }\n\n    public static function getCachedRoutes(): ?array\n    {\n        $result = null;\n\n        if (self::hasMoved()) {\n            $result = require self::getMovedPhpFilename();\n        }\n\n        return $result;\n    }\n\n    public static function hasMoved(): bool\n    {\n        return file_exists(self::getMovedPhpFilename());\n    }\n\n    public static function getMovedPhpFilename(): string\n    {\n        return \\Constants::BUILD_DIR . 'routes.php';\n    }\n\n    public static function getMovedFilename(): string\n    {\n        return \\Constants::BUILD_DIR . 'routes.json';\n    }\n}"}
{"instruction": "Write an Ephect component", "input": "Based on Ephect source: RouterService.php", "output": "<?php\n\nnamespace Ephect\\Modules\\Routing\\Services;\n\nuse Ephect\\Framework\\Utils\\File;\nuse Ephect\\Framework\\Utils\\Text;\nuse Ephect\\Modules\\Forms\\Components\\Component;\nuse Ephect\\Modules\\Forms\\Registry\\ComponentRegistry;\nuse Ephect\\Modules\\Http\\Transport\\Request;\nuse Ephect\\Modules\\Routing\\Base\\RouteInterface;\nuse Ephect\\Modules\\Routing\\Registry\\HttpErrorRegistry;\nuse Ephect\\Modules\\Routing\\Registry\\RouteRegistry;\nuse Ephect\\Modules\\WebApp\\Registry\\PageRegistry;\n\nuse function Ephect\\Hooks\\useMemory;\n\nclass RouterService implements RouterServiceInterface\n{\n    public function __construct()\n    {\n        RouteRegistry::load();\n        HttpErrorRegistry::load();\n    }\n\n    public static function findRouteArguments(string $route): ?array\n    {\n        $result = [];\n\n        $routes = RouteRegistry::items();\n        if (count($routes) === 0) {\n            $routes = RouteRegistry::getCachedRoutes();\n        }\n\n        $routeParts = explode('\\\\', $route);\n        if (count($routeParts) > 0) {\n            $route = array_pop($routeParts);\n        }\n\n        $allroutes = [];\n\n        foreach ($routes as $method => $rules) {\n            $allroutes = array_merge($allroutes, $rules);\n        }\n\n        $allroutes = array_filter($allroutes, function ($item) use ($route) {\n            return $item['redirect'] == $route && $item['translate'] != '';\n        });\n\n        if (count($allroutes) === 0) {\n            return null;\n        }\n\n        sort($allroutes);\n\n        $query = parse_url('https://localhost' . $allroutes[0]['translate'], PHP_URL_QUERY);\n\n        if ($query === null || $query === false) {\n            return null;\n        }\n\n        parse_str($query, $result);\n\n        return $result;\n    }\n\n    public static function findRouteNames(): ?array\n    {\n        $routes = RouteRegistry::items();\n        if (count($routes) === 0) {\n            $routes = RouteRegistry::getCachedRoutes();\n        }\n\n        $allroutes = $routes['GET'];\n\n        $result = array_map(function ($item) {\n            return $item['redirect'];\n        }, $allroutes);\n\n        return array_unique($result);\n    }\n\n    public static function findRouteByQueryString(string $query): ?string\n    {\n        $routes = RouteRegistry::items();\n        if (count($routes) === 0) {\n            $routes = RouteRegistry::getCachedRoutes();\n        }\n\n        $allroutes = $routes['GET'];\n\n        $allroutes = array_filter($allroutes, function ($item) use ($query) {\n            return $item['translate'] == $query;\n        });\n\n        if (count($allroutes) === 0) {\n            return null;\n        }\n\n        sort($allroutes);\n\n        $finalRoute = (object)$allroutes[0];\n\n        $result = $finalRoute->redirect;\n\n        return $result;\n    }\n\n    public static function findRouteQueryString(string $route): ?string\n    {\n        $routes = RouteRegistry::items();\n        if (count($routes) === 0) {\n            $routes = RouteRegistry::getCachedRoutes();\n        }\n\n        $routeParts = explode('\\\\', $route);\n        if (count($routeParts) > 0) {\n            $route = array_pop($routeParts);\n        }\n\n        $allroutes = $routes['GET'];\n\n        $allroutes = array_filter($allroutes, function ($item) use ($route) {\n            return $item['redirect'] == $route && $item['translate'] != '';\n        });\n\n        if (count($allroutes) === 0) {\n            return null;\n        }\n\n        sort($allroutes);\n\n        $finalRoute = (object)$allroutes[0];\n        if ($finalRoute->rule === $finalRoute->normal) {\n            $queryString = str_replace(\"\\\\\", \"\", $finalRoute->translate);\n\n            return $queryString;\n        }\n\n        $queryString = parse_url('http://localhost' . $finalRoute->translate, PHP_URL_QUERY);\n        parse_str($queryString, $arguments);\n\n        $queryString = $finalRoute->normal;\n        foreach ($arguments as $argument => $value) {\n            $queryString = str_replace('(' . $argument . ')', $value, $queryString);\n            $queryString = str_replace('$', '', $queryString);\n        }\n\n        return $queryString;\n    }\n\n    public function findRoute(string &$html): void\n    {\n        $html = '';\n        [$routes] = useMemory(get: 'routes');\n\n        if (count($routes ?? []) === 0) {\n            return;\n        }\n\n        $responseCode = 404;\n        $query = [];\n\n        $c = count($routes);\n\n        for ($i = 0; $i < $c; $i++) {\n            $route = $routes[$i];\n            $path = $route->path;\n            $query = $route->query;\n            $error = $route->error;\n            $responseCode = $route->code;\n            $middlewares = $route->middlewares ?? [];\n\n            if ($responseCode === 200) {\n                $i = $c;\n            }\n        }\n\n        $this->renderRoute($responseCode === 200, $path, $query, $error, $responseCode, $middlewares, $html);\n    }\n\n    /**\n     * @throws \\ReflectionException\n     */\n    public function renderRoute(\n        bool $pageFound,\n        string $path,\n        array|object|null $query,\n        int $error,\n        int $responseCode,\n        array $middlewares,\n        string &$html\n    ): void {\n        if ($responseCode >= 400) {\n            http_response_code($responseCode);\n            $path = HttpErrorRegistry::read($responseCode);\n\n            if (ComponentRegistry::read($path) === null) {\n                $html = 'Unknown error';\n                $html = ($responseCode === 400) ? 'Bad request' : $html;\n                $html = ($responseCode === 401) ? 'Unauthorized' : $html;\n                $html = ($responseCode === 403) ? 'Forbidden' : $html;\n                $html = ($responseCode === 404) ? 'Page not found' : $html;\n                $html = ($responseCode === 405) ? 'Method not allowed' : $html;\n                $html = ($responseCode === 406) ? 'Not acceptable' : $html;\n                $html = ($responseCode === 407) ? 'Proxy authentication required' : $html;\n                $html = ($responseCode === 408) ? 'Request timeout' : $html;\n                $html = ($responseCode === 409) ? 'Conflict' : $html;\n                $html = ($responseCode === 410) ? 'Gone' : $html;\n                $html = ($responseCode === 411) ? 'Length required' : $html;\n                $html = ($responseCode === 412) ? 'Precondition failed' : $html;\n                $html = ($responseCode === 413) ? 'Payload too large' : $html;\n                $html = ($responseCode === 414) ? 'URI too long' : $html;\n                $html = ($responseCode === 415) ? 'Unsupported media type' : $html;\n                $html = ($responseCode === 416) ? 'Range not satisfiable' : $html;\n                $html = ($responseCode === 417) ? 'Expectation failed' : $html;\n                $html = ($responseCode === 418) ? 'I\\'m a teapot' : $html;\n                $html = ($responseCode === 421) ? 'Misdirected request' : $html;\n                $html = ($responseCode === 422) ? 'Unprocessable entity' : $html;\n                $html = ($responseCode === 423) ? 'Locked' : $html;\n                $html = ($responseCode === 424) ? 'Failed dependency' : $html;\n                $html = ($responseCode === 425) ? 'Too early' : $html;\n                $html = ($responseCode === 426) ? 'Upgrade required' : $html;\n                $html = ($responseCode === 428) ? 'Precondition required' : $html;\n                $html = ($responseCode === 429) ? 'Too many requests' : $html;\n                $html = ($responseCode === 431) ? 'Request header fields too large' : $html;\n                $html = ($responseCode === 451) ? 'Unavailable For Legal Reasons' : $html;\n                $html = ($responseCode === 500) ? 'Internal server error' : $html;\n                $html = ($responseCode === 501) ? 'Not implemented' : $html;\n                $html = ($responseCode === 502) ? 'Bad gateway' : $html;\n                $html = ($responseCode === 503) ? 'Service unavailable' : $html;\n                $html = ($responseCode === 504) ? 'Gateway timeout' : $html;\n                $html = ($responseCode === 505) ? 'HTTP version not supported' : $html;\n                $html = ($responseCode === 506) ? 'Variant also negotiates' : $html;\n                $html = ($responseCode === 507) ? 'Insufficient storage' : $html;\n                $html = ($responseCode === 508) ? 'Loop detected' : $html;\n                $html = ($responseCode === 509) ? 'Bandwidth limit exceeded' : $html;\n                $html = ($responseCode === 510) ? 'Not extended' : $html;\n                $html = ($responseCode === 511) ? 'Network authentication required' : $html;\n\n                return;\n            }\n        }\n\n        $request = new Request();\n\n        if (count($middlewares)) {\n            foreach ($middlewares as $middleware) {\n                call_user_func($middleware);\n            }\n        }\n\n        $page = PageRegistry::read($path);\n        $uid = PageRegistry::read($page);\n\n        $comp = new Component($path, $uid);\n        $comp->render($query, $request);\n    }\n\n    public function doRouting(): ?array\n    {\n        if (!\\Constants::IS_WEB_APP) {\n            return null;\n        }\n\n        $routes = require RouteRegistry::getMovedPhpFilename();\n        $method = \\Constants::REQUEST_METHOD;\n        $methodRoutes = !isset($routes[$method]) ? null : $routes[$method];\n\n        if (null === $methodRoutes) {\n            return null;\n        }\n\n        $redirect = '';\n        $parameters = [];\n\n        foreach ($methodRoutes as $rule => $settings) {\n            $stuff = (object)$settings;\n            $redirect = $stuff->redirect;\n            $translation = $stuff->translate;\n            $isExact = $stuff->exact;\n            $error = $stuff->error;\n            $middlewares = $stuff->middlewares;\n\n            [$redirect, $parameters, $code] = $this->matchRouteEx($method, $rule, $redirect, $translation, $isExact);\n\n            if ($code !== 200) {\n                continue;\n            }\n\n            break;\n        }\n\n        return [$redirect, $parameters, $error, $code, $middlewares];\n    }\n\n    private function matchRouteEx(\n        string $method,\n        string $rule,\n        string $redirect,\n        string $translation,\n        bool $isExact\n    ): ?array {\n        if ($method !== \\Constants::REQUEST_METHOD) {\n            return [$redirect, [], 401];\n        }\n\n        $prefix = '@';\n        $suffix = '@su';\n\n        if ($isExact) {\n            $prefix = $prefix . '^';\n            $suffix = '$' . $suffix;\n        }\n\n        // \\Constants::REQUEST_URI = \\preg_replace('@' . $rule . '@', $redirect, \\Constants::REQUEST_URI);\n        preg_match($prefix . $rule . $suffix, \\Constants::REQUEST_URI, $matches);\n        $request_uri = !isset($matches[0]) ? '' : $matches[0][0];\n\n\n        if ($request_uri === '') {\n            return [$redirect, [], 404];\n        }\n\n        if ($translation !== '') {\n            $request_uri = preg_replace($prefix . $rule . $suffix, $translation, \\Constants::REQUEST_URI);\n        }\n\n        $baseurl = parse_url(\\Constants::SERVER_HOST . $request_uri);\n\n        $parameters = [];\n\n        if (isset($baseurl['query'])) {\n            parse_str($baseurl['query'], $parameters);\n        }\n\n        return [$redirect, $parameters, 200];\n    }\n\n    public function addRoute(RouteInterface $route): void\n    {\n        $methodRegistry = RouteRegistry::read($route->getMethod()) ?: [];\n        if (array_key_exists($route->getRule(), $methodRegistry)) {\n            $currentRoute = $methodRegistry[$route->getRule()];\n            $middlewares = $currentRoute['middlewares'];\n\n            if (!empty($middlewares)) {\n                $methodRegistry[$route->getRule()] = [\n                    'rule' => $route->getRule(),\n                    'redirect' => $route->getRedirect(),\n                    'normal' => $route->getNormalized(),\n                    'translate' => $route->getTranslation(),\n                    'error' => $route->getError(),\n                    'exact' => $route->isExact(),\n                    'middlewares' => $middlewares,\n                ];\n                RouteRegistry::write($route->getMethod(), $methodRegistry);\n            }\n        }\n\n        if (!array_key_exists($route->getRule(), $methodRegistry)) {\n            $methodRegistry[$route->getRule()] = [\n                'rule' => $route->getRule(),\n                'redirect' => $route->getRedirect(),\n                'normal' => $route->getNormalized(),\n                'translate' => $route->getTranslation(),\n                'error' => $route->getError(),\n                'exact' => $route->isExact(),\n                'middlewares' => $route->getMiddlewares(),\n            ];\n            RouteRegistry::write($route->getMethod(), $methodRegistry);\n        }\n\n\n        if (($error = $route->getError()) !== 0) {\n            HttpErrorRegistry::write($error, $route->getRedirect());\n        }\n    }\n\n    public function saveRoutes(): bool\n    {\n        return RouteRegistry::save() && HttpErrorRegistry::save();\n    }\n\n    public function moveCache(): void\n    {\n        $json = File::safeRead(RouteRegistry::getCacheFilename());\n        $phpRoutes = Text::jsonToPhpReturnedArray($json);\n        File::safeWrite(RouteRegistry::getMovedPhpFilename(), $phpRoutes);\n        rename(RouteRegistry::getCacheFilename(), RouteRegistry::getMovedFilename());\n    }\n\n    public function matchRoute(RouteInterface $route): ?array\n    {\n        return $this->matchRouteEx(\n            $route->getMethod(),\n            $route->getRule(),\n            $route->getRedirect(),\n            $route->getTranslation(),\n            $route->isExact(),\n        );\n    }\n\n    public function purgeCopies(): void\n    {\n        //        File::delTree(\\Constants::COPY_DIR);\n    }\n}"}
{"instruction": "Write an Ephect PHP component", "input": "Based on Ephect source: RouterServiceInterface.php", "output": "<?php\n\nnamespace Ephect\\Modules\\Routing\\Services;\n\nuse Ephect\\Modules\\Routing\\Base\\RouteInterface;\nuse Ephect\\Modules\\Routing\\Entities\\RouteEntity;\n\ninterface RouterServiceInterface\n{\n    public static function findRouteArguments(string $route): ?array;\n\n    public static function findRouteQueryString(string $route): ?string;\n\n    public function findRoute(string &$html): void;\n\n    public function renderRoute(bool $pageFound, string $path, array $query, int $error, int $responseCode, array $middlewares, string &$html): void;\n\n    public function doRouting(): ?array;\n\n    public function addRoute(RouteInterface $route): void;\n\n    public function saveRoutes(): bool;\n\n    public function matchRoute(RouteEntity $route): ?array;\n}"}
{"instruction": "Write an Ephect PHP component", "input": "Based on Ephect source: AjilBuilder.php", "output": "<?php\n\nnamespace Ephect\\JavaScripts\\Builder;\n\nuse Ephect\\Framework\\Modules\\Utils;\nuse Ephect\\Framework\\Utils\\File;\n\nclass AjilBuilder\n{\n    public static function build(): void\n    {\n\n        $common = new Utils(__DIR__);\n        $srcdir = $common->getModuleSrcDir() . 'Assets' . DIRECTORY_SEPARATOR . 'Ajil' . DIRECTORY_SEPARATOR;\n\n        $js_filename = \\Constants::DOCUMENT_ROOT . 'ajil.js';\n\n        $filenames = [\n            'core/main.js',\n            'core/registry.js',\n            'core/object.js',\n            'core/url.js',\n            'rest/rest.js',\n            'web/web_object.js',\n            'web/web_application.js',\n            'mvc/view.js',\n            'mvc/controller.js',\n            'utils/utils.js',\n            'utils/backend.js',\n            'utils/commands.js',\n            'web/ui/plugin.js',\n            'web/ui/plugin/accordion.js',\n            'web/ui/plugin/list.js',\n            'web/ui/plugin/table.js',\n            'bootstrap.js',\n        ];\n\n        $js_content = '';\n\n        foreach ($filenames as $filename) {\n            $js_content .= file_get_contents($srcdir . $filename);\n        }\n\n        File::safeWrite($js_filename, $js_content);\n    }\n}"}
{"instruction": "Write an Ephect domain event", "input": "Based on Ephect source: ResponseEvent.php", "output": "<?php\n\nnamespace Ephect\\Modules\\Http\\Event;\n\nuse Ephect\\Framework\\Event\\Event;\nuse Ephect\\Modules\\Http\\Transport\\Request;\nuse Ephect\\Modules\\Http\\Transport\\Response;\n\nclass ResponseEvent extends Event\n{\n    public function __construct(\n        private readonly Request $request,\n        private readonly Response $response,\n    ) {\n    }\n\n    public function getRequest(): Request\n    {\n        return $this->request;\n    }\n\n    public function getResponse(): Response\n    {\n        return $this->response;\n    }\n}"}
{"instruction": "Write an Ephect domain event", "input": "Based on Ephect source: ResponseEventListenerInterface.php", "output": "<?php\n\nnamespace Ephect\\Modules\\Http\\Event;\n\ninterface ResponseEventListenerInterface\n{\n    public function __invoke(ResponseEvent $event);\n}"}
{"instruction": "Write an Ephect PHP component", "input": "Based on Ephect source: HttpStatusCodeEnum.php", "output": "<?php\n\nnamespace Ephect\\Modules\\Http\\Transport;\n\nenum HttpStatusCodeEnum: int\n{\n    case OK = 200;\n    case TEMPORARY_REDIRECT = 301;\n    case PERMANENT_REDIRECT = 302;\n    case NOT_FOUND = 404;\n    case BAD_REQUEST = 400;\n    case NOT_AUTHORIZED = 401;\n    case FORBIDDEN_ACCESS = 403;\n    case METHOD_NOT_ALLOWED = 405;\n    case SERVER_ERROR = 500;\n\n}"}
{"instruction": "Write an Ephect PHP component", "input": "Based on Ephect source: RedirectResponse.php", "output": "<?php\n\nnamespace Ephect\\Modules\\Http\\Transport;\n\nclass RedirectResponse extends Response\n{\n    public function __construct(string $url)\n    {\n        parent::__construct('', 302, ['location' => $url]);\n    }\n\n    public function send(): void\n    {\n        header($this->buildHeader('location'), true, $this->getStatus());\n        exit();\n    }\n}"}
{"instruction": "Write an Ephect PHP component", "input": "Based on Ephect source: Request.php", "output": "<?php\n\nnamespace Ephect\\Modules\\Http\\Transport;\n\nclass Request implements RequestInfoInterface\n{\n    private RequestInfo $info;\n    public RequestHeaders $headers;\n\n    public function __construct()\n    {\n        $this->info = new RequestInfo();\n        parse_str(\\Constants::QUERY_STRING, $params);\n\n        $this->headers = new RequestHeaders();\n    }\n\n    public function getGetParams(string $param = ''): array|string\n    {\n        return $this->info->getGetParams($param);\n    }\n\n    public function getPostParams(string $param = ''): array|string\n    {\n        return $this->info->getPostParams($param);\n    }\n\n    public function getCookies($name = ''): array|string\n    {\n        return $this->info->getCookies($name);\n    }\n\n    public function getFiles(): array\n    {\n        return $this->info->getFiles();\n    }\n\n    public function getServer(): array\n    {\n        return $this->info->getServer();\n    }\n\n    public function getPathInfo(): string\n    {\n        return $this->info->getPathInfo();\n    }\n\n    public function getMethod(): string\n    {\n        return $this->info->getMethod();\n    }\n\n    public function getBody(): string\n    {\n        return $this->info->getBody();\n    }\n}"}
{"instruction": "Write an Ephect PHP component", "input": "Based on Ephect source: RequestHeaders.php", "output": "<?php\n\nnamespace Ephect\\Modules\\Http\\Transport;\n\nreadonly class RequestHeaders\n{\n    public array $list;\n\n    public function __construct()\n    {\n        $this->list = array_change_key_case(getallheaders(), CASE_LOWER);\n    }\n\n    /**\n     * Search the needle string in headers values using headers key\n     *\n     * @param $needle\n     * @param $key\n     * @return boolean\n     */\n    public function contains($needle, $key): bool\n    {\n        $result = false;\n\n        if (isset($this->list[$key])) {\n            $result = strpos($this->list[$key], $needle) > -1;\n        }\n\n        return $result;\n    }\n}"}
{"instruction": "Write an Ephect PHP component", "input": "Based on Ephect source: RequestInfo.php", "output": "<?php\n\nnamespace Ephect\\Modules\\Http\\Transport;\n\nclass RequestInfo implements RequestInfoInterface\n{\n    private array $getParams;\n    private array $postParams;\n    private array $cookies;\n    private array $files;\n    private array $server;\n    private string $pathInfo;\n    private string $method;\n    private string $body;\n    public function __construct()\n    {\n        $this->getParams = $_GET;\n        $this->postParams = $_POST;\n        $this->cookies = $_COOKIE;\n        $this->files = $_FILES;\n        $this->server = $_SERVER;\n        $this->pathInfo = strtok($this->server['REQUEST_URI'], '?');\n        $this->method = $this->server['REQUEST_METHOD'];\n        $this->body = file_get_contents('php://input');\n    }\n\n    public function getGetParams(string $param = ''): array|string\n    {\n        if ($param == '') {\n            return $this->getParams;\n        }\n\n        return !isset($this->getParams[$param]) ? '' : $this->getParams[$param];\n    }\n\n    public function getPostParams(string $param = ''): array|string\n    {\n        if ($param == '') {\n            return $this->postParams;\n        }\n\n        return !isset($this->postParams[$param]) ? '' : $this->postParams[$param];\n    }\n\n    public function getCookies($name = ''): array|string\n    {\n        if ($name == '') {\n            return $this->cookies;\n        }\n\n        return !isset($this->cookies[$name]) ? '' : $this->cookies[$name];\n    }\n\n    public function getFiles(): array\n    {\n        return $this->files;\n    }\n\n    public function getServer(): array\n    {\n        return $this->server;\n    }\n\n    public function getPathInfo(): string\n    {\n        return $this->pathInfo;\n    }\n\n    public function getMethod(): string\n    {\n        return $this->method;\n    }\n\n    public function getBody(): string\n    {\n        return $this->body;\n    }\n}"}
{"instruction": "Write an Ephect PHP component", "input": "Based on Ephect source: RequestInfoInterface.php", "output": "<?php\n\nnamespace Ephect\\Modules\\Http\\Transport;\n\ninterface RequestInfoInterface\n{\n    public function getGetParams(string $param = ''): array|string;\n\n    public function getPostParams(string $param = ''): array|string;\n\n    public function getCookies($name = ''): array|string;\n\n    public function getFiles(): array;\n\n    public function getServer(): array;\n\n    public function getPathInfo(): string;\n\n    public function getMethod(): string;\n\n    public function getBody(): string;\n}"}
{"instruction": "Write an Ephect PHP component", "input": "Based on Ephect source: Response.php", "output": "<?php\n\nnamespace Ephect\\Modules\\Http\\Transport;\n\nclass Response\n{\n    public function __construct(\n        private ?string $content = '',\n        private HttpStatusCodeEnum|int $status = 200,\n        private array $headers = [],\n    ) {\n    }\n\n    public function getContent(): string\n    {\n        return $this->content;\n    }\n\n    public function setContent(string $content): void\n    {\n        $this->content = $content;\n    }\n\n    public function getStatus(): int|HttpStatusCodeEnum\n    {\n        $status = $this->status;\n        if ($this->status instanceof HttpStatusCodeEnum) {\n            $status = $this->status->value;\n        }\n        return $status;\n    }\n\n    public function setStatus(int|HttpStatusCodeEnum $status): void\n    {\n        $this->status = $status;\n    }\n\n    public function send(): void\n    {\n        ob_start();\n\n        foreach ($this->buildHeaders() as $header) {\n            header($header);\n        }\n\n        echo $this->content;\n\n        ob_end_flush();\n    }\n\n    protected function buildHeaders(): array\n    {\n        $result = [];\n        foreach ($this->headers as $key => $value) {\n            $result[] = \"$key: \" . $value;\n        }\n\n        return $result;\n    }\n\n    public function getHeaders(): array\n    {\n        return $this->headers;\n    }\n\n    public function setHeaders(string $key, mixed $value): void\n    {\n        $this->headers[$key] = $value;\n    }\n\n    /**\n     * @throws Exception\n     */\n    protected function buildHeader(string $header): string\n    {\n        $result = '';\n        foreach ($this->headers as $key => $value) {\n            if ($key == $header) {\n                $result = \"$key: \" . $value;\n                break;\n            }\n        }\n\n        if ($result == '') {\n            throw new Exception('Header not found!');\n        }\n\n        return $result;\n    }\n}"}
{"instruction": "Write an Ephect component", "input": "Based on Ephect source: AbstractApplicationParser.php", "output": "<?php\n\nnamespace Ephect\\Modules\\Forms\\Application;\n\nuse Ephect\\Modules\\Forms\\Components\\Component;\nuse Ephect\\Modules\\Forms\\Components\\FileComponentInterface;\nuse Ephect\\Modules\\Forms\\Registry\\CodeRegistry;\nuse Ephect\\Modules\\Forms\\Generators\\ComponentParser;\n\nabstract class AbstractApplicationParser\n{\n    use ComponentCodeTrait;\n\n    /**\n     * @return void\n     */\n    abstract protected function __parse(FileComponentInterface $component): void;\n\n    public function updateComponent(FileComponentInterface $component): string\n    {\n        $uid = $component->getUID();\n        $motherUID = $component->getMotherUID();\n        $filename = $component->getSourceFilename();\n\n        $comp = new Component($uid, $motherUID);\n        $comp->load($filename);\n        $parser = new ComponentParser($comp);\n        $struct = $parser->doDeclaration($uid);\n        $decl = $struct->toArray();\n\n        CodeRegistry::write($comp->getFullyQualifiedFunction(), $decl);\n        CodeRegistry::save();\n\n        return $filename;\n    }\n}"}
{"instruction": "Write an Ephect component", "input": "Based on Ephect source: ApplicationComponent.php", "output": "<?php\n\nnamespace Ephect\\Modules\\Forms\\Application;\n\nuse Ephect\\Framework\\ElementTrait;\nuse Ephect\\Framework\\ElementUtils;\nuse Ephect\\Framework\\Event\\EventDispatcher;\nuse Ephect\\Framework\\Registry\\StateRegistry;\nuse Ephect\\Framework\\Tree\\Tree;\nuse Ephect\\Framework\\Utils\\File;\nuse Ephect\\Framework\\Web\\ApplicationIgniter;\nuse Ephect\\Modules\\Forms\\Components\\ComponentDeclaration;\nuse Ephect\\Modules\\Forms\\Components\\ComponentEntity;\nuse Ephect\\Modules\\Forms\\Components\\ComponentEntityInterface;\nuse Ephect\\Modules\\Forms\\Components\\ComponentFactory;\nuse Ephect\\Modules\\Forms\\Components\\ComponentInterface;\nuse Ephect\\Modules\\Forms\\Components\\FileComponentInterface;\nuse Ephect\\Modules\\Forms\\Events\\ComponentFinishedEvent;\nuse Ephect\\Modules\\Forms\\Registry\\CacheRegistry;\nuse Ephect\\Modules\\Forms\\Registry\\CodeRegistry;\nuse Ephect\\Modules\\Forms\\Registry\\ComponentRegistry;\nuse Ephect\\Modules\\Http\\Transport\\Request;\nuse Exception;\nuse Ephect\\Modules\\Forms\\Generators\\ParserService;\nuse ReflectionException;\n\nabstract class ApplicationComponent extends Tree implements FileComponentInterface\n{\n    use ElementTrait;\n    use ComponentCodeTrait;\n\n    public const INCLUDE_PLACEHOLDER = \"include_once \\Constants::BUILD_DIR . '%s';\";\n\n    protected ?ComponentDeclaration $declaration = null;\n    protected ?ComponentEntity $entity = null;\n\n    public function __construct(?string $id = null, ?string $motherUID = null)\n    {\n        parent::__construct([]);\n\n        $this->id = $id ?: '';\n        if ($id === null) {\n            $this->getUID();\n            $this->motherUID = $motherUID ?? $this->uid;\n\n            return;\n        }\n\n        ComponentRegistry::load();\n        $this->class = ComponentRegistry::read($id);\n        if ($this->class !== null) {\n            $this->filename = ComponentRegistry::read($this->class);\n            $this->filename = $this->filename ?: '';\n\n            $this->uid = ComponentRegistry::read($this->filename);\n            $this->uid = $this->uid ?: '';\n        }\n\n        if ($this->uid !== $this->id) {\n            $this->function = $id;\n        }\n        if ($this->uid === $this->id) {\n            $this->function = self::functionName($this->class);\n        }\n\n        $this->motherUID = $motherUID ?? $this->uid;\n    }\n\n    public function load(?string $filename = null): bool\n    {\n        $filename = $filename ?: '';\n        $this->filename = ($filename !== '') ? $filename : $this->filename;\n\n        if ($this->filename === '') {\n            return false;\n        }\n\n        if (file_exists($this->filename)) {\n            $this->code = File::safeRead($this->filename);\n        } else {\n            $this->code = File::safeRead(\\Constants::BUILD_DIR . $this->motherUID . DIRECTORY_SEPARATOR . $this->filename);\n            if ($this->code === null) {\n                $this->code = File::safeRead(\\Constants::COPY_DIR . $this->filename);\n            }\n        }\n\n        [\n            $this->namespace,\n            $this->function,\n            $parameters,\n            $returnedType,\n            $this->bodyStartsAt\n        ] = ElementUtils::getFunctionDefinition($this->code);\n        if ($this->bodyStartsAt == -1 && !empty($this->code)) {\n            $this->makeComponent($this->filename, $this->code);\n            [\n                $this->namespace,\n                $this->function,\n                $parameters,\n                $returnedType,\n                $this->bodyStartsAt\n            ] = ElementUtils::getFunctionDefinition($this->code);\n        }\n\n        return $this->code !== null;\n    }\n\n    abstract public function makeComponent(string $filename, string &$html): void;\n\n    public static function createByHtml(string $html): static\n    {\n        $new = new static();\n        $new->code = $html;\n\n        return $new;\n    }\n\n    /**\n     * @throws Exception\n     */\n    public function getEntity(): ?ComponentEntity\n    {\n        if ($this->entity === null) {\n            $this->setEntity();\n        }\n\n        return $this->entity;\n    }\n\n    /**\n     * @throws Exception\n     */\n    protected function setEntity(): void\n    {\n        $decl = $this->getDeclaration();\n        $this->entity = $decl->getComposition();\n    }\n\n    public function getFunction(): ?string\n    {\n        return $this->function;\n    }\n\n    /**\n     * @throws Exception\n     */\n    public function getDeclaration(): ?ComponentDeclaration\n    {\n        if ($this->declaration === null) {\n            $this->setDeclaration();\n        }\n\n        return $this->declaration;\n    }\n\n    /**\n     * @throws Exception\n     */\n    protected function setDeclaration(): void\n    {\n        $fqName = ComponentRegistry::read($this->uid);\n\n        if ($fqName === null) {\n            $fqName = $this->getFullyQualifiedFunction();\n            if ($fqName === null) {\n                throw new Exception('Please the component is defined in the registry before asking for its entity');\n            }\n        }\n        CodeRegistry::setCacheDirectory(\\Constants::BUILD_DIR . $this->getMotherUID());\n\n        $decl = ComponentDeclaration::byName($fqName);\n\n        $this->declaration = $decl;\n    }\n\n    public function resetDeclaration(): void\n    {\n        $this->declaration = null;\n    }\n\n    public function composedOfUnique(): ?array\n    {\n        $result = $this->composedOf();\n\n        if ($result === null) {\n            return null;\n        }\n\n        return array_unique($result);\n    }\n\n    public function composedOf(): ?array\n    {\n        $names = [];\n\n        $this->forEach(function (ComponentEntityInterface $item, $key) use (&$names) {\n            $names[] = $item;\n        }, $this);\n\n        $names = array_filter($names, function ($item) {\n            return $item !== null;\n        });\n\n        if (count($names) === 0) {\n            $names = null;\n        }\n\n        return $names;\n    }\n\n    public function analyse(): void\n    {\n        $parser = new ParserService();\n        $parser->doUses($this);\n        $parser->doUsesAs($this);\n        $parser->doAttributes($this);\n    }\n\n    /**\n     * @throws ReflectionException\n     */\n    public function render(array|object|null $functionArgs = null, ?Request $request = null): void\n    {\n        if ($this->motherUID == $this->uid && $this->id !== 'App') {\n            StateRegistry::loadByMotherUid($this->motherUID, true);\n            //            StateRegistry::load(true);\n            $stateIgniter = new ApplicationIgniter();\n            $stateIgniter->ignite();\n        }\n\n        //        $trueStaticFile = STATIC_DIR . pathinfo($this->filename, PATHINFO_FILENAME) . PREHTML_EXTENSION;\n        //        if ($html = File::safeRead($trueStaticFile) != null && $this->motherUID == $this->uid && $this->id !== 'App')  {\n        //            echo $html;\n        //            return;\n        //        }\n\n        [$fqFunctionName, $cacheFilename] = $this->renderComponent($this->motherUID, $this->function, $functionArgs);\n        $html = ComponentRenderer::renderHTML(\n            $this->motherUID,\n            $cacheFilename,\n            $fqFunctionName,\n            $functionArgs,\n            $request\n        );\n        if ($this->motherUID == $this->uid && $this->id !== 'App') {\n            File::safeWrite(\\Constants::STATIC_DIR . $this->filename, $html);\n        }\n        echo $html;\n    }\n\n    public function renderComponent(\n        string $motherUID,\n        string $functionName,\n        array|object|null $functionArgs = null\n    ): array {\n        [$fqFunctionName, $cacheFilename, $isCached] = ComponentFinder::find($functionName, $motherUID);\n\n        if ($isCached) {\n            return [$fqFunctionName, $cacheFilename];\n        }\n\n        ComponentRegistry::load();\n\n        $fqName = ComponentRegistry::read($functionName);\n        $component = ComponentFactory::create($fqName, $motherUID);\n        $component->parse();\n\n        $motherUID = $component->getMotherUID();\n        $cacheFilename = $motherUID . DIRECTORY_SEPARATOR . $component->getSourceFilename();\n\n        if ($motherUID !== $component->getUID()) {\n            $finishedEvent = new ComponentFinishedEvent($component, $cacheFilename);\n            $dispatcher = new EventDispatcher();\n            $dispatcher->dispatch($finishedEvent);\n        }\n\n        return [$fqFunctionName, $cacheFilename];\n    }\n\n    public function parse(): void\n    {\n        ApplicationRecursiveParser::parse($this);\n    }\n\n    public function getSourceFilename(): string\n    {\n        return $this->filename;\n    }\n\n    public function getStandardFilename(): string\n    {\n        return str_replace(pathinfo($this->filename, PATHINFO_EXTENSION), 'php', $this->filename);\n    }\n\n    public function getFlattenSourceFilename(): string\n    {\n        return static::getFlatFilename($this->filename);\n    }\n\n    public static function getFlatFilename(string $basename): string\n    {\n        return str_replace('/', '_', $basename);\n    }\n\n    public function getFlattenFilename(): string\n    {\n        return static::getFlatFilename($this->filename);\n    }\n\n    public function copyComponents(\n        array &$list,\n        ?string $motherUID = null,\n        ?ComponentInterface $component = null\n    ): ?string {\n        if ($component === null) {\n            $component = $this;\n            $motherUID = $component->getUID();\n            if (!file_exists(\\Constants::BUILD_DIR . $motherUID)) {\n                mkdir(\\Constants::BUILD_DIR . $motherUID, 0775);\n\n                $flatFilename = CodeRegistry::getFlatFilename() . '.json';\n                copy(\n                    \\Constants::BUILD_DIR . $flatFilename,\n                    \\Constants::BUILD_DIR . $motherUID . DIRECTORY_SEPARATOR . $flatFilename\n                );\n            }\n        }\n\n        return ComponentsCopier::copy($list, $motherUID, $component);\n    }\n\n    protected function cacheHtml(): ?string\n    {\n        return $this->cacheFile(\\Constants::BUILD_DIR);\n    }\n\n    private function cacheFile($cacheDir): ?string\n    {\n        $cache_file = $this->getSourceFilename();\n        $result = File::safeWrite($cacheDir . $this->motherUID . DIRECTORY_SEPARATOR . $cache_file, $this->code);\n\n        $cache = (($cache = CacheRegistry::read($this->motherUID)) === null) ? [] : $cache;\n\n        $cache[$this->getFullyQualifiedFunction()] = $this->getSourceFilename();\n        CacheRegistry::write($this->motherUID, $cache);\n        CacheRegistry::save();\n\n        return $result === null ? $result : $cache_file;\n    }\n\n    public function getFullyQualifiedFunction(): ?string\n    {\n        return $this->namespace . '\\\\' . $this->function;\n    }\n\n    protected function cacheJavascript(): ?string\n    {\n        return $this->cacheFile(\\Constants::RUNTIME_JS_DIR);\n    }\n\n    public function findDependencies(array &$list, ?string $motherUID = null, ?ComponentInterface $component = null): ?array\n    {\n        $composition = $this->composedOf();\n        if ($composition === null) {\n            return null;\n        }\n\n        $list = array_map(function ($item) {\n            return $item->getFullyQualifiedFunction();\n        }, $composition);\n\n        return $list[0] ?? null;\n    }\n}"}
{"instruction": "Write an Ephect component", "input": "Based on Ephect source: ApplicationPreParser.php", "output": "<?php\n\nnamespace Ephect\\Modules\\Forms\\Application;\n\nuse Ephect\\Framework\\Utils\\File;\nuse Ephect\\Modules\\Forms\\Components\\FileComponentInterface;\nuse Ephect\\Modules\\Forms\\Registry\\CodeRegistry;\nuse Ephect\\Modules\\Forms\\Generators\\ParserService;\n\nclass ApplicationPreParser extends AbstractApplicationParser\n{\n    public static function parse(FileComponentInterface $component): void\n    {\n        $parser = new ApplicationPreParser();\n        $parser->__parse($component);\n    }\n\n    /**\n     * @return void\n     */\n    protected function __parse(FileComponentInterface $component): void\n    {\n        CodeRegistry::setCacheDirectory(\\Constants::BUILD_DIR . $component->getMotherUID());\n        CodeRegistry::load();\n\n        $parser = new ParserService();\n\n        $parser->doAttributes($component);\n\n        //        $parser->doUses($component);\n        $parser->doUsesAs($component);\n\n        $parser->doHeredoc($component);\n        $component->applyCode($parser->getHtml());\n\n        $parser->doInlineCode($component);\n        $component->applyCode($parser->getHtml());\n\n        $parser->doChildrenDeclaration($component);\n\n        $parser->doArrays($component);\n        $component->applyCode($parser->getHtml());\n\n        $parser->doUseEffect($component);\n        $component->applyCode($parser->getHtml());\n\n        $parser->doReturnType($component);\n        $component->applyCode($parser->getHtml());\n\n        $parser->doModuleComponent($component);\n\n        $parser->doUseVariables($component);\n        $component->applyCode($parser->getHtml());\n\n        $parser->doNamespace($component);\n        $component->applyCode($parser->getHtml());\n\n        $parser->doFragments($component);\n        $component->applyCode($parser->getHtml());\n\n        $filename = $component->getSourceFilename();\n        File::safeWrite(\n            \\Constants::COPY_DIR . $filename,\n            $component->getCode()\n        );\n        $this->updateComponent($component);\n\n        CodeRegistry::save();\n    }\n}"}
{"instruction": "Write an Ephect component", "input": "Based on Ephect source: ApplicationRecursiveParser.php", "output": "<?php\n\nnamespace Ephect\\Modules\\Forms\\Application;\n\nuse Ephect\\Framework\\Utils\\File;\nuse Ephect\\Modules\\Forms\\Components\\FileComponentInterface;\nuse Ephect\\Modules\\Forms\\Registry\\CodeRegistry;\nuse Ephect\\Modules\\Forms\\Generators\\ParserService;\n\nclass ApplicationRecursiveParser extends AbstractApplicationParser\n{\n    use ComponentCodeTrait;\n\n    public static function parse(FileComponentInterface $component): void\n    {\n        $parser = new self();\n        $parser->__parse($component);\n    }\n\n    /**\n     * @param FileComponentInterface $component\n     * @return void\n     */\n    protected function __parse(FileComponentInterface $component): void\n    {\n        CodeRegistry::setCacheDirectory(\\Constants::BUILD_DIR . $component->getMotherUID());\n        CodeRegistry::load();\n\n        $parser = new ParserService();\n\n        $parser->doAttributes($component);\n\n        $parser->doUses($component);\n        $parser->doUsesAs($component);\n\n        $parser->doHeredoc($component);\n        $component->applyCode($parser->getHtml());\n\n        $parser->doInlineCode($component);\n        $component->applyCode($parser->getHtml());\n\n        $parser->doChildrenDeclaration($component);\n\n        $parser->doArrays($component);\n        $component->applyCode($parser->getHtml());\n\n        $parser->doUseEffect($component);\n        $component->applyCode($parser->getHtml());\n\n        $parser->doReturnType($component);\n        $component->applyCode($parser->getHtml());\n\n        $parser->doModuleComponent($component);\n\n        $parser->doUseVariables($component);\n        $component->applyCode($parser->getHtml());\n\n        $parser->doNamespace($component);\n        $component->applyCode($parser->getHtml());\n\n        $parser->doFragments($component);\n        $component->applyCode($parser->getHtml());\n\n        $filename = $component->getSourceFilename();\n        File::safeWrite(\n            \\Constants::BUILD_DIR . $component->getMotherUID() . DIRECTORY_SEPARATOR . $filename,\n            $component->getCode()\n        );\n        $this->updateComponent($component);\n\n        $parser->doChildSlots($component);\n        $component->applyCode($parser->getHtml());\n        $this->updateComponent($component);\n\n        while ($component->getDeclaration()?->getComposition() !== null) {\n            $parser->doOpenComponents($component);\n            $component->applyCode($parser->getHtml());\n            $this->updateComponent($component);\n\n            $parser->doClosedComponents($component);\n            $component->applyCode($parser->getHtml());\n            $this->updateComponent($component);\n\n            $parser->doIncludes($component);\n            $component->applyCode($parser->getHtml());\n        }\n\n        CodeRegistry::save();\n    }\n}"}
{"instruction": "Write an Ephect component", "input": "Based on Ephect source: ComponentCodeTrait.php", "output": "<?php\n\nnamespace Ephect\\Modules\\Forms\\Application;\n\ntrait ComponentCodeTrait\n{\n    protected ?string $filename = '';\n    protected ?string $code = '';\n    protected int $bodyStartsAt = 0;\n\n    public function getCode(): ?string\n    {\n        return $this->code;\n    }\n\n    public function applyCode(string $code): void\n    {\n        $this->code = $code;\n    }\n\n    public function getBodyStart(): int\n    {\n        return $this->bodyStartsAt;\n    }\n}"}
{"instruction": "Write an Ephect component", "input": "Based on Ephect source: ComponentDependencyFinder.php", "output": "<?php\n\nnamespace Ephect\\Modules\\Forms\\Application;\n\nuse Ephect\\Framework\\Utils\\File;\nuse Ephect\\Modules\\Forms\\Components\\FileComponentInterface;\nuse Ephect\\Modules\\Forms\\Registry\\ComponentRegistry;\nuse Ephect\\Modules\\Forms\\Registry\\PluginRegistry;\n\nclass ComponentDependencyFinder\n{\n    public static function find(array &$list, ?string $motherUID = null, ?FileComponentInterface $component = null): ?string\n    {\n        $cachedir = \\Constants::BUILD_DIR . $motherUID . DIRECTORY_SEPARATOR;\n        $componentList = $component->composedOf();\n        $copyFile = $component->getSourceFilename();\n        $copyPath = pathinfo($copyFile, PATHINFO_DIRNAME);\n\n        File::safeMkDir($cachedir . $copyPath);\n\n        if ($componentList === null) {\n            if (!file_exists($cachedir . $copyFile)) {\n                copy(\\Constants::COPY_DIR . $copyFile, $cachedir . $copyFile);\n            }\n\n            return $copyFile;\n        }\n\n        $fqFuncName = $component->getFullyQualifiedFunction();\n        foreach ($componentList as $entity) {\n            $funcName = $entity->getName();\n            $fqFuncName = ComponentRegistry::read($funcName);\n\n            if ($fqFuncName === null) {\n                continue;\n            }\n            $nextComponent = !isset($list[$fqFuncName]) ? null : $list[$fqFuncName];\n\n            $nextCopyFile = '';\n            if ($nextComponent !== null) {\n                $nextCopyFile = $nextComponent->getSourceFilename();\n            }\n\n            if ($nextComponent === null) {\n                $nextCopyFile = PluginRegistry::read($fqFuncName);\n            }\n            if (file_exists($cachedir . $nextCopyFile)) {\n                continue;\n            }\n\n            if ($nextComponent === null) {\n                continue;\n            }\n            $component->findDependencies($list, $motherUID, $nextComponent);\n        }\n\n        return $copyFile;\n    }\n}"}
{"instruction": "Write an Ephect component", "input": "Based on Ephect source: ComponentFinder.php", "output": "<?php\n\nnamespace Ephect\\Modules\\Forms\\Application;\n\nuse BadFunctionCallException;\nuse Ephect\\Modules\\Forms\\Registry\\CacheRegistry;\nuse Ephect\\Modules\\Forms\\Registry\\ComponentRegistry;\n\nclass ComponentFinder\n{\n    public static function find(string $componentName, string $motherUID): array\n    {\n        ComponentRegistry::load();\n        $uses = ComponentRegistry::items();\n        $fqFuncName = $uses[$componentName] ?? null;\n\n        if ($fqFuncName === null) {\n            throw new BadFunctionCallException('The component ' . $componentName . ' does not exist.');\n        }\n\n        CacheRegistry::load();\n\n        if ($motherUID === '') {\n            $filename = $uses[$fqFuncName];\n            $motherUID = $uses[$filename];\n        }\n        $filename = CacheRegistry::read($motherUID, $fqFuncName);\n        $filename = ($filename !== null) ? $motherUID . DIRECTORY_SEPARATOR . $filename : $filename;\n        $isCached = $filename !== null;\n\n        return [$fqFuncName, $filename, $isCached];\n    }\n}"}
{"instruction": "Write an Ephect component", "input": "Based on Ephect source: ComponentRenderer.php", "output": "<?php\n\nnamespace Ephect\\Modules\\Forms\\Application;\n\nuse Ephect\\Framework\\Event\\EventDispatcher;\nuse Ephect\\Modules\\Forms\\Events\\PageFinishedEvent;\nuse Ephect\\Modules\\Http\\Transport\\Request;\nuse ReflectionFunction;\nuse stdClass;\n\nclass ComponentRenderer\n{\n    /**\n     * @throws \\ReflectionException\n     */\n    public static function renderHTML(\n        string $motherUID,\n        string $cacheFilename,\n        string $fqFunctionName,\n        array|object|null $functionArgs = null,\n        ?Request $request = null\n    ): string {\n        $props = new stdClass();\n        include_once \\Constants::BUILD_DIR . $cacheFilename;\n\n        $funcReflection = new ReflectionFunction($fqFunctionName);\n        $funcParams = $funcReflection->getParameters();\n\n        $bodyProps = null;\n        if ($request !== null && $request->headers->contains('application/json', 'content-type')) {\n            $bodyProps = json_decode($request->getBody());\n        }\n\n        $html = '';\n\n        if ($funcParams === [] && $bodyProps === null) {\n            ob_start();\n            $fn = call_user_func($fqFunctionName);\n            $fn();\n            $html = ob_get_clean();\n        } else {\n            $props = null;\n            if (count($functionArgs) > 0) {\n                $props = (object)$functionArgs;\n            }\n\n            if ($bodyProps !== null) {\n                if ($props === null) {\n                    $props = new stdClass();\n                }\n                foreach ($bodyProps as $field => $value) {\n                    $props->{$field} = $value;\n                }\n            }\n\n            ob_start();\n            $fn = call_user_func($fqFunctionName, $props);\n            $fn();\n            $html = ob_get_clean();\n        }\n\n        $finishedEvent = new PageFinishedEvent($motherUID, $cacheFilename, $fqFunctionName, $props);\n        $dispatcher = new EventDispatcher();\n        $dispatcher->dispatch($finishedEvent);\n\n        return $html;\n    }\n}"}
{"instruction": "Write an Ephect component", "input": "Based on Ephect source: ComponentsCopier.php", "output": "<?php\n\nnamespace Ephect\\Modules\\Forms\\Application;\n\nuse Ephect\\Framework\\Utils\\File;\nuse Ephect\\Modules\\Forms\\Components\\FileComponentInterface;\nuse Ephect\\Modules\\Forms\\Registry\\ComponentRegistry;\nuse Ephect\\Modules\\Forms\\Registry\\PluginRegistry;\n\nclass ComponentsCopier\n{\n    public static function copy(array &$list, ?string $motherUID = null, ?FileComponentInterface $component = null): ?string\n    {\n        $cachedir = \\Constants::BUILD_DIR . $motherUID . DIRECTORY_SEPARATOR;\n        $componentList = $component->composedOf();\n        $copyFile = $component->getSourceFilename();\n        $copyPath = pathinfo($copyFile, PATHINFO_DIRNAME);\n\n        File::safeMkDir($cachedir . $copyPath);\n\n        if ($componentList === null) {\n            if (!file_exists($cachedir . $copyFile)) {\n                copy(\\Constants::COPY_DIR . $copyFile, $cachedir . $copyFile);\n            }\n\n            return $copyFile;\n        }\n\n        $fqFuncName = $component->getFullyQualifiedFunction();\n        foreach ($componentList as $entity) {\n            $funcName = $entity->getName();\n            $fqFuncName = ComponentRegistry::read($funcName);\n\n            if ($fqFuncName === null) {\n                continue;\n            }\n            $nextComponent = !isset($list[$fqFuncName]) ? null : $list[$fqFuncName];\n\n            $nextCopyFile = '';\n            if ($nextComponent !== null) {\n                $nextCopyFile = $nextComponent->getSourceFilename();\n            }\n\n            if ($nextComponent === null) {\n                $nextCopyFile = PluginRegistry::read($fqFuncName);\n            }\n            if (file_exists($cachedir . $nextCopyFile)) {\n                continue;\n            }\n\n            if ($nextComponent === null) {\n                continue;\n            }\n            $component->copyComponents($list, $motherUID, $nextComponent);\n        }\n\n        if (!file_exists($cachedir . $copyFile)) {\n            copy(\\Constants::COPY_DIR . $copyFile, $cachedir . $copyFile);\n        }\n\n        return $copyFile;\n    }\n}"}
{"instruction": "Write an Ephect PHP component", "input": "Based on Ephect source: AbstractBuilder.php", "output": "<?php\n\nnamespace Ephect\\Modules\\Forms\\Builders;\n\nuse Ephect\\Framework\\ElementInterface;\nuse ErrorException;\nuse Ephect\\Modules\\Forms\\Validators\\PropsValidator;\n\nabstract class AbstractBuilder\n{\n    protected object $props;\n    protected string $struct;\n\n    public function __construct(object $props, string $struct)\n    {\n        $this->props = $props;\n        $this->struct = $struct;\n    }\n\n    /**\n     * @throws ErrorException\n     */\n    protected function buildEx(string $class): ElementInterface\n    {\n        $struct = (new PropsValidator($this->props, $this->struct))->validate();\n\n        return new $class($struct);\n    }\n\n}"}
{"instruction": "Write an Ephect component", "input": "Based on Ephect source: Children.php", "output": "<?php\n\nnamespace Ephect\\Modules\\Forms\\Components;\n\nuse Ephect\\Framework\\ElementTrait;\nuse Ephect\\Framework\\Entity\\Entity;\nuse Ephect\\Framework\\Tree\\TreeTrait;\n\nclass Children extends Entity implements ChildrenInterface\n{\n    use ElementTrait;\n    use TreeTrait;\n\n    protected ?object $props = null;\n    protected array|object|null $parentProps = null;\n    protected array|object|null $allProps = null;\n    protected $buffer = null;\n\n    protected ?string $name = null;\n\n    public function __construct(ChildrenStructure $struct)\n    {\n        parent::__construct($struct);\n\n        $this->uid = $struct->uid;\n        $this->motherUID = $struct->motherUID;\n        $this->props = $struct->props;\n        $this->parentProps = $struct->parentProps;\n        $this->name = $struct->name;\n        $this->class = $struct->class;\n        $this->buffer = $struct->buffer;\n    }\n\n    public function getName(): string\n    {\n        return $this->name;\n    }\n\n    public function props(): array|object\n    {\n        return $this->props;\n    }\n\n    public function buffer(): callable\n    {\n        return $this->buffer;\n    }\n\n    public function getBuffer(): string\n    {\n        ob_start();\n        $fn = $this->buffer;\n        call_user_func($fn);\n        return ob_get_clean();\n    }\n\n    public function render(): void\n    {\n        $fn = $this->buffer;\n        call_user_func($fn);\n    }\n\n    public function getAttributes(): string\n    {\n        $props = $this->props->props ?? $this->props;\n\n        $args = [];\n        foreach ($props as $key => $value) {\n            $args[] = $key . '=\"' . $value . '\"';\n        }\n\n        return implode(\" \", $args);\n\n    }\n\n    public function getAttribute(string $attribute): string|bool|null\n    {\n        $props = $this->getAllProps();\n        $value = $props->$attribute ?? null;\n\n        if ($value === 'false') {\n            $value = false;\n        }\n        if ($value === 'true') {\n            $value = true;\n        }\n        return $value;\n    }\n\n    public function getAllProps(): array|object\n    {\n        $parentProps = $this->parentProps();\n        $props = $this->props;\n\n        $parentProps = json_encode($parentProps);\n        $props = json_encode($props);\n\n        $parentProps = json_decode($parentProps, JSON_OBJECT_AS_ARRAY);\n        $props = json_decode($props, JSON_OBJECT_AS_ARRAY);\n\n        $allProps = array_merge(\n            $parentProps,\n            $props\n        );\n\n        return (object)$allProps;\n    }\n\n    public function parentProps(): array|object\n    {\n        if ($this->parentProps === null && isset($this->props->props)) {\n            $this->parentProps = $this->props->props;\n        }\n\n        return $this->parentProps;\n    }\n\n}"}
{"instruction": "Write an Ephect component", "input": "Based on Ephect source: ChildrenInterface.php", "output": "<?php\n\nnamespace Ephect\\Modules\\Forms\\Components;\n\nuse Ephect\\Framework\\ElementInterface;\nuse Ephect\\Framework\\Tree\\TreeInterface;\n\ninterface ChildrenInterface extends TreeInterface, ElementInterface\n{\n    public function getAttributes(): string;\n\n    public function getAttribute(string $attribute): string|bool|null;\n\n    public function parentProps(): array|object;\n\n    public function props(): array|object;\n\n    public function getAllProps(): array|object;\n\n    public function render(): void;\n\n    public function getName(): string;\n}"}
{"instruction": "Write an Ephect component", "input": "Based on Ephect source: ChildrenStructure.php", "output": "<?php\n\nnamespace Ephect\\Modules\\Forms\\Components;\n\nuse Ephect\\Framework\\Structure\\Structure;\n\nclass ChildrenStructure extends Structure\n{\n    public string $uid = '';\n    public ?object $props = null;\n    public string $class = '';\n    public string $name = '';\n    public ?array $parentProps = null;\n    public string $motherUID = '';\n    public ?object $buffer = null;\n}"}
{"instruction": "Write an Ephect component", "input": "Based on Ephect source: Component.php", "output": "<?php\n\nnamespace Ephect\\Modules\\Forms\\Components;\n\nuse Ephect\\Framework\\Utils\\File;\nuse Ephect\\Modules\\Forms\\Application\\ApplicationComponent;\nuse Ephect\\Modules\\Forms\\Registry\\ComponentRegistry;\n\nclass Component extends ApplicationComponent implements FileComponentInterface\n{\n    public function makeComponent(string $filename, string &$html): void\n    {\n        $info = (object)pathinfo($filename);\n        $namespace = \\Constants::CONFIG_NAMESPACE;\n        $function = $info->filename;\n\n        $html = <<< COMPONENT\n        <?php\n\n        namespace $namespace;\n\n        function $function(): string\n        {\n        return (<<< HTML\n        $html\n        HTML);\n        }\n        COMPONENT;\n\n        File::safeWrite(\\Constants::COPY_DIR . $filename, $html);\n    }\n\n    public function parse(): void\n    {\n        parent::parse();\n\n        $this->cacheHtml();\n    }\n\n    public function analyse(): void\n    {\n        parent::analyse();\n\n        ComponentRegistry::write($this->getFullyQualifiedFunction(), $this->getSourceFilename());\n        ComponentRegistry::safeWrite($this->getFunction(), $this->getFullyQualifiedFunction());\n    }\n}"}
{"instruction": "Write an Ephect component", "input": "Based on Ephect source: ComponentDeclaration.php", "output": "<?php\n\nnamespace Ephect\\Modules\\Forms\\Components;\n\nuse Ephect\\Framework\\Element;\nuse Ephect\\Modules\\Forms\\Registry\\CodeRegistry;\n\nclass ComponentDeclaration extends Element implements ComponentDeclarationInterface\n{\n    protected mixed $type = '';\n    protected string $name = '';\n    protected ?ComponentEntity $entity = null;\n    protected mixed $arguments = [];\n    protected mixed $attributes = [];\n    protected mixed $flatComposition = [];\n\n    public function __construct(ComponentDeclarationStructure $struct)\n    {\n        parent::__construct($this);\n\n        $this->uid = $struct->uid;\n        $this->type = $struct->type;\n        $this->arguments = $struct->arguments;\n        $this->attributes = $struct->attributes;\n        $this->flatComposition = $struct->composition;\n    }\n\n    public static function byName(string $componentName): ComponentDeclaration\n    {\n        $list = CodeRegistry::read($componentName);\n        $struct = new ComponentDeclarationStructure($list);\n        return new static($struct);\n    }\n\n    public function getType(): string\n    {\n        return $this->type;\n    }\n\n    public function getName(): string\n    {\n        return $this->name;\n    }\n\n    public function hasArguments(): bool\n    {\n        return $this->attributes !== null && count($this->arguments) > 0;\n    }\n\n    public function getArguments(): ?array\n    {\n        return $this->arguments;\n    }\n\n    public function hasAttributes(): bool\n    {\n        return count($this->attributes) > 0;\n    }\n\n    public function getAttributes(): ?array\n    {\n        return $this->attributes;\n    }\n\n    public function getComposition(): ?ComponentEntity\n    {\n        if ($this->entity === null) {\n            $this->entity = ComponentEntity::buildFromArray($this->flatComposition);\n        }\n\n        return $this->entity;\n    }\n\n}"}
{"instruction": "Write an Ephect component", "input": "Based on Ephect source: ComponentDeclarationInterface.php", "output": "<?php\n\nnamespace Ephect\\Modules\\Forms\\Components;\n\nuse Ephect\\Framework\\ElementInterface;\n\ninterface ComponentDeclarationInterface extends ElementInterface\n{\n    public function getType(): string;\n\n    public function getName(): string;\n\n    public function hasArguments(): bool;\n\n    public function getArguments(): ?array;\n\n    public function hasAttributes(): bool;\n\n    public function getAttributes(): ?array;\n\n    public function getComposition(): ?ComponentEntity;\n}"}
{"instruction": "Write an Ephect component", "input": "Based on Ephect source: ComponentDeclarationStructure.php", "output": "<?php\n\nnamespace Ephect\\Modules\\Forms\\Components;\n\nuse Ephect\\Framework\\Structure\\Structure;\n\nclass ComponentDeclarationStructure extends Structure\n{\n    public string $uid = '';\n    public ?string $type = '';\n    public ?string $name = '';\n    public ?array $arguments = [];\n    public ?array $attributes = [];\n    public ?array $composition = null;\n\n}"}
{"instruction": "Write an Ephect component", "input": "Based on Ephect source: ComponentEntity.php", "output": "<?php\n\nnamespace Ephect\\Modules\\Forms\\Components;\n\nuse Ephect\\Framework\\ElementTrait;\nuse Ephect\\Framework\\Entity\\Entity;\nuse Ephect\\Framework\\Structure\\StructureInterface;\nuse Ephect\\Framework\\Tree\\TreeTrait;\nuse Ephect\\Framework\\Utils\\File;\nuse Ephect\\Modules\\Forms\\Registry\\ComponentRegistry;\n\n/**\n * Description of match\n *\n * @author david\n */\nclass ComponentEntity extends Entity implements ComponentEntityInterface\n{\n    use ElementTrait;\n    use TreeTrait;\n\n    protected int $parentId = 0;\n    protected string $name = '';\n    protected string $text = '';\n    protected int $start = 0;\n    protected int $end = 0;\n    protected int $depth = 0;\n    protected bool $isSibling = false;\n    protected ?array $closer = null;\n    protected mixed $contents = null;\n    protected bool $hasCloser = false;\n    protected bool $hasProperties = false;\n    protected array $properties = [];\n    protected string $method = '';\n    protected string $compName = '';\n    protected ?string $className = '';\n    protected bool $isSingle = false;\n    protected array $attributes = [];\n    protected StructureInterface|null $struct;\n\n    public function __construct(ComponentStructure|null $struct)\n    {\n        parent::__construct($struct);\n\n        if ($struct === null) {\n            return null;\n        }\n        $this->struct = $struct;\n\n        $this->uid = $struct->uid;\n        $this->motherUID = $struct->motherUID;\n        $this->id = $struct->id;\n        $this->className = $struct->class;\n        $this->compName = $struct->component;\n        $this->parentId = $struct->parentId;\n        $this->text = $struct->text;\n        $this->name = $struct->name;\n        $this->method = $struct->method;\n        $this->start = $struct->startsAt;\n        $this->end = $struct->endsAt;\n        $this->depth = $struct->depth;\n        $this->hasProperties = count($struct->props) !== 0;\n        $this->properties = $this->hasProperties ? $struct->props : [];\n        $this->hasCloser = is_array($struct->closer);\n        $this->closer = $this->hasCloser ? $struct->closer : null;\n        $this->isSingle = $struct->isSingle;\n        $this->attributes = $struct->attributes;\n\n        $this->elementList = (false === $struct->node) ? [] : $struct->node;\n\n        $this->bindNode();\n    }\n\n    public function bindNode(): void\n    {\n        if ($this->elementList === false || $this->elementList === null) {\n            return;\n        }\n\n        $this->elementList = array_map(function ($child) {\n            return new ComponentEntity(new ComponentStructure($child));\n        }, $this->elementList);\n    }\n\n    public static function buildFromArray(?array $list): ?ComponentEntity\n    {\n        $result = null;\n\n        if ($list === null) {\n            return null;\n        }\n\n        $depthIds = static::listIdsByDepth($list);\n\n        $c = count($list);\n\n        for ($j = 0; $j < $c; $j++) {\n            $i = $depthIds[$j];\n            if ($list[$i]['parentId'] === -1) {\n                continue;\n            }\n            $pId = $list[$i]['parentId'];\n\n            if (!is_array($list[$pId]['node'])) {\n                $list[$pId]['node'] = [];\n            }\n            $list[$pId]['node'][] = $list[$i];\n            unset($list[$i]);\n        }\n\n        if (count($list) === 1) {\n            $result = new ComponentEntity(new ComponentStructure($list[0]));\n        } elseif (count($list) > 1) {\n            $result = self::makeFragment();\n            foreach ($list as $item) {\n                $entity = new ComponentEntity(new ComponentStructure($item));\n                $result->add($entity);\n            }\n        }\n\n        return $result;\n    }\n\n    private static function listIdsByDepth(?array $list): ?array\n    {\n        if ($list === null) {\n            return null;\n        }\n\n        $result = [];\n\n        $depths = [];\n\n        foreach ($list as $match) {\n            $struct = new ComponentStructure($match);\n            $depths[$struct->depth] = 1;\n        }\n\n        $maxDepth = count($depths);\n        for ($i = $maxDepth; $i > -1; $i--) {\n            foreach ($list as $match) {\n                if ($match[\"depth\"] == $i) {\n                    $result[] = $match['id'];\n                }\n            }\n        }\n\n        return $result;\n    }\n\n    private static function makeFragment(): ComponentEntityInterface\n    {\n        $fragment = [\n            \"closer\" => [\n                \"id\" => 1,\n                \"parentId\" => 0,\n                \"text\" => \"<\\/>\",\n                \"startsAt\" => 0,\n                \"endsAt\" => 0,\n                \"contents\" => [\n                    \"startsAt\" => 0,\n                    \"endsAt\" => 0\n                ]\n            ],\n            \"uid\" => \"00000000-0000-0000-0000-000000000000\",\n            \"id\" => 0,\n            \"name\" => \"FakeFragment\",\n            \"class\" => null,\n            \"component\" => \"Ephect\",\n            \"text\" => \"<>\",\n            \"method\" => \"echo\",\n            \"startsAt\" => 0,\n            \"endsAt\" => 0,\n            \"props\" => [],\n            \"node\" => [],\n            \"hasCloser\" => true,\n            \"isSibling\" => false,\n            \"parentId\" => -1,\n            \"depth\" => 0\n        ];\n\n        return new ComponentEntity(new ComponentStructure($fragment));\n    }\n\n    public function getParentId(): int\n    {\n        return $this->parentId;\n    }\n\n    public function getText(): string\n    {\n        return $this->text;\n    }\n\n    public function getDepth(): int\n    {\n        return $this->depth;\n    }\n\n    public function hasProps(): bool\n    {\n        return count($this->properties) > 0;\n    }\n\n    public function hasCloser(): bool\n    {\n        return $this->hasCloser;\n    }\n\n    public function isSibling(): bool\n    {\n        return $this->isSibling;\n    }\n\n    public function getCloser(): array\n    {\n        return $this->closer;\n    }\n\n    public function getMethod(): string\n    {\n        return $this->method;\n    }\n\n    public function getStart(): int\n    {\n        return $this->start;\n    }\n\n    public function getEnd(): int\n    {\n        return $this->end;\n    }\n\n    public function composedOf(): array\n    {\n        $names = [];\n        $names[] = $this->name;\n\n        $this->forEach(function (ComponentEntityInterface $item, $key) use (&$names) {\n            $names[] = $item->getName();\n        }, $this);\n\n        return $names;\n    }\n\n    public function getName(): string\n    {\n        return $this->name;\n    }\n\n    public function toArray(): array\n    {\n        return $this->struct->toArray();\n    }\n\n    public function props(?string $key = null): string|array|null\n    {\n        if ($key === null) {\n            if (count($this->properties) === 0) {\n                return null;\n            }\n            return $this->properties;\n        }\n        if (isset($this->properties[$key])) {\n            return $this->properties[$key];\n        }\n        return null;\n    }\n\n    public function getInnerHTML(): string\n    {\n        $result = '';\n\n        if (!isset($this->closer['contents']['text'])) {\n            return $result;\n        }\n\n        $result = $this->closer['contents']['text'];\n        $result = substr($result, 9);\n\n        return base64_decode($result);\n    }\n\n    public function getContents(?string $html = null): ?string\n    {\n        $result = '';\n\n        if (!$this->hasCloser) {\n            return $result;\n        }\n\n        $contents = $this->closer['contents'];\n        $start = $contents['startsAt'];\n        $end = $contents['endsAt'];\n\n        $compFile = ComponentRegistry::read($this->compName);\n        if ($compFile === null) {\n            return $result;\n        }\n        $text = $html ?: File::safeRead(\\Constants::COPY_DIR . $compFile);\n\n        if (($pos = strpos($text, $this->text) + strlen($this->text)) > $start) {\n            $offset = $pos - $start;\n\n            $start += $offset;\n            $end += $offset;\n        }\n\n        return substr($text, $start, $end - $start + 1);\n    }\n\n    public function hasAttributes(): bool\n    {\n        return count($this->attributes) > 0;\n    }\n    public function getAttributes(): array\n    {\n        return $this->attributes;\n    }\n\n}"}
{"instruction": "Write an Ephect component", "input": "Based on Ephect source: ComponentEntityInterface.php", "output": "<?php\n\nnamespace Ephect\\Modules\\Forms\\Components;\n\nuse Ephect\\Framework\\ElementInterface;\nuse Ephect\\Framework\\Tree\\TreeInterface;\n\ninterface ComponentEntityInterface extends TreeInterface, ElementInterface\n{\n    public function getParentId(): int;\n\n    public function getName(): string;\n\n    public function getText(): string;\n\n    public function getDepth(): int;\n\n    public function hasProps(): bool;\n\n    public function props(?string $key = null): string|array|null;\n\n    public function getStart(): int;\n\n    public function getEnd(): int;\n\n    public function getInnerHTML(): ?string;\n\n    public function getContents(?string $html = null): ?string;\n\n    public function hasCloser(): bool;\n\n    public function isSibling(): bool;\n\n    public function getCloser(): array;\n\n    public function getMethod(): string;\n\n    public function toArray(): array;\n\n    public function hasAttributes(): bool;\n\n    public function getAttributes(): array;\n}"}
{"instruction": "Write an Ephect component", "input": "Based on Ephect source: ComponentFactory.php", "output": "<?php\n\nnamespace Ephect\\Modules\\Forms\\Components;\n\nuse Ephect\\Modules\\Forms\\Registry\\ComponentRegistry;\nuse Ephect\\Modules\\Forms\\Registry\\PluginRegistry;\n\nclass ComponentFactory\n{\n    public static function create(string $fullyQualifiedName, string $motherUID): FileComponentInterface\n    {\n\n        $filename = ComponentRegistry::read($fullyQualifiedName);\n        $isPlugin = empty($filename) && !empty($filename = PluginRegistry::read($fullyQualifiedName));\n\n        if ($isPlugin) {\n            $uid = PluginRegistry::read($filename);\n            $plugin = new Plugin($uid, $motherUID);\n            $plugin->load($filename);\n\n            return $plugin;\n        }\n\n        $uid = ComponentRegistry::read($filename);\n        $comp = new Component($uid, $motherUID);\n        $comp->load($filename);\n\n        return $comp;\n    }\n}"}
{"instruction": "Write an Ephect component", "input": "Based on Ephect source: ComponentInterface.php", "output": "<?php\n\nnamespace Ephect\\Modules\\Forms\\Components;\n\nuse Ephect\\Framework\\ElementInterface;\n\ninterface ComponentInterface extends ElementInterface\n{\n    public function getCode(): ?string;\n\n    public function applyCode(string $code): void;\n\n    public function getFullyQualifiedFunction(): ?string;\n\n    public function getFunction(): ?string;\n\n    public function getDeclaration(): ?ComponentDeclarationInterface;\n\n    public function getEntity(): ?ComponentEntityInterface;\n\n    public function getBodyStart(): int;\n\n    public function resetDeclaration(): void;\n\n    public function composedOf(): ?array;\n\n    public function renderComponent(\n        string $motherUID,\n        string $functionName,\n        array|object|null $functionArgs = null\n    ): array;\n\n    public function render(): void;\n}"}
{"instruction": "Write an Ephect component", "input": "Based on Ephect source: ComponentStructure.php", "output": "<?php\n\nnamespace Ephect\\Modules\\Forms\\Components;\n\nuse Ephect\\Framework\\Structure\\Structure;\n\nclass ComponentStructure extends Structure\n{\n    public string $uid = '';\n    public string $motherUID = '';\n    public string $id = '';\n    public ?string $class = '';\n    public string $component = '';\n    public string $name = '';\n    public string $method = '';\n    public string $text = '';\n    public int $parentId = 0;\n    public int $depth = 0;\n    public int $startsAt = 0;\n    public int $endsAt = 0;\n    public bool $isSibling = false;\n    public bool $hasCloser = false;\n    public ?array $closer = null;\n    public array $props = [];\n    public false|array $node = [];\n    public bool $isSingle = false;\n    public array $attributes = [];\n}"}
{"instruction": "Write an Ephect component", "input": "Based on Ephect source: FileComponentInterface.php", "output": "<?php\n\nnamespace Ephect\\Modules\\Forms\\Components;\n\ninterface FileComponentInterface extends ComponentInterface\n{\n    public static function getFlatFilename(string $basename): string;\n\n    public function getSourceFilename(): string;\n\n    public function getStandardFilename(): string;\n\n    public function getFlattenFilename(): string;\n\n    public function getFlattenSourceFilename(): string;\n\n    public function load(string $filename = ''): bool;\n\n    public function analyse(): void;\n\n    public function parse(): void;\n\n    public function copyComponents(\n        array &$list,\n        ?string $motherUID = null,\n        ?ComponentInterface $component = null\n    ): ?string;\n\n    public function findDependencies(\n        array &$list,\n        ?string $motherUID = null,\n        ?ComponentInterface $component = null\n    ): ?array;\n\n}"}
{"instruction": "Write an Ephect component", "input": "Based on Ephect source: Plugin.php", "output": "<?php\n\nnamespace Ephect\\Modules\\Forms\\Components;\n\nuse Ephect\\Modules\\Forms\\Registry\\ComponentRegistry;\nuse Ephect\\Modules\\Forms\\Registry\\PluginRegistry;\n\nclass Plugin extends Component implements FileComponentInterface\n{\n    public function makeComponent(string $filename, string &$html): void\n    {\n    }\n\n    public function analyse(): void\n    {\n        parent::analyse();\n\n        PluginRegistry::write($this->getFullyQualifiedFunction(), $this->getSourceFilename());\n        ComponentRegistry::safeWrite($this->getFunction(), $this->getFullyQualifiedFunction());\n    }\n\n}"}
{"instruction": "Write an Ephect component", "input": "Based on Ephect source: ComponentAttributesEvent.php", "output": "<?php\n\nnamespace Ephect\\Modules\\Forms\\Events;\n\nuse Ephect\\Framework\\ElementInterface;\nuse Ephect\\Framework\\Event\\Event;\nuse Ephect\\Framework\\Utils\\File;\nuse Ephect\\Modules\\Forms\\Components\\ComponentDeclaration;\nuse Ephect\\Modules\\Forms\\Components\\ComponentDeclarationInterface;\nuse Ephect\\Modules\\Forms\\Components\\ComponentDeclarationStructure;\nuse Ephect\\Modules\\Forms\\Components\\ComponentEntityInterface;\nuse Ephect\\Modules\\Forms\\Components\\ComponentInterface;\nuse Ephect\\Modules\\Forms\\Generators\\TokenParsers\\AbstractComponentParser;\nuse Ephect\\Modules\\Forms\\Registry\\CodeRegistry;\nuse Ephect\\Modules\\Forms\\Registry\\ComponentRegistry;\n\nclass ComponentAttributesEvent extends Event\n{\n    private ?ComponentDeclaration $declaration = null;\n\n    public function __construct(\n        private readonly ComponentInterface $parent,\n        private readonly ComponentEntityInterface $entity,\n    ) {\n        CodeRegistry::load();\n    }\n\n    public function getEntity(): ComponentEntityInterface\n    {\n        return $this->entity;\n    }\n\n    public function getMotherUID(): string\n    {\n        return $this->parent->getMotherUID();\n    }\n\n    public function getUID(): string\n    {\n        return $this->parent->getUID();\n    }\n\n    public function getCacheFilename(): string\n    {\n        $filename = $this->parent->getSourceFilename();\n        return \\Constants::BUILD_DIR . $this->parent->getMotherUID() . DIRECTORY_SEPARATOR . $filename;\n    }\n\n    public function getParent(): ?ElementInterface\n    {\n        return $this->parent->getParent();\n    }\n\n    public function getComponent(): ComponentInterface\n    {\n        return $this->parent;\n    }\n\n    public function getDeclaration(): ComponentDeclarationInterface\n    {\n        if ($this->declaration === null) {\n            $fqFuncName = ComponentRegistry::read($this->entity->getName());\n            $list = CodeRegistry::read($fqFuncName);\n            $struct = new ComponentDeclarationStructure($list);\n            $this->declaration = new ComponentDeclaration($struct);\n        }\n\n        return $this->declaration;\n    }\n\n    public function getAttributes(): ?array\n    {\n        return $this->declaration->getAttributes();\n    }\n\n    public function getPropsToArray(): array\n    {\n        $decl = $this->getDeclaration();\n        return $decl->getArguments();\n    }\n\n    public function getProps(): object\n    {\n        return (object) $this->getPropsToArray();\n    }\n\n    public function getPropsToString(): string\n    {\n        return AbstractComponentParser::doArgumentsToString($this->getPropsToArray()) ?? '';\n    }\n\n}"}
{"instruction": "Write an Ephect component", "input": "Based on Ephect source: ComponentFinishedEvent.php", "output": "<?php\n\nnamespace Ephect\\Modules\\Forms\\Events;\n\nuse Ephect\\Framework\\ElementInterface;\nuse Ephect\\Framework\\Event\\Event;\nuse Ephect\\Modules\\Forms\\Components\\ComponentDeclarationInterface;\nuse Ephect\\Modules\\Forms\\Components\\ComponentInterface;\nuse Ephect\\Modules\\Forms\\Generators\\TokenParsers\\AbstractComponentParser;\n\nclass ComponentFinishedEvent extends Event\n{\n    public function __construct(\n        private readonly ComponentInterface $component,\n        private readonly string $cacheFilename,\n    ) {\n    }\n\n    public function getMotherUID(): string\n    {\n        return $this->component->getMotherUID();\n    }\n\n    public function getUID(): string\n    {\n        return $this->component->getUID();\n    }\n\n    public function getCacheFilename(): string\n    {\n        return $this->cacheFilename;\n    }\n\n    public function getParent(): ?ElementInterface\n    {\n        return $this->getDeclaration()->getParent();\n    }\n\n    public function getComponent(): ComponentInterface\n    {\n        return $this->component;\n    }\n\n    public function getDeclaration(): ComponentDeclarationInterface\n    {\n        return $this->component->getDeclaration();\n    }\n\n    public function getPropsToArray(): array\n    {\n        $decl = $this->getDeclaration();\n        return $decl->getArguments();\n    }\n\n    public function getProps(): object\n    {\n        return (object) $this->getPropsToArray();\n    }\n\n    public function getPropsToString(): string\n    {\n        return AbstractComponentParser::doArgumentsToString($this->getPropsToArray()) ?? '';\n    }\n\n}"}
{"instruction": "Write an Ephect component", "input": "Based on Ephect source: PageFinishedEvent.php", "output": "<?php\n\nnamespace Ephect\\Modules\\Forms\\Events;\n\nuse Ephect\\Framework\\Event\\Event;\n\nclass PageFinishedEvent extends Event\n{\n    public function __construct(\n        private readonly string $motherUID,\n        private readonly string $cacheFilename,\n        private readonly string $componentName,\n        private readonly ?object $props,\n    ) {\n    }\n\n    public function getMotherUID(): string\n    {\n        return $this->motherUID;\n    }\n\n    public function getCacheFilename(): string\n    {\n        return $this->cacheFilename;\n    }\n\n    public function getComponentName(): string\n    {\n        return $this->componentName;\n    }\n\n    public function getProps(): ?object\n    {\n        return $this->props;\n    }\n}"}
{"instruction": "Write an Ephect component", "input": "Based on Ephect source: ComponentDocument.php", "output": "<?php\n\nnamespace Ephect\\Modules\\Forms\\Generators;\n\nuse Ephect\\Modules\\Forms\\Components\\ComponentEntity;\nuse Ephect\\Modules\\Forms\\Components\\ComponentInterface;\nuse Ephect\\Modules\\Forms\\Components\\ComponentStructure;\n\nclass ComponentDocument\n{\n    protected array $list = [];\n    protected ?string $text = '';\n    protected int $count = 0;\n    protected array $matches = [];\n    protected int $currentMatchKey = -1;\n    protected ?ComponentEntity $match = null;\n    protected array $depths = [];\n    protected array $matchesByDepth = [];\n    protected array $matchesById = [];\n    protected array $matchesByKey = [];\n    protected array $offsetsById = [];\n    protected ?ComponentInterface $component = null;\n\n    public function __construct(ComponentInterface $comp)\n    {\n        $this->component = $comp;\n        $this->text = $comp->getCode();\n    }\n\n    public function getMatches(): array\n    {\n        return $this->matches;\n    }\n\n    public function fieldValue(int $i, string $field, string $value): void\n    {\n        $this->list[$i][$field] = $value;\n    }\n\n    public function getMaxDepth(): int\n    {\n        return count($this->depths);\n    }\n\n    public function getDepthsOfMatches(): array\n    {\n        return $this->matchesByDepth;\n    }\n\n    public function getKeysOfMatches(): array\n    {\n        return $this->matchesByKey;\n    }\n\n    public function matchAll(): bool\n    {\n\n        $parser = new ComponentParser($this->component);\n        $parser->doComponents();\n\n        $this->list = $parser->getList();\n        $this->depths = $parser->getDepths();\n\n        $this->matchesByDepth = $parser->getIdListByDepth();\n        $this->matchesById = $this->sortMatchesById();\n        $this->matchesByKey = $this->sortMatchesByKey();\n\n        $this->count = count($this->list);\n\n        return ($this->count > 0);\n    }\n\n    public function getList(): array\n    {\n        return $this->list;\n    }\n\n    public function sortMatchesById(): array\n    {\n        $result = [];\n        foreach ($this->list as $match) {\n            $result[] = $match['id'];\n        }\n\n        return $result;\n    }\n\n    public function sortMatchesByKey(): array\n    {\n        $result = [];\n        $i = 0;\n        foreach ($this->list as $match) {\n            $result[$match['id']] = $i;\n            $i++;\n        }\n\n        return $result;\n    }\n\n    public function sortMatchesByDepth(): array\n    {\n        $maxDepth = count($this->depths);\n        $result = [];\n        for ($i = $maxDepth; $i > -1; $i--) {\n            foreach ($this->list as $match) {\n                if ($match[\"depth\"] == $i) {\n                    array_push($result, $match['id']);\n                }\n            }\n        }\n\n        return $result;\n    }\n\n    public function resetMatchId(): void\n    {\n        $this->currentMatchKey = -1;\n    }\n\n    public function getNextMatch(): ?ComponentEntity\n    {\n        $this->currentMatchKey++;\n\n        $this->match = null;\n        if ($this->currentMatchKey == $this->count) {\n            return null;\n        }\n\n        return $this->getCurrentMatch();\n    }\n\n    public function getCurrentMatch(): ?ComponentEntity\n    {\n        $currentId = $this->matchesById[$this->currentMatchKey];\n        if ($this->match === null || $this->match->getId() !== $currentId) {\n            $struct = new ComponentStructure($this->list[$currentId]);\n            $this->match = new ComponentEntity($struct);\n        }\n\n        return $this->match;\n    }\n\n    public function replaceMatches(ComponentDocument $doc, string &$childText): string\n    {\n        $parentMatchesById = $this->getIDsOfMatches();\n        $parentCount = $this->getCount();\n        $parentText = $this->text;\n        $parentReplacing = '';\n\n        $childMatchesById = $doc->getIDsOfMatches();\n        $childCount = $doc->getCount();\n\n        for ($i = $parentCount - 1; $i > -1; $i--) {\n            $parentId = $parentMatchesById[$i];\n            $parentMatch = $this->getMatchById($parentId);\n            $parentReplaced = '';\n\n            if ($parentMatch->getName() !== 'Slot') {\n                continue;\n            }\n\n            if ($parentMatch->hasCloser()) {\n                $start = $parentMatch->getStart();\n                $closer = $parentMatch->getCloser();\n                $length = $closer['endsAt'] - $parentMatch->getStart() + 1;\n\n                $parentReplaced = substr($parentText, $start, $length);\n\n                $start = $closer['contents']['startsAt'];\n                $length = $closer['contents']['endsAt'] - $start + 1;\n\n                $parentReplacing = substr($parentText, $start, $length);\n            } else {\n                $parentReplaced = $parentMatch->getText();\n            }\n            $matchesChildBlock = false;\n\n            for ($j = $childCount - 1; $j > -1; $j--) {\n                $childId = $childMatchesById[$j];\n                $childMatch = $doc->getMatchById($childId);\n                $childReplacing = '';\n\n                if (\n                    $childMatch->getName() !== 'Slot'\n                    || $parentMatch->props('name') !== $childMatch->props('name')\n                ) {\n                    continue;\n                }\n\n                $matchesChildBlock = true;\n                if ($childMatch->hasCloser()) {\n                    $closer = $childMatch->getCloser();\n                    $start = $closer['contents']['startsAt'];\n                    $length = $closer['contents']['endsAt'] - $start + 1;\n\n                    $childReplacing = substr($childText, $start, $length);\n\n                    $start = $childMatch->getStart();\n                    $closer = $childMatch->getCloser();\n                    $length = $closer['endsAt'] - $childMatch->getStart() + 1;\n\n                    $childReplaced = substr($childText, $start, $length);\n\n                } else {\n                    $childReplacing = $childMatch->getText();\n                }\n\n                $childText = str_replace($childReplaced, '', $childText);\n                $parentText = str_replace($parentReplaced, $childReplacing, $parentText);\n\n                break;\n            }\n\n            if (!$matchesChildBlock) {\n                $parentText = str_replace($parentReplaced, $parentReplacing, $parentText);\n            }\n        }\n\n        return $parentText;\n    }\n\n    public function getIDsOfMatches(): array\n    {\n        return $this->matchesById;\n    }\n\n    public function getCount(): int\n    {\n        return $this->count;\n    }\n\n    public function getMatchById(int $id): ?ComponentEntity\n    {\n        if (!isset($this->list[$id])) {\n            return null;\n        }\n\n        $struct = new ComponentStructure($this->list[$id]);\n\n        return new ComponentEntity($struct);\n    }\n\n    public function getText(): string\n    {\n        return $this->text;\n    }\n\n}"}
{"instruction": "Write an Ephect component", "input": "Based on Ephect source: ComponentParser.php", "output": "<?php\n\nnamespace Ephect\\Modules\\Forms\\Generators;\n\nuse Ephect\\Framework\\Crypto\\Crypto;\nuse Ephect\\Framework\\ElementUtils;\nuse Ephect\\Modules\\Forms\\Components\\ComponentDeclarationStructure;\nuse Ephect\\Modules\\Forms\\Components\\ComponentInterface;\nuse Ephect\\Modules\\Forms\\Registry\\ComponentRegistry;\n\nclass ComponentParser extends Parser implements ParserInterface\n{\n    private const string TERMINATOR = '/';\n    private const string OPEN_TAG = '<';\n    private const string CLOSE_TAG = '>';\n    protected array $depths = [];\n    protected array $idListByDepth = [];\n    protected array $list = [];\n\n    public function __construct(string|ComponentInterface $comp)\n    {\n        parent::__construct($comp);\n\n        ComponentRegistry::load();\n    }\n\n    /**\n     * @throws \\ReflectionException\n     */\n    public function doReflection(): array\n    {\n        $fqFuncName = $this->component->getFullyQualifiedFunction();\n        $filename = ComponentRegistry::read($fqFuncName);\n        $sourceDir = \\Constants::UNIQUE_DIR;\n\n        [\n            $namespace,\n            $functionName,\n            $parameters,\n            $returnedType,\n            $startsAt\n        ] = ElementUtils::getFunctionDefinitionFromFile($sourceDir . $filename);\n\n        if ($functionName == '') {\n            return  [null, null, null];\n        }\n\n        include_once $sourceDir . $filename;\n\n        $fqFuncName = $namespace . '\\\\' . $functionName;\n\n        $ref = new \\ReflectionFunction($fqFuncName);\n        $refParameters = $ref->getParameters();\n        $refAttributes = $ref->getAttributes();\n        $refReturnType = $ref->getReturnType();\n\n        $arguments = array_map(function ($parameter) {\n            return $parameter->getName();\n        }, $refParameters);\n\n        $attributes = array_map(function ($attribute) {\n            return [\n                'name' => get_class($attribute->newInstance()),\n                'arguments' => $attribute->getArguments(),\n            ];\n        }, $refAttributes);\n\n        return [$arguments, $attributes, $refReturnType?->getName()];\n    }\n\n    /**\n     * @throws \\ReflectionException\n     */\n    public function doDeclaration(string $uid = ''): ComponentDeclarationStructure\n    {\n        if ($uid == '') {\n            $uid = Crypto::createUID();\n        }\n        [$args, $attrs, $return] = $this->doReflection();\n        $this->doComponents();\n        $func = $this->doFunctionDeclaration();\n        $decl = [\n            'uid' => $uid,\n            'type' => $func[0],\n            'name' => $func[1],\n            'arguments' => $args ?? [],\n            'attributes' => $attrs ?? [],\n            'composition' => $this->list\n        ];\n\n        return new ComponentDeclarationStructure($decl);\n    }\n\n    public function doComponents(string $rule = \"[A-Z]\\w+\"): void\n    {\n\n        $list = [];\n        $i = 0;\n        $text = $this->html;\n        $text .= \"\\n<Eof />\";\n        $parentIds = [];\n        $depth = 0;\n        $parentIds[$depth] = -1;\n        $allTags = [];\n\n        $re = <<< REGEX\n/<\\/?({$rule})((\\s|.*?)*)\\/?>|<\\/?>/\nREGEX;\n\n        preg_match_all($re, $text, $matches, PREG_OFFSET_CAPTURE | PREG_SET_ORDER, 0);\n\n        $i = 0;\n\n        foreach ($matches as $match) {\n            $tag = $match;\n            $tag['id'] = $i;\n            $tag['text'] = $match[0][0];\n            $tag['name'] = !isset($match[1]) ? 'Fragment' : $match[1][0];\n            $tag['startsAt'] = $match[0][1];\n            $tag['endsAt'] = intval($match[0][1]) + strlen($tag['text']) - 1;\n\n            unset($tag[0]);\n            unset($tag[1]);\n            unset($tag[2]);\n            unset($tag[3]);\n\n            $allTags[] = $tag;\n            $i++;\n        }\n\n        $this->depths[$depth] = 1;\n\n        $l = count($allTags);\n        $i = 0;\n        $isFinished = false;\n        $spinner = 0;\n        $spinnerMax = $l;\n        $isSpinning = false;\n        while (count($allTags) && !$isFinished && !$isSpinning) {\n            if ($i === $l) {\n                $i = 0;\n                $allTags = array_values($allTags);\n                $l = count($allTags);\n                if ($l === 0) {\n                    $isFinished = true;\n                    continue;\n                }\n\n                $spinner++;\n                $isSpinning = $spinner > $spinnerMax + 1;\n            }\n\n            $tag = $allTags[$i];\n            if (count($allTags) === 1 && $tag['name'] === 'Eof') {\n                $isFinished = true;\n                continue;\n            }\n\n            if ($this->isClosedTag($tag) && $tag['name'] !== 'Eof') {\n                $item = $this->makeTag($tag, $parentIds, $depth, false);\n                $list[$item['id']] = $item;\n                unset($allTags[$i]);\n\n                $i++;\n\n                continue;\n            }\n\n            if ($this->isCloseTag($tag)) {\n                $depth--;\n            }\n\n            if ($i + 1 < $l) {\n                $nextMatch = $allTags[$i + 1];\n\n                if (!$this->isCloseTag($tag) && $this->isCloseTag($nextMatch)) {\n                    $item = $this->makeTag($tag, $parentIds, $depth, true);\n                    $closer = $this->makeTag($nextMatch, $parentIds, $depth, false, true);\n\n                    if ($item['name'] !== $closer['name']) {\n                        $item['hasCloser'] = false;\n                        $list[$item['id']] = $item;\n                        unset($allTags[$i]);\n                        $this->depths[$depth] = 1;\n                        $i++;\n\n                        continue;\n                    }\n\n                    $closer['contents'] = [];\n                    $closer['parentId'] = $item['id'];\n                    $closer['contents']['startsAt'] = $item['endsAt'] + 1; // uniqid();\n                    $closer['contents']['endsAt'] = $closer['startsAt'] - 1; // uniqid();\n                    $contents = substr(\n                        $this->html,\n                        $closer['contents']['startsAt'],\n                        $closer['contents']['endsAt'] - $closer['contents']['startsAt'] + 1\n                    );\n                    $closer['contents']['text'] = '!#base64#' . base64_encode($contents);\n\n                    $item['closer'] = $closer;\n\n                    $list[$item['id']] = $item;\n\n                    unset($allTags[$i]);\n                    unset($allTags[$i + 1]);\n\n                    $i += 2;\n\n                    continue;\n                }\n\n                if (!$this->isCloseTag($tag) && !$this->isCloseTag($nextMatch)) {\n                    $depth++;\n                    $parentIds[$depth] = $tag['id'];\n                }\n            }\n\n            $this->depths[$depth] = 1;\n\n            $i++;\n        }\n\n        ksort($list);\n\n        $maxDepth = count($this->depths);\n        for ($i = $maxDepth; $i > -1; $i--) {\n            foreach ($list as $match) {\n                if ($match[\"depth\"] == $i) {\n                    $this->idListByDepth[] = $match['id'];\n                }\n            }\n        }\n\n        $this->list = $list;\n    }\n\n    protected function isClosedTag(array $tag): bool\n    {\n        $text = $tag['text'];\n        if (empty($text) || $tag['name'] === 'Fragment') {\n            return false;\n        }\n\n        return substr($text, -2) === self::TERMINATOR . self::CLOSE_TAG;\n    }\n\n    protected function makeTag($tag, $parentIds, $depth, $hasCloser, $isCloser = false): array\n    {\n        $text = $tag['text'];\n        $name = $tag['name'];\n\n        $i = count($this->list);\n        $item = [];\n\n        $fqName = '';\n        if (is_object($this->component)) {\n            $fqName = $this->component->getFullyQualifiedFunction();\n        }\n\n        $item['id'] = $tag['id'];\n        $item['name'] = empty($name) ? 'Fragment' : $name;\n        $item['text'] = $text;\n        $item['startsAt'] = $tag['startsAt'];\n        $item['endsAt'] = $tag['endsAt'];\n        if (!$isCloser) {\n            $item['uid'] = Crypto::createOID();\n            $item['class'] = ComponentRegistry::read($item['name']);\n            $item['method'] = 'echo';\n            $item['component'] = $fqName;\n            $item['props'] = ($item['name'] === 'Fragment') ? [] : $this->doArguments($text);\n            $item['depth'] = $depth;\n            $item['hasCloser'] = $hasCloser;\n            $item['node'] = false;\n            $item['isSingle'] = false;\n        }\n        if (!isset($parentIds[$depth])) {\n            $parentIds[$depth] = $i - 1;\n        }\n        $item['parentId'] = $parentIds[$depth];\n\n        return $item;\n    }\n\n    protected function isCloseTag(array $tag): bool\n    {\n        $text = $tag['text'];\n        if (empty($text) || $text === '<>') {\n            return false;\n        }\n        return substr($text, 0, 2) === self::OPEN_TAG . self::TERMINATOR;\n    }\n\n    /** TO BE DONE on base of regex101 https://regex101.com/r/QZejMW/2/ */\n    public function doFunctionDeclaration(): ?array\n    {\n        $result = [];\n        $re = '/(function)[ ]+([\\w]+)[ ]*\\(((\\s|.*?)*)\\)/m';\n\n        $str = $this->html;\n\n        preg_match_all($re, $str, $matches, PREG_SET_ORDER, 0);\n\n        foreach ($matches as $match) {\n            $args = $this->doFunctionArguments($match[3]);\n            $result = [$match[1], $match[2], $args];\n        }\n\n        return $result;\n    }\n\n    private function doFunctionArguments(string $arguments): ?array\n    {\n        $result = [];\n        $re = '/([,]?[.]?\\$[\\w]+)/';\n\n        $str = $arguments;\n\n        preg_match_all($re, $str, $matches, PREG_SET_ORDER, 0);\n\n        foreach ($matches as $match) {\n            $result[] = $match[1];\n        }\n\n        return $result;\n    }\n\n    public function doAttributes(): array\n    {\n        $result = [];\n\n        $re = '/(#\\[(\\w+)(\\(.*\\))?])/m';\n        preg_match_all($re, $this->html, $matches, PREG_SET_ORDER, 0);\n\n        foreach ($matches as $match) {\n            $result[] = $match[2];\n        }\n\n        return $result;\n    }\n\n    public function getList(): array\n    {\n        return $this->list;\n    }\n\n    public function getHtml(): string\n    {\n        return $this->html;\n    }\n\n    public function getDepths(): array\n    {\n        return $this->depths;\n    }\n\n    public function getIdListByDepth(): array\n    {\n        return $this->idListByDepth;\n    }\n}"}
{"instruction": "Write an Ephect component", "input": "Based on Ephect source: Decomposer.php", "output": "<?php\n\n/** @noinspection PhpArrayWriteIsNotUsedInspection */\n\nnamespace Ephect\\Modules\\Forms\\Generators;\n\nuse Ephect\\Framework\\CLI\\Console;\nuse Ephect\\Framework\\Crypto\\Crypto;\nuse Ephect\\Modules\\Forms\\Components\\ComponentDeclarationStructure;\nuse Ephect\\Modules\\Forms\\Components\\ComponentInterface;\nuse Ephect\\Modules\\Forms\\Registry\\ComponentRegistry;\n\nclass Decomposer extends Parser implements ParserInterface\n{\n    private const string TERMINATOR = '/';\n    private const string OPEN_TAG = '&lt;';\n    private const string CLOSE_TAG = '&gt;';\n    protected array $depths = [];\n    protected array $idListByDepth = [];\n    protected array $list = [];\n\n    public function __construct(string|ComponentInterface $comp)\n    {\n        parent::__construct($comp);\n\n        $this->protect();\n        $this->markupQuotes();\n    }\n\n    protected function protect(): void\n    {\n        $text = trim($this->html);\n        $text = str_replace('{{', '<D>', $text);\n        $text = str_replace('}}', '</D>', $text);\n        $text = str_replace('(', '<C>', $text);\n        $text = str_replace(')', '</C>', $text);\n        $text = str_replace('{', '<E>', $text);\n        $text = str_replace('}', '</E>', $text);\n        $text = str_replace('[', '<T>', $text);\n        $text = str_replace(']', '</T>', $text);\n        $text = preg_replace('/<([\\/\\w])/m', self::OPEN_TAG . '$1', $text);\n        $text = str_replace('>', self::CLOSE_TAG, $text);\n\n        $this->html = $text;\n    }\n\n    protected function markupQuotes(): void\n    {\n\n        $html = $this->html;\n        $re = '/([\"\\'`])((\\s|((\\\\\\)*)\\\\\\.|.)*?)\\1/m';\n\n        preg_match_all($re, $html, $attributes, PREG_OFFSET_CAPTURE | PREG_SET_ORDER, 0);\n\n        Console::log($attributes);\n\n        $l = count($attributes);\n        for ($i = $l - 1; $i > -1; $i--) {\n            $attr = $attributes[$i];\n            $quote = $attr[1][0];\n            $quoted = $attr[0][0];\n            $unQuoted = $attr[2][0];\n            $start = intval($attr[0][1]) + 1;\n            $end = $start + strlen($quoted) - 1;\n\n            $letter = '';\n            if ($quote === '\"') {\n                $letter = 'R';\n            } elseif ($quote === '\\'') {\n                $letter = 'Q';\n            } elseif ($quote === '`') {\n                $letter = 'G';\n            }\n\n            $unQuoted = str_replace('&lt;', '&pp;', $unQuoted);\n            $unQuoted = str_replace('&gt;', '&pg;', $unQuoted);\n            $newValue = '&oq;' . $letter . '&cq;' . $unQuoted . '&oq;/' . $letter . '&cq;';\n\n            $beginBlock = substr($html, 0, $start - 1);\n            $endBlock = substr($html, $end);\n\n            $html = $beginBlock . $newValue . $endBlock;\n        }\n\n        $this->html = $html;\n    }\n\n    public function doDeclaration(string $uid): ComponentDeclarationStructure\n    {\n        $this->doComponents();\n        $func = $this->doFunctionDeclaration();\n        $decl = [\n            'uid' => $uid,\n            'type' => $func[0],\n            'name' => $func[1],\n            'arguments' => $func[2],\n            'composition' => $this->list\n        ];\n\n        return new ComponentDeclarationStructure($decl);\n    }\n\n    public function doComponents(string $rule = \"\\w+\"): void\n    {\n\n        $list = [];\n        $i = 0;\n        $text = $this->html;\n        $text .= \"\\n<Eof />\";\n        $parentIds = [];\n        $depth = 0;\n        $parentIds[$depth] = -1;\n        $allTags = [];\n        $singleTags = [];\n        $singleIdList = [];\n        $workTags = [];\n\n        $allTags = $this->collectTags($text, $rule);\n\n        [$regularTags, $singleTags] = $this->splitTags($allTags);\n\n        $workTags = $allTags;\n\n        if (count($singleTags)) {\n            foreach ($singleTags as $tag) {\n                $singleIdList[] = $tag['id'];\n            }\n            $text = $this->replaceTags($text, $singleTags);\n            $workTags = $this->collectTags($text, $rule);\n        }\n\n        $l = count($workTags);\n        $isFinished = false;\n        $spinner = 0;\n        $spinnerMax = $l;\n        $isSpinning = false;\n\n        $this->depths[$depth] = 1;\n\n        while (count($workTags) && !$isFinished && !$isSpinning) {\n            if ($i === $l) {\n                $i = 0;\n                $workTags = array_values($workTags);\n                $l = count($workTags);\n                if ($l === 0) {\n                    $isFinished = true;\n                    continue;\n                }\n\n                $spinner++;\n                $isSpinning = $spinner > $spinnerMax + 1;\n            }\n\n            $tag = $workTags[$i];\n            if (count($workTags) === 1 && $tag['name'] === 'Eof') {\n                $isFinished = true;\n                continue;\n            }\n\n            if ($this->isSingleTag($tag) && $tag['name'] !== 'Eof') {\n                $item = $this->makeTag($tag, $parentIds, $depth, false);\n                $item['isSingle'] = in_array($tag['id'], $singleIdList);\n\n                $list[$item['id']] = $item;\n                unset($workTags[$i]);\n\n                $i++;\n\n                continue;\n            }\n\n            if ($this->isCloseTag($tag)) {\n                $depth--;\n            }\n\n            if ($i + 1 < $l) {\n                $nextMatch = $workTags[$i + 1];\n\n                if (!$this->isCloseTag($tag) && $this->isCloseTag($nextMatch)) {\n                    $item = $this->makeTag($tag, $parentIds, $depth, true);\n                    $closer = $this->makeTag($nextMatch, $parentIds, $depth, false, true);\n\n                    $closer['contents'] = [];\n                    $closer['parentId'] = $item['id'];\n                    $closer['contents']['startsAt'] = $item['endsAt'] + 1; // uniqid();\n                    $closer['contents']['endsAt'] = $closer['startsAt'] - 1; // uniqid();\n                    $contents = substr(\n                        $this->html,\n                        $closer['contents']['startsAt'],\n                        $closer['contents']['endsAt'] - $closer['contents']['startsAt'] + 1\n                    );\n                    $closer['contents']['text'] = '!#base64#' . base64_encode($contents);\n\n                    $item['closer'] = $closer;\n\n                    $list[$item['id']] = $item;\n\n                    unset($workTags[$i]);\n                    unset($workTags[$i + 1]);\n\n                    $i += 2;\n\n                    continue;\n                }\n\n                if (!$this->isCloseTag($tag) && !$this->isCloseTag($nextMatch)) {\n                    $depth++;\n                    $parentIds[$depth] = $tag['id'];\n                }\n            }\n\n            $this->depths[$depth] = 1;\n\n            $i++;\n        }\n\n        ksort($list);\n        //        $l = count($list);\n        //        for ($i = 0; $i < $l; $i++) {}\n\n        $maxDepth = count($this->depths);\n        for ($i = $maxDepth; $i > -1; $i--) {\n            foreach ($list as $match) {\n                if ($match[\"depth\"] == $i) {\n                    $this->idListByDepth[] = $match['id'];\n                }\n            }\n        }\n\n        $this->list = $list;\n    }\n\n    protected function collectTags(string $text, string $rule = \"\\w+\"): array\n    {\n        $result = [];\n\n        $re = \"/&lt;\\/?($rule)((\\s|.*?)*)\\/?&gt;/\";\n        preg_match_all($re, $text, $matches, PREG_OFFSET_CAPTURE | PREG_SET_ORDER, 0);\n\n        $i = 0;\n\n        foreach ($matches as $match) {\n            $tag = $match;\n            $tag['id'] = $i;\n            $tag['text'] = $match[0][0];\n            $tag['name'] = !isset($match[1]) ? 'Fragment' : $match[1][0];\n            $tag['startsAt'] = $match[0][1];\n            $tag['endsAt'] = intval($match[0][1]) + strlen($tag['text']) - 1;\n\n            unset($tag[0]);\n            unset($tag[1]);\n            unset($tag[2]);\n            unset($tag[3]);\n\n            $result[] = $tag;\n            $i++;\n        }\n\n        return $result;\n    }\n\n    protected function splitTags(array $allTags): array\n    {\n        $l = count($allTags);\n        $i = 0;\n        $isFinished = false;\n        $spinner = 0;\n        $spinnerMax = $l;\n        $isSpinning = false;\n        $singleTags = [];\n        $regularTags = [];\n\n        while (count($allTags) && !$isFinished && !$isSpinning) {\n            if ($i === $l) {\n                $i = 0;\n                $allTags = array_values($allTags);\n                $l = count($allTags);\n                if ($l === 0) {\n                    $isFinished = true;\n                    continue;\n                }\n\n                $spinner++;\n                $isSpinning = $spinner > $spinnerMax + 1;\n            }\n\n            $tag = $allTags[$i];\n            if (count($allTags) === 1 && $tag['name'] === 'Eof') {\n                $isFinished = true;\n                continue;\n            }\n\n            if ($this->isSingleTag($tag) && $tag['name'] !== 'Eof') {\n                $regularTags[$i] = $allTags[$i];\n                unset($allTags[$i]);\n                $i++;\n\n                continue;\n            }\n\n            if ($i + 1 < $l) {\n                $nextMatch = $allTags[$i + 1];\n\n                if (!$this->isCloseTag($tag) && $this->isCloseTag($nextMatch)) {\n                    if ($tag['name'] !== $nextMatch['name']) {\n                        unset($allTags[$i]);\n                        $singleTags[] = $tag;\n                        $singleIdList[] = $i;\n                        $i++;\n                        continue;\n                    }\n\n                    $regularTags[$i] = $allTags[$i];\n                    $regularTags[$i + 1] = $allTags[$i + 1];\n                    unset($allTags[$i]);\n                    unset($allTags[$i + 1]);\n\n                    $i += 2;\n\n                    continue;\n                }\n            }\n            $i++;\n        }\n\n        return [$regularTags, $singleTags];\n    }\n\n    protected function isSingleTag(array $tag): bool\n    {\n        $text = $tag['text'];\n        if (empty($text) || $tag['name'] === 'Fragment') {\n            return false;\n        }\n\n        return substr($text, -5) === self::TERMINATOR . self::CLOSE_TAG;\n    }\n\n    protected function isCloseTag(array $tag): bool\n    {\n        $text = $tag['text'];\n        if (empty($text)) {\n            return false;\n        }\n        return substr($text, 0, 5) === self::OPEN_TAG . self::TERMINATOR;\n    }\n\n    protected function replaceTags(string $text, array $tags): string\n    {\n        $result = $text;\n\n        $list = [];\n\n        foreach ($tags as $tag) {\n            $list[$tag['id']] = $tag;\n        }\n\n        ksort($list);\n        $tags = array_values($list);\n\n        $c = count($tags);\n        for ($i = $c - 1; $i > -1; $i--) {\n            $tag = $tags[$i];\n            $tag['text'] = substr($tag['text'], 0, -4) . self::TERMINATOR . self::CLOSE_TAG;\n\n            $begin = substr($result, 0, $tag['startsAt']);\n            $end = substr($result, $tag['endsAt'] + 1);\n\n            $result = $begin . $tag['text'] . $end;\n        }\n\n        return $result;\n    }\n\n    protected function makeTag($tag, $parentIds, $depth, $hasCloser, $isCloser = false): array\n    {\n        $text = $tag['text'];\n        $name = $tag['name'];\n\n        $i = count($this->list);\n        $item = [];\n\n        $fqName = '';\n        if (is_object($this->component)) {\n            $fqName = $this->component->getFullyQualifiedFunction();\n        }\n\n        $item['id'] = $tag['id'];\n        $item['name'] = empty($name) ? 'Fragment' : $name;\n        $item['text'] = $text;\n        $item['startsAt'] = $tag['startsAt'];\n        $item['endsAt'] = $tag['endsAt'];\n        if (!$isCloser) {\n            $item['uid'] = Crypto::createOID();\n            $item['class'] = ComponentRegistry::read($item['name']);\n            $item['method'] = 'echo';\n            $item['component'] = $fqName;\n            $item['props'] = ($item['name'] === 'Fragment') ? [] : $this->doArguments($text);\n            $item['depth'] = $depth;\n            $item['hasCloser'] = $hasCloser;\n            $item['node'] = false;\n            $item['isSingle'] = false;\n        }\n        if (!isset($parentIds[$depth])) {\n            $parentIds[$depth] = $i - 1;\n        }\n        $item['parentId'] = $parentIds[$depth];\n\n        return $item;\n    }\n\n    /** TO BE DONE on bas of regex101 https://regex101.com/r/QZejMW/2/ */\n    public function doFunctionDeclaration(): ?array\n    {\n        $result = [];\n        $re = '/(function)[ ]+([\\w]+)[ ]*\\(((\\s|.*?)*)\\)/m';\n\n        $str = $this->html;\n\n        preg_match_all($re, $str, $matches, PREG_SET_ORDER, 0);\n\n        foreach ($matches as $match) {\n            $args = $this->doFunctionArguments($match[3]);\n            $result = [$match[1], $match[2], $args];\n        }\n\n        return $result;\n    }\n\n    private function doFunctionArguments(string $arguments): ?array\n    {\n        $result = [];\n        $re = '/([,]?[.]?\\$[\\w]+)/';\n\n        $str = $arguments;\n\n        preg_match_all($re, $str, $matches, PREG_SET_ORDER, 0);\n\n        foreach ($matches as $match) {\n            $result[] = $match[1];\n        }\n\n        return $result;\n    }\n\n    public function getList(): array\n    {\n        return $this->list;\n    }\n\n    public function getHtml(): string\n    {\n        return $this->html;\n    }\n\n    public function getDepths(): array\n    {\n        return $this->depths;\n    }\n\n    public function getIdListByDepth(): array\n    {\n        return $this->idListByDepth;\n    }\n}"}
{"instruction": "Write an Ephect component", "input": "Based on Ephect source: Parser.php", "output": "<?php\n\nnamespace Ephect\\Modules\\Forms\\Generators;\n\nuse Ephect\\Modules\\Forms\\Components\\ComponentInterface;\nuse Ephect\\Modules\\Forms\\Registry\\CodeRegistry;\n\nclass Parser implements ParserInterface\n{\n    protected ?string $html = '';\n    protected ?ComponentInterface $component = null;\n\n    public function __construct(string|ComponentInterface $comp)\n    {\n        if (is_string($comp)) {\n            $this->component = null;\n            $this->html = $comp;\n        } else {\n            $this->component = $comp;\n            $this->html = $comp->getCode();\n            $this->doUncache();\n        }\n    }\n\n    public function doUncache(): bool\n    {\n        CodeRegistry::setCacheDirectory(\\Constants::BUILD_DIR . $this->component->getMotherUID());\n        return CodeRegistry::load();\n    }\n\n    public static function doArgumentsToString(array $componentArgs): ?string\n    {\n        $result = '';\n\n        foreach ($componentArgs as $key => $value) {\n            if (is_array($value)) {\n                $value = json_encode($value);\n            }\n            $result .= '\"' . $key . '\" => \"' . urlencode($value) . '\", ';\n        }\n        return ($result === '') ? null : '[' . $result . ']';\n    }\n\n    public function getHtml(): ?string\n    {\n        return $this->html;\n    }\n\n    public function doCache(): bool\n    {\n        return CodeRegistry::save();\n    }\n\n    public function doArguments(string $componentArgs): ?array\n    {\n        $result = [];\n\n        $re = '/([A-Za-z0-9_-]+)(\\[])?=(\\\"([\\S ][^\"]*)\\\"|\\'([\\S]*)\\'|\\{\\{ ([\\w]*) }}|\\{([\\S ]*)})/m';\n\n        preg_match_all($re, $componentArgs, $matches, PREG_SET_ORDER, 0);\n\n        foreach ($matches as $match) {\n            $key = $match[1];\n            $value = substr(substr($match[3], 1), 0, -1);\n\n            if (isset($match[2]) && $match[2] === '[]') {\n                if (!isset($result[$key])) {\n                    $result[$key] = [];\n                }\n                $result[$key][] = $value;\n            } else {\n                $result[$key] = $value;\n            }\n        }\n\n        return $result;\n    }\n\n}"}
{"instruction": "Write an Ephect PHP component", "input": "Based on Ephect source: ParserInterface.php", "output": "<?php\n\nnamespace Ephect\\Modules\\Forms\\Generators;\n\ninterface ParserInterface\n{\n    public static function doArgumentsToString(array $componentArgs): ?string;\n\n    public function getHtml(): ?string;\n\n    public function doCache(): bool;\n\n    public function doUncache(): bool;\n\n    public function doArguments(string $componentArgs): ?array;\n}"}
{"instruction": "Write an Ephect component", "input": "Based on Ephect source: ParserService.php", "output": "<?php\n\nnamespace Ephect\\Modules\\Forms\\Generators;\n\nuse Constants;\nuse Ephect\\Modules\\Forms\\Application\\ApplicationComponent;\nuse Ephect\\Modules\\Forms\\Components\\FileComponentInterface;\nuse Ephect\\Modules\\Forms\\Registry\\ComponentRegistry;\nuse Ephect\\Modules\\Forms\\Generators\\TokenParsers\\ArraysParser;\nuse Ephect\\Modules\\Forms\\Generators\\TokenParsers\\AttributesParser;\nuse Ephect\\Modules\\Forms\\Generators\\TokenParsers\\ChildrenDeclarationParser;\nuse Ephect\\Modules\\Forms\\Generators\\TokenParsers\\ChildSlotsParser;\nuse Ephect\\Modules\\Forms\\Generators\\TokenParsers\\ClosedComponentsParser;\nuse Ephect\\Modules\\Forms\\Generators\\TokenParsers\\EmptyComponentsParser;\nuse Ephect\\Modules\\Forms\\Generators\\TokenParsers\\FragmentsParser;\nuse Ephect\\Modules\\Forms\\Generators\\TokenParsers\\HeredocParser;\nuse Ephect\\Modules\\Forms\\Generators\\TokenParsers\\HtmlParser;\nuse Ephect\\Modules\\Forms\\Generators\\TokenParsers\\ModuleComponentParser;\nuse Ephect\\Modules\\Forms\\Generators\\TokenParsers\\NamespaceParser;\nuse Ephect\\Modules\\Forms\\Generators\\TokenParsers\\OpenComponentsParser;\nuse Ephect\\Modules\\Forms\\Generators\\TokenParsers\\ReturnTypeParser;\nuse Ephect\\Modules\\Forms\\Generators\\TokenParsers\\UseEffectParser;\nuse Ephect\\Modules\\Forms\\Generators\\TokenParsers\\UsesAsParser;\nuse Ephect\\Modules\\Forms\\Generators\\TokenParsers\\UsesParser;\nuse Ephect\\Modules\\Forms\\Generators\\TokenParsers\\UseVariablesParser;\nuse Ephect\\Modules\\Forms\\Generators\\TokenParsers\\View\\InlineCodeParser;\n\nclass ParserService implements ParserServiceInterface\n{\n    protected ?object $component = null;\n    protected array $funcVariables = [];\n    protected array $useVariables = [];\n    protected array $attributes = [];\n    protected array $useTypes = [];\n    protected string $html = '';\n    protected ?object $children = null;\n    protected array $componentList = [];\n    protected array $openComponentList = [];\n    protected string|array|bool|null $result = null;\n\n    public function getChildren(): ?object\n    {\n        return $this->children;\n    }\n\n    public function doChildSlots(FileComponentInterface $component): void\n    {\n        $p = new ChildSlotsParser($component);\n        $p->do();\n        $this->html = $p->getHtml();\n        $this->result = $p->getResult();\n    }\n\n    public function getHtml(): string\n    {\n        return $this->html;\n    }\n\n    public function getResult(): null|string|array|bool\n    {\n        return $this->result;\n    }\n\n    public function getUses(): ?array\n    {\n        return $this->useTypes;\n    }\n\n    public function getAttributes(): ?array\n    {\n        return $this->attributes;\n    }\n\n    public function doUses(FileComponentInterface $component): void\n    {\n        $p = new UsesParser($component);\n        $p->do();\n        $this->useTypes = array_merge($this->useTypes, $p->getUses());\n    }\n\n    public function doUsesAs(FileComponentInterface $component): void\n    {\n        $p = new UsesAsParser($component);\n        $p->do();\n        $this->useTypes = array_merge($this->useTypes, $p->getUses());\n    }\n\n    public function doReturnType(FileComponentInterface $component): void\n    {\n        $p = new ReturnTypeParser($component);\n        $p->do();\n        $this->html = $p->getHtml();\n    }\n\n    public function doAttributes(FileComponentInterface $component): void\n    {\n        $p = new AttributesParser($component);\n        $p->do();\n        $this->attributes = $p->getResult();\n    }\n\n    public function doHeredoc(FileComponentInterface $component): void\n    {\n        $p = new HeredocParser($component);\n        $p->do();\n        $this->html = $p->getHtml();\n    }\n\n    public function doInlineCode(FileComponentInterface $component): void\n    {\n        $this->doHtml($component);\n        $text = $this->result;\n        $this->html = $component->getCode();\n\n        $p = new InlineCodeParser($component);\n        $p->do([\n            \"html\" => $text,\n            \"useVariables\" => $this->useVariables,\n        ]);\n        $phtml = $p->getResult();\n\n        $this->html = str_replace($text, $phtml, $this->html);\n\n        $this->useVariables = $p->getUseVariables();\n        $this->funcVariables = $p->getFuncVariables();\n    }\n\n    public function doHtml(FileComponentInterface $component): void\n    {\n        $p = new HtmlParser($component);\n        $p->do();\n        $this->result = $p->getResult();\n    }\n\n    public function getUseVariables(): ?array\n    {\n        return $this->useVariables;\n    }\n\n    public function getFuncVariables(): ?array\n    {\n        return $this->funcVariables;\n    }\n\n    public function doChildrenDeclaration(FileComponentInterface $component): void\n    {\n        $p = new ChildrenDeclarationParser($component);\n        $p->do();\n        $this->children = (object)$p->getResult();\n    }\n\n    public function doArrays(FileComponentInterface $component): void\n    {\n        $p = new ArraysParser($component);\n        $p->do($this->useVariables);\n        $this->useVariables = $p->getUseVariables();\n        $this->html = $p->getHtml();\n    }\n\n    public function doUseEffect(FileComponentInterface $component): void\n    {\n        $p = new UseEffectParser($component);\n        $p->do();\n        $this->html = $p->getHtml();\n    }\n\n    public function doUseVariables(FileComponentInterface $component): void\n    {\n        $p = new UseVariablesParser($component);\n        $p->do($this->useVariables);\n        $this->useVariables = $p->getUseVariables();\n        $this->html = $p->getHtml();\n    }\n\n    public function doModuleComponent(FileComponentInterface $component): void\n    {\n        $p = new ModuleComponentParser($component);\n        $p->do($this->useVariables);\n        $this->useVariables = $p->getUseVariables();\n    }\n\n    public function doNamespace(FileComponentInterface $component): void\n    {\n        $p = new NamespaceParser($component);\n        $p->do($component->getMotherUID());\n        $this->html = $p->getHtml();\n    }\n\n    public function doFragments(FileComponentInterface $component): void\n    {\n        $p = new FragmentsParser($component);\n        $p->do();\n        $this->html = $p->getHtml();\n    }\n\n    public function doClosedComponents(FileComponentInterface $component): void\n    {\n        $p = new ClosedComponentsParser($component, $this);\n        $p->do();\n        $this->componentList = $p->getResult();\n        $this->html = $p->getHtml();\n    }\n\n    public function doOpenComponents(FileComponentInterface $component): void\n    {\n        $p = new OpenComponentsParser($component, $this);\n        $p->do($this->useVariables);\n        $this->openComponentList = $p->getResult();\n        $this->html = $p->getHtml();\n    }\n\n    public function doEmptyComponents(FileComponentInterface $component): void\n    {\n        $p = new EmptyComponentsParser($component);\n        $p->do();\n        $this->html = $p->getHtml();\n        $this->result = $p->getResult();\n    }\n\n    public function doIncludes(FileComponentInterface $component): void\n    {\n        $componentList = array_unique(array_merge($this->componentList, $this->openComponentList));\n\n        ComponentRegistry::load();\n        $motherUID = $component->getMotherUID();\n\n        foreach ($componentList as $componentName) {\n            [$fqFunctionName, $cacheFilename] = $component->renderComponent($motherUID, $componentName);\n\n            $include = sprintf(ApplicationComponent::INCLUDE_PLACEHOLDER, $cacheFilename);\n\n            $re = '/(namespace +[\\w\\\\\\\\]+;)/m';\n            preg_match_all($re, $this->html, $matches, PREG_SET_ORDER, 0);\n\n            if (!isset($matches[0])) {\n                $re = '/(<\\?php)/m';\n            }\n\n            $subst = '$1' . PHP_EOL . '<Include />';\n            $this->html = preg_replace($re, $subst, $this->html, 1);\n\n            $this->html = str_replace('<Include />', $include, $this->html);\n        }\n    }\n}"}
{"instruction": "Write an Ephect PHP component", "input": "Based on Ephect source: ParserServiceInterface.php", "output": "<?php\n\nnamespace Ephect\\Modules\\Forms\\Generators;\n\ninterface ParserServiceInterface\n{\n    public function getHtml(): string;\n\n    public function getResult(): null|string|array|bool;\n\n    public function getFuncVariables(): ?array;\n\n    public function getUseVariables(): ?array;\n\n    public function getUses(): ?array;\n}"}
{"instruction": "Write an Ephect component", "input": "Based on Ephect source: RawHtmlParser.php", "output": "<?php\n\nnamespace Ephect\\Modules\\Forms\\Generators;\n\nuse Ephect\\Modules\\Forms\\Components\\ComponentEntity;\nuse Ephect\\Modules\\Forms\\Components\\ComponentStructure;\n\nclass RawHtmlParser implements RawHtmlParserInterface\n{\n    private array $list;\n\n    public function __construct(private readonly string $html)\n    {\n    }\n\n    public function doTag(string $tag): void\n    {\n        $parser = new ComponentParser($this->html);\n        $parser->doComponents($tag);\n        $this->list = $parser->getList();\n        unset($parser);\n    }\n\n    public function getOuterHtml(): array\n    {\n        $result = [];\n        if (count($this->list) === 0) {\n            return $result;\n        }\n        foreach ($this->list as $current) {\n            $struct = new ComponentStructure($current);\n            $entity = new ComponentEntity($struct);\n            $html = $current['text'] . PHP_EOL;\n            $html .= $entity->getInnerHTML() . PHP_EOL;\n            $html .= $current['closer']['text'] . PHP_EOL;\n\n            $result[] = $html;\n        }\n\n        return $result;\n    }\n\n    public function getInnerHtml(): array\n    {\n        $result = [];\n        if (count($this->list) === 0) {\n            return $result;\n        }\n        foreach ($this->list as $current) {\n            $struct = new ComponentStructure($current);\n            $entity = new ComponentEntity($struct);\n            $result[] = $entity->getInnerHTML();\n        }\n\n        return $result;\n    }\n}"}
{"instruction": "Write an Ephect PHP component", "input": "Based on Ephect source: RawHtmlParserInterface.php", "output": "<?php\n\nnamespace Ephect\\Modules\\Forms\\Generators;\n\ninterface RawHtmlParserInterface\n{\n    public function doTag(string $tag): void;\n\n    public function getInnerHtml(): array;\n\n    public function getOuterHtml(): array;\n}"}
{"instruction": "Write an Ephect PHP component", "input": "Based on Ephect source: TypesParserTrait.php", "output": "<?php\n\nnamespace Ephect\\Modules\\Forms\\Generators;\n\ntrait TypesParserTrait\n{\n    public function declareTypedVariables($item): string\n    {\n        $item = trim($item);\n        $item = str_replace('&', '', $item);\n        $name = substr($item, strpos($item, '$'));\n\n        if (strpos($item, '/* bool */') > -1) {\n            return $name . ' = false; ';\n        }\n        if (strpos($item, '/* int */') > -1) {\n            return $name . ' = 0; ';\n        }\n        if (strpos($item, '/* float */') > -1) {\n            return $name . ' = 0.0; ';\n        }\n        if (strpos($item, '/* real */') > -1) {\n            return $name . ' = 0.0; ';\n        }\n        if (strpos($item, '/* string */') > -1) {\n            return $name . ' = \\'\\'; ';\n        }\n        if (strpos($item, '/* array */') > -1) {\n            return $name . ' = []; ';\n        }\n\n        return $name . ' = null; ';\n    }\n\n    public function getDefaultValue($item): string\n    {\n        $item = trim($item);\n\n        $name = substr($item, strpos($item, '$') + 1);\n\n        if (strpos($item, '/* bool */') > -1) {\n            return \"'$name' => false\";\n        }\n        if (strpos($item, '/* int */') > -1) {\n            return \"'$name' => 0\";\n        }\n        if (strpos($item, '/* float */') > -1) {\n            return \"'$name' => 0.0\";\n        }\n        if (strpos($item, '/* real */') > -1) {\n            return \"'$name' => 0.0\";\n        }\n        if (strpos($item, '/* string */') > -1) {\n            return \"'$name' => ''\";\n        }\n        if (strpos($item, '/* array */') > -1) {\n            return \"'$name' => []\";\n        }\n\n        return \"'$name' => null\";\n    }\n}"}
{"instruction": "Write an Ephect component", "input": "Based on Ephect source: ComponentAttributesListener.php", "output": "<?php\n\nnamespace Ephect\\Modules\\Forms\\Listeners;\n\nuse Ephect\\Framework\\Event\\Event;\nuse Ephect\\Framework\\Event\\EventListenerInterface;\nuse Ephect\\Framework\\Logger\\Logger;\nuse Ephect\\Framework\\Middlewares\\AttributeMiddlewareInterface;\nuse Ephect\\Framework\\Registry\\FrameworkRegistry;\nuse Ephect\\Framework\\Registry\\StateRegistry;\nuse Ephect\\Modules\\Forms\\Components\\Component;\nuse Ephect\\Modules\\Forms\\Events\\ComponentAttributesEvent;\nuse Ephect\\Modules\\Forms\\Events\\ComponentFinishedEvent;\nuse Ephect\\Modules\\Forms\\Middlewares\\ComponentParserMiddlewareInterface;\nuse Ephect\\Modules\\Forms\\Registry\\ComponentRegistry;\n\nclass ComponentAttributesListener implements EventListenerInterface\n{\n    /**\n     * @param Event|ComponentAttributesEvent $event\n     * @return void\n     * @throws \\ReflectionException\n     */\n    public function __invoke(Event|ComponentAttributesEvent $event): void\n    {\n        $funcName = $event->getComponent()->getClass();\n\n        if ($funcName === Component::class) {\n            return;\n        }\n\n        $motherUID = $event->getMotherUID();\n        $filename = $event->getCacheFilename();\n\n        $decl = $event->getDeclaration();\n        $componentName = $decl->getName();\n\n        if ($componentName == 'FakeFragment') {\n            return;\n        }\n\n        if ($componentName == 'Fragment') {\n            return;\n        }\n\n        if ($componentName == 'Slot') {\n            return;\n        }\n\n        $attrs = $event->getAttributes();\n\n        $middlewaresList = [];\n        foreach ($attrs as $attr) {\n            if (!isset($attr['name'])) {\n                continue;\n            }\n\n            $attr = (object)$attr;\n\n            if (count($attr->arguments) > 0) {\n                $attrNew = new $attr->name(...$attr->arguments);\n            } else {\n                $attrNew = new $attr->name();\n            }\n\n            if ($attrNew instanceof AttributeMiddlewareInterface) {\n                $middlewaresList[$attr->name] = [\n                    $attr->arguments,\n                    $attrNew->getMiddlewares(),\n                ];\n            }\n        }\n\n        if (count($middlewaresList)) {\n            foreach ($middlewaresList as $key => $value) {\n                [$arguments, $middlewares] = $value;\n                foreach ($middlewares as $middlewareClass) {\n                    $middleware = new $middlewareClass();\n\n                    if ($middleware instanceof ComponentParserMiddlewareInterface) {\n                        $middleware->parse(null, $motherUID, $funcName, $event->getPropsToString(), $arguments);\n                    }\n\n                    StateRegistry::saveByMotherUid($motherUID, true);\n                }\n            }\n        }\n    }\n}"}
{"instruction": "Write an Ephect component", "input": "Based on Ephect source: ComponentFinishedListener.php", "output": "<?php\n\nnamespace Ephect\\Modules\\Forms\\Listeners;\n\nuse Ephect\\Framework\\Event\\Event;\nuse Ephect\\Framework\\Event\\EventListenerInterface;\nuse Ephect\\Modules\\Forms\\Events\\ComponentFinishedEvent;\n\nclass ComponentFinishedListener implements EventListenerInterface\n{\n    /**\n     * @param Event|ComponentFinishedEvent $event\n     * @return void\n     * @throws \\ReflectionException\n     */\n    public function __invoke(Event|ComponentFinishedEvent $event): void\n    {\n    }\n}"}
{"instruction": "Write an Ephect domain event", "input": "Based on Ephect source: PageFinishedListener.php", "output": "<?php\n\nnamespace Ephect\\Modules\\Forms\\Listeners;\n\nuse Ephect\\Framework\\Event\\Event;\nuse Ephect\\Framework\\Event\\EventListenerInterface;\nuse Ephect\\Modules\\Forms\\Events\\PageFinishedEvent;\n\nclass PageFinishedListener implements EventListenerInterface\n{\n    /**\n     * @param Event|PageFinishedEvent $event\n     * @return void\n     * @throws \\ReflectionException\n     */\n    public function __invoke(Event|PageFinishedEvent $event): void\n    {\n    }\n}"}
{"instruction": "Write an Ephect component", "input": "Based on Ephect source: ComponentParserMiddlewareInterface.php", "output": "<?php\n\nnamespace Ephect\\Modules\\Forms\\Middlewares;\n\nuse Ephect\\Modules\\Forms\\Components\\ComponentEntityInterface;\n\ninterface ComponentParserMiddlewareInterface\n{\n    public function parse(\n        ComponentEntityInterface|null $parent,\n        string $motherUID,\n        string $funcName,\n        string $props,\n        array $arguments\n    ): void;\n}"}
{"instruction": "Write an Ephect PHP component", "input": "Based on Ephect source: CacheRegistry.php", "output": "<?php\n\nnamespace Ephect\\Modules\\Forms\\Registry;\n\nuse Ephect\\Framework\\Registry\\AbstractStaticRegistry;\nuse Ephect\\Framework\\Registry\\RegistryInterface;\n\nclass CacheRegistry extends AbstractStaticRegistry\n{\n    private static ?CacheRegistry $instance = null;\n\n    public static function reset(): void\n    {\n        self::$instance = new CacheRegistry();\n        unlink(self::$instance->getCacheFilename());\n    }\n\n    public static function getInstance(): CacheRegistry\n    {\n        if (self::$instance === null) {\n            self::$instance = new CacheRegistry();\n        }\n\n        return self::$instance;\n    }\n}"}
{"instruction": "Write an Ephect PHP component", "input": "Based on Ephect source: CodeRegistry.php", "output": "<?php\n\nnamespace Ephect\\Modules\\Forms\\Registry;\n\nuse Ephect\\Framework\\Registry\\AbstractStaticRegistry;\nuse Ephect\\Framework\\Registry\\RegistryInterface;\n\nclass CodeRegistry extends AbstractStaticRegistry\n{\n    private static ?CodeRegistry $instance = null;\n\n    public static function reset(): void\n    {\n        self::$instance = new CodeRegistry();\n        unlink(self::$instance->getCacheFilename());\n    }\n\n    public static function getInstance(): CodeRegistry\n    {\n        if (self::$instance === null) {\n            self::$instance = new CodeRegistry();\n        }\n\n        return self::$instance;\n    }\n}"}
{"instruction": "Write an Ephect component", "input": "Based on Ephect source: ComponentRegistry.php", "output": "<?php\n\nnamespace Ephect\\Modules\\Forms\\Registry;\n\nuse Ephect\\Framework\\Registry\\AbstractStaticRegistry;\nuse Ephect\\Framework\\Registry\\RegistryInterface;\n\nclass ComponentRegistry extends AbstractStaticRegistry\n{\n    private static ?ComponentRegistry $instance = null;\n\n    public static function reset(): void\n    {\n        self::$instance = new ComponentRegistry();\n        unlink(self::$instance->getCacheFilename());\n    }\n\n    public static function getInstance(): ComponentRegistry\n    {\n        if (self::$instance === null) {\n            self::$instance = new ComponentRegistry();\n        }\n\n        return self::$instance;\n    }\n}"}
{"instruction": "Write an Ephect PHP component", "input": "Based on Ephect source: PluginRegistry.php", "output": "<?php\n\nnamespace Ephect\\Modules\\Forms\\Registry;\n\nuse Ephect\\Framework\\Registry\\AbstractStaticRegistry;\nuse Ephect\\Framework\\Registry\\RegistryInterface;\n\nclass PluginRegistry extends AbstractStaticRegistry\n{\n    private static ?PluginRegistry $instance = null;\n\n    public static function reset(): void\n    {\n        self::$instance = new PluginRegistry();\n        unlink(self::$instance->getCacheFilename());\n    }\n\n    public static function getInstance(): PluginRegistry\n    {\n        if (self::$instance === null) {\n            self::$instance = new PluginRegistry();\n        }\n\n        return self::$instance;\n    }\n\n\n}"}
{"instruction": "Write an Ephect PHP component", "input": "Based on Ephect source: UniqueCodeRegistry.php", "output": "<?php\n\nnamespace Ephect\\Modules\\Forms\\Registry;\n\nuse Ephect\\Framework\\Registry\\AbstractStaticRegistry;\nuse Ephect\\Framework\\Registry\\RegistryInterface;\n\nclass UniqueCodeRegistry extends AbstractStaticRegistry\n{\n    private static ?UniqueCodeRegistry $instance = null;\n\n    public static function reset(): void\n    {\n        self::$instance = new UniqueCodeRegistry();\n        unlink(self::$instance->getCacheFilename());\n    }\n\n    public static function getInstance(): UniqueCodeRegistry\n    {\n        if (self::$instance === null) {\n            self::$instance = new UniqueCodeRegistry();\n        }\n\n        return self::$instance;\n    }\n}"}
{"instruction": "Write an Ephect component", "input": "Based on Ephect source: HtmlSaverService.php", "output": "<?php\n\nnamespace Ephect\\Modules\\Forms\\Services;\n\nuse DateTime;\nuse Ephect\\Framework\\Utils\\File;\nuse Ephect\\Modules\\Forms\\Components\\ChildrenInterface;\n\nclass HtmlSaverService implements HtmlSaverServiceInterface\n{\n    public function __construct(private readonly ChildrenInterface $children)\n    {\n    }\n\n    public function canRefresh(): bool\n    {\n        $canRefresh = $this->children->getAttribute('refresh') ?? false;\n\n        return $canRefresh;\n    }\n\n    public function canRender(): bool\n    {\n        $canRender = $this->children->getAttribute('render') ?? true;\n\n        return $canRender;\n    }\n\n    public function isPending(): bool\n    {\n        return file_exists(\\Constants::BUILD_DIR . $this->children->getName() . '.pending' . \\Constants::TXT_EXTENSION);\n    }\n\n    public function markAsPending(): void\n    {\n        $date = new DateTime();\n        $timestamp = $date->getTimestamp();\n        $pendingTxt = \\Constants::BUILD_DIR . $this->children->getName() . '.pending' . \\Constants::TXT_EXTENSION;\n        File::safeWrite($pendingTxt, \"const time = $timestamp\");\n    }\n\n    public function storeHTML(string $html): void\n    {\n        $name = $this->children->getName();\n        $finalHTML = \\Constants::DOCUMENT_ROOT . $name . DIRECTORY_SEPARATOR . $name . \\Constants::HTML_EXTENSION;\n        File::safeWrite($finalHTML, $html);\n    }\n}"}
{"instruction": "Write an Ephect PHP component", "input": "Based on Ephect source: HtmlSaverServiceInterface.php", "output": "<?php\n\nnamespace Ephect\\Modules\\Forms\\Services;\n\ninterface HtmlSaverServiceInterface\n{\n    public function canRender(): bool;\n\n    public function isPending(): bool;\n\n    public function markAsPending(): void;\n\n    public function storeHTML(string $html): void;\n\n}"}
{"instruction": "Write an Ephect PHP component", "input": "Based on Ephect source: PropsValidator.php", "output": "<?php\n\nnamespace Ephect\\Modules\\Forms\\Validators;\n\nuse Ephect\\Framework\\Structure\\Structure;\nuse ErrorException;\nuse Exception;\n\nclass PropsValidator\n{\n    protected object $props;\n    protected string $structClass;\n\n    public function __construct(object $props, string $structClass)\n    {\n        $this->props = $props;\n        $this->structClass = $structClass;\n    }\n\n    /**\n     * @throws ErrorException\n     */\n    public function validate(): ?Structure\n    {\n        $result = null;\n\n        $structClass = $this->structClass;\n\n        try {\n            $result = new $structClass($this->props);\n        } catch (Exception $ex) {\n            throw new ErrorException(\"Invalid structure.\", 1, 3, __FILE__, __LINE__, $ex);\n        }\n\n        return $result;\n    }\n}"}
{"instruction": "Write an Ephect component", "input": "Based on Ephect source: AbstractComponentParser.php", "output": "<?php\n\nnamespace Ephect\\Modules\\Forms\\Generators\\TokenParsers;\n\nuse Ephect\\Framework\\Middlewares\\AttributeMiddlewareInterface;\nuse Ephect\\Framework\\Registry\\StateRegistry;\nuse Ephect\\Framework\\Utils\\Text;\nuse Ephect\\Modules\\Forms\\Components\\ComponentDeclarationInterface;\nuse Ephect\\Modules\\Forms\\Components\\ComponentEntityInterface;\nuse Ephect\\Modules\\Forms\\Middlewares\\ComponentParserMiddlewareInterface;\n\nabstract class AbstractComponentParser extends AbstractTokenParser\n{\n    public static function doArgumentsToString(array $componentArgs): ?string\n    {\n        $result = '';\n\n        foreach ($componentArgs as $key => $value) {\n            if (is_array($value)) {\n                $arrayString = Text::arrayToString($value);\n                $pair = '\"' . $key . '\" => ' . $arrayString . ', ';\n            } else {\n                $pair = '\"' . $key . '\" => ' . (\n                    addslashes($value) != $value\n                    ? \"'\" . addslashes($value) . \"', \"\n                    : \"'\" . $value . \"', \"\n                );\n            }\n            if ($value[0] === '$') {\n                $pair = '\"' . $key . '\" => ' . $value . ', ';\n            }\n            $result .= $pair;\n        }\n        return ($result === '') ? null : '[' . $result . ']';\n    }\n\n    abstract public function do(object|array|string|null $parameter = null): void;\n\n    /**\n     * @throws \\ReflectionException\n     */\n    public function declareMiddlewares(\n        string $motherUID,\n        ComponentEntityInterface|null $parent,\n        ?ComponentDeclarationInterface $declaration,\n        string $fqItemName,\n        string $props\n    ): void {\n\n        /**\n         * Mandatory test: Parent is not always null!\n         */\n        if ($parent == null || $declaration == null || !$declaration->hasAttributes()) {\n            return;\n        }\n\n        $attrs = $declaration->getAttributes();\n\n        $middlewaresList = [];\n        foreach ($attrs as $attr) {\n            if (!isset($attr['name'])) {\n                continue;\n            }\n\n            $attr = (object)$attr;\n\n            if (count($attr->arguments) > 0) {\n                $attrNew = new $attr->name(...$attr->arguments);\n            } else {\n                $attrNew = new $attr->name();\n            }\n\n            if ($attrNew instanceof AttributeMiddlewareInterface) {\n                $middlewaresList[$attr->name] = [\n                    $attr->arguments,\n                    $attrNew->getMiddlewares(),\n                ];\n            }\n        }\n\n        if (count($middlewaresList)) {\n            foreach ($middlewaresList as $key => $value) {\n                [$arguments, $middlewares] = $value;\n                foreach ($middlewares as $middlewareClass) {\n                    $middleware = new $middlewareClass();\n                    if ($middleware instanceof ComponentParserMiddlewareInterface) {\n                        $middleware->parse($parent, $motherUID, $fqItemName, $props, $arguments);\n                    }\n\n                    StateRegistry::saveByMotherUid($motherUID, true);\n                }\n            }\n        }\n    }\n}"}
{"instruction": "Write an Ephect component", "input": "Based on Ephect source: AbstractTokenParser.php", "output": "<?php\n\nnamespace Ephect\\Modules\\Forms\\Generators\\TokenParsers;\n\nuse Ephect\\Modules\\Forms\\Components\\FileComponentInterface;\nuse Ephect\\Modules\\Forms\\Registry\\CodeRegistry;\nuse Ephect\\Modules\\Forms\\Generators\\ParserServiceInterface;\n\nabstract class AbstractTokenParser implements TokenParserInterface\n{\n    protected ?string $html = '';\n    protected ?FileComponentInterface $component = null;\n    protected string|array|bool|null $result = null;\n    protected array $funcVariables = [];\n    protected array $useVariables = [];\n    protected array $useTypes = [];\n    protected ?ParserServiceInterface $parent = null;\n\n    public function __construct(FileComponentInterface $comp, ?ParserServiceInterface $parent = null)\n    {\n        $this->parent = $parent;\n        $this->component = $comp;\n        $this->html = $comp->getCode();\n    }\n\n    public function getHtml(): string\n    {\n        return $this->html;\n    }\n\n    public function getResult(): null|string|array|bool\n    {\n        return $this->result;\n    }\n\n    public function getFuncVariables(): ?array\n    {\n        return $this->funcVariables;\n    }\n\n    public function getUseVariables(): ?array\n    {\n        return $this->useVariables;\n    }\n\n    public function getUses(): ?array\n    {\n        return $this->useTypes;\n    }\n\n    public function doCache(): bool\n    {\n        return CodeRegistry::save();\n    }\n\n    public function doUncache(): bool\n    {\n        CodeRegistry::setCacheDirectory(\\Constants::BUILD_DIR . $this->component->getMotherUID());\n        return CodeRegistry::load();\n    }\n\n    abstract public function do(null|string|array|object $parameter = null): void;\n}"}
{"instruction": "Write an Ephect PHP component", "input": "Based on Ephect source: ArgumentsParser.php", "output": "<?php\n\nnamespace Ephect\\Modules\\Forms\\Generators\\TokenParsers;\n\nfinal class ArgumentsParser extends AbstractTokenParser\n{\n    public function do(null|string|array|object $parameter = null): void\n    {\n        $componentArgs = $parameter;\n\n        $re = '/([A-Za-z0-9_-]+)(\\[\\])?=(\\\"([\\S ][^\"]*)\\\"|\\'([\\S]*)\\'|\\{\\{ ([\\w]*) \\}\\}|\\{([\\S ]*)\\})/m';\n        $re = '/([A-Za-z0-9_-]+)(\\[\\])?=([\\\"\\{]([\\S ][^\\\"\\}]*)[\\\"\\}])/m';\n\n        preg_match_all($re, $componentArgs, $matches, PREG_SET_ORDER, 0);\n\n        foreach ($matches as $match) {\n            $key = $match[1];\n            $value = substr(substr($match[3], 1), 0, -1);\n            $value = $match[3][0] == '{' ? $$value : $value;\n\n            if (isset($match[2]) && $match[2] === '[]') {\n                if (!isset($result[$key])) {\n                    $result[$key] = [];\n                }\n                $result[$key][] = $value;\n            } else {\n                $result[$key] = $value;\n            }\n        }\n    }\n\n}"}
{"instruction": "Write an Ephect PHP component", "input": "Based on Ephect source: ArraysParser.php", "output": "<?php\n\nnamespace Ephect\\Modules\\Forms\\Generators\\TokenParsers;\n\nfinal class ArraysParser extends AbstractTokenParser\n{\n    public function do(null|string|array|object $parameter = null): void\n    {\n        $this->useVariables = $parameter;\n\n        $re = '/\\{\\{ \\.\\.\\.([a-z0-9_\\->]*) }}/m';\n        $str = $this->html;\n\n        preg_match_all($re, $str, $matches, PREG_SET_ORDER, 0);\n\n        foreach ($matches as $match) {\n            $variable = $match[1];\n\n            $useVar = $variable;\n            $arrowPos = strpos($variable, '->');\n            if ($arrowPos > -1) {\n                $useVar = substr($useVar, 0, $arrowPos);\n            }\n\n            $this->useVariables[$useVar] = '$' . $useVar;\n\n            if ($variable === 'children') {\n                continue;\n            }\n\n            $this->html = str_replace('{{ ...' . $variable . ' }}', '<?php echo print_r($' . $variable . ', true) ?>', $this->html);\n        }\n    }\n\n}"}
{"instruction": "Write an Ephect PHP component", "input": "Based on Ephect source: AttributesParser.php", "output": "<?php\n\nnamespace Ephect\\Modules\\Forms\\Generators\\TokenParsers;\n\nfinal class AttributesParser extends AbstractTokenParser\n{\n    public function do(null|string|array|object $parameter = null): void\n    {\n        $this->result = [];\n\n        $re = '/(#\\[(\\w+)\\(.*\\)])/m';\n        preg_match_all($re, $this->html, $matches, PREG_SET_ORDER, 0);\n\n        foreach ($matches as $match) {\n            $this->result[] = $match[2];\n        }\n    }\n}"}
{"instruction": "Write an Ephect component", "input": "Based on Ephect source: ChildSlotsParser.php", "output": "<?php\n\nnamespace Ephect\\Modules\\Forms\\Generators\\TokenParsers;\n\nuse Ephect\\Framework\\Utils\\File;\nuse Ephect\\Modules\\Forms\\Components\\Component;\nuse Ephect\\Modules\\Forms\\Registry\\ComponentRegistry;\nuse Ephect\\Modules\\Forms\\Generators\\ComponentDocument;\n\nclass ChildSlotsParser extends AbstractTokenParser\n{\n    public function do(null|string|array|object $parameter = null): void\n    {\n        ComponentRegistry::load();\n\n        $motherUID = $this->component->getMotherUID();\n        $doc = new ComponentDocument($this->component);\n        $doc->matchAll();\n\n        $firstMatch = $doc->getNextMatch();\n        if ($firstMatch === null || !$firstMatch->hasCloser()) {\n            $this->result = null;\n            return;\n        }\n\n        $functionName = $firstMatch->getName();\n\n        $parentComponent = new Component($functionName, $motherUID);\n        if (!$parentComponent->load()) {\n            $this->result = null;\n            return;\n        }\n\n        $parentFilename = $parentComponent->getSourceFilename();\n        $parentDoc = new ComponentDocument($parentComponent);\n        $parentDoc->matchAll();\n\n        $parentHtml = $parentDoc->replaceMatches($doc, $this->html);\n\n        if ($parentHtml !== '') {\n            File::safeWrite(\\Constants::BUILD_DIR . $motherUID . DIRECTORY_SEPARATOR . $parentFilename, $parentHtml);\n            File::safeWrite(\\Constants::BUILD_DIR . $motherUID . DIRECTORY_SEPARATOR . $this->component->getSourceFilename(), $this->html);\n        }\n\n        if ($doc->getCount() > 0) {\n            ComponentRegistry::save();\n        }\n\n        $this->result = $parentFilename;\n    }\n}"}
{"instruction": "Write an Ephect PHP component", "input": "Based on Ephect source: ChildrenDeclarationParser.php", "output": "<?php\n\nnamespace Ephect\\Modules\\Forms\\Generators\\TokenParsers;\n\nfinal class ChildrenDeclarationParser extends AbstractTokenParser\n{\n    public function do(null|string|array|object $parameter = null): void\n    {\n        $subject = $this->html;\n\n        $re = '/(function([\\w ]+)\\(\\$([\\w]+)[^\\)]*\\)(\\s|.)+?(\\{))(\\s|.)+?(\\{\\{ \\3 \\}\\})/';\n        preg_match_all($re, $subject, $matches, PREG_SET_ORDER, 0);\n\n        foreach ($matches as $match) {\n\n            $functionDeclaration = $match[1];\n            $componentName = $match[2];\n            $variable = $match[7];\n\n            $this->result = ['declaration' => $functionDeclaration, 'component' => $componentName, 'variable' => $variable];\n        }\n\n    }\n\n}"}
{"instruction": "Write an Ephect component", "input": "Based on Ephect source: ClosedComponentsParser.php", "output": "<?php\n\nnamespace Ephect\\Modules\\Forms\\Generators\\TokenParsers;\n\nuse Ephect\\Framework\\Utils\\File;\nuse Ephect\\Modules\\Forms\\Components\\ComponentDeclaration;\nuse Ephect\\Modules\\Forms\\Components\\ComponentEntityInterface;\nuse Ephect\\Modules\\Forms\\Registry\\ComponentRegistry;\n\nfinal class ClosedComponentsParser extends AbstractComponentParser\n{\n    /**\n     * @throws \\ReflectionException\n     */\n    public function do(null|string|array|object $parameter = null): void\n    {\n        $this->result = [];\n        $this->useTypes = $this->parent ? $this->parent->getUses() : [];\n\n        $comp = $this->component;\n        $decl = $comp->getDeclaration();\n        // First level entity\n        $fle = $decl->getComposition();\n\n        $parent = null;\n        $child = null;\n        if ($parameter != null) {\n            [$parent, $child] = $parameter;\n        }\n        $motherUID = $comp->getMotherUID();\n\n        if ($fle === null) {\n            return;\n        }\n        $props = $this->doArgumentsToString($decl->getArguments()) ?? '';\n\n        if ($decl->hasAttributes()) {\n            $this->declareMiddlewares(\n                $motherUID,\n                $parent,\n                $decl,\n                $this->component->getFullyQualifiedFunction(),\n                $props,\n            );\n        }\n\n        $subject = $this->html;\n\n        /**\n         * @throws \\ReflectionException\n         */\n        $closure = function (\n            ComponentEntityInterface $child,\n            int $index\n        ) use (\n            &$subject,\n            &$result,\n            $parent,\n            $motherUID\n        ) {\n\n            if ($child->hasCloser()) {\n                return;\n            }\n\n            $uid = $child->getUID();\n            $component = $child->getText();\n            $componentName = $child->getName();\n            $componentArgs = [];\n            $componentArgs['uid'] = $uid;\n\n            $props = '';\n            if ($child->props() !== null) {\n                $componentArgs = array_merge($componentArgs, $child->props());\n                $propsArgs = self::doArgumentsToString($componentArgs);\n                $props = \"(object) \" . $propsArgs ?? \"[]\";\n            }\n\n            $fqFuncName = ComponentRegistry::read($componentName);\n            $componentRender = \"\\t\\t\\t<?php \\$fn = {$componentName}($props); \\$fn(); ?>\\n\";\n\n            $subject = str_replace($component, $componentRender, $subject);\n\n            $filename = $this->component->getSourceFilename();\n            File::safeWrite(\n                \\Constants::BUILD_DIR . $this->component->getMotherUID() . DIRECTORY_SEPARATOR . $filename,\n                $subject\n            );\n\n            $decl = ComponentDeclaration::byName($fqFuncName);\n            $this->declareMiddlewares($motherUID, $parent, $decl, $fqFuncName, $props);\n\n            $this->result[] = $componentName;\n\n            /**\n             * TODO Make a listener for this feature\n             * $attributesEvent = new ComponentAttributesEvent($this->component, $child);\n             * $dispatcher = new EventDispatcher();\n             * $dispatcher->dispatch($attributesEvent);\n             */\n        };\n\n        if ($child != null) {\n            $closure($child, 0);\n        } elseif (!$fle->hasChildren()) {\n            $closure($fle, 0);\n        } elseif ($fle->hasChildren()) {\n            $fle->forEach($closure, $fle);\n        }\n\n        $this->html = $subject;\n    }\n}"}
{"instruction": "Write an Ephect component", "input": "Based on Ephect source: EmptyComponentsParser.php", "output": "<?php\n\nnamespace Ephect\\Modules\\Forms\\Generators\\TokenParsers;\n\nclass EmptyComponentsParser extends AbstractTokenParser\n{\n    public function do(null|string|array|object $parameter = null): void\n    {\n        $this->result = false;\n\n        // To match any case, but must be tested before use to replace\n        $re = '/<([A-Z]\\w+)((\\s[^\\w\\>]|.*?)*)\\>((\\s|.?)*?)(<\\/\\1>)/';\n\n        $subject = $this->html;\n\n        preg_match_all($re, $subject, $matches, PREG_SET_ORDER, 0);\n\n        foreach ($matches as $match) {\n            $contents = trim($match[4]);\n            if ($contents === '') {\n                $this->result = true;\n                $subst = '<$1$2/>';\n                $tag = $match[1];\n                $re = <<< REGEX\n                /<({$tag})((\\s[^\\w\\>]|.*?)*)\\>((\\s|.?)*?)(<\\/{$tag}>)/\n                REGEX;\n\n                // Replace only the first occurrence of $tag\n                $this->html = preg_replace($re, $subst, $subject, 1);\n            }\n\n        }\n\n    }\n}"}
{"instruction": "Write an Ephect PHP component", "input": "Based on Ephect source: FragmentsParser.php", "output": "<?php\n\nnamespace Ephect\\Modules\\Forms\\Generators\\TokenParsers;\n\nfinal class FragmentsParser extends AbstractTokenParser\n{\n    public function do(null|string|array|object $parameter = null): void\n    {\n        $this->html = str_replace('<>', '', $this->html);\n        $this->html = str_replace('</>', '', $this->html);\n\n    }\n\n}"}
{"instruction": "Write an Ephect PHP component", "input": "Based on Ephect source: HeredocParser.php", "output": "<?php\n\nnamespace Ephect\\Modules\\Forms\\Generators\\TokenParsers;\n\nfinal class HeredocParser extends AbstractTokenParser\n{\n    public function do(null|string|array|object $parameter = null): void\n    {\n        $re = '/(<<<[ ]*(HTML|html))/';\n\n        $subst = '<<< \\\\2';\n\n        $str = $this->html;\n\n        $this->html = preg_replace($re, $subst, $str);\n    }\n\n}"}
{"instruction": "Write an Ephect PHP component", "input": "Based on Ephect source: HtmlParser.php", "output": "<?php\n\nnamespace Ephect\\Modules\\Forms\\Generators\\TokenParsers;\n\nfinal class HtmlParser extends AbstractTokenParser\n{\n    public function do(null|string|array|object $parameter = null): void\n    {\n        $subject = $this->html;\n\n        $re = '/return \\(<<< ?HTML((.|\\s|\\R)+)HTML\\);/m';\n        preg_match_all($re, $subject, $matches, PREG_SET_ORDER, 0);\n\n        $this->result = !isset($matches[0]) ? '' : $matches[0][1];\n    }\n\n}"}
{"instruction": "Write an Ephect component", "input": "Based on Ephect source: ModuleComponentParser.php", "output": "<?php\n\nnamespace Ephect\\Modules\\Forms\\Generators\\TokenParsers;\n\nfinal class ModuleComponentParser extends AbstractTokenParser\n{\n    public function do(null|string|array|object $parameter = null): void\n    {\n        $this->useVariables = $parameter;\n\n        $re = '/function[\\w ]+\\((\\$slot)\\)/m';\n        $str = $this->html;\n\n        preg_match_all($re, $str, $matches, PREG_SET_ORDER, 0);\n\n        $match = $matches[0] ?? null;\n        if ($match && $match[1] === '$slot') {\n            $this->useVariables['slot'] = '$slot';\n        }\n    }\n\n}"}
{"instruction": "Write an Ephect component", "input": "Based on Ephect source: MotherSlotsParser.php", "output": "<?php\n\nnamespace Ephect\\Modules\\Forms\\Generators\\TokenParsers;\n\nuse Ephect\\Framework\\Utils\\File;\nuse Ephect\\Modules\\Forms\\Components\\Component;\nuse Ephect\\Modules\\Forms\\Registry\\ComponentRegistry;\nuse Ephect\\Modules\\Forms\\Generators\\ComponentDocument;\n\n/** @deprecated It's useless for now */\nclass MotherSlotsParser extends AbstractTokenParser\n{\n    public function do(null|string|array|object $parameter = null): void\n    {\n\n        $slotParser = new UseSlotParser($this->component, $this->parent);\n        $slotParser->do();\n\n        [$source, $dest] = $slotParser->getResult();\n\n        if ($source === \"\" || $source === null) {\n            return;\n        }\n\n        ComponentRegistry::load();\n\n        $motherUID = $this->component->getMotherUID();\n        $doc = new ComponentDocument($this->component);\n        $doc->matchAll();\n\n        $firstMatch = $doc->getNextMatch();\n        if ($firstMatch === null || !$firstMatch->hasCloser()) {\n            $this->result = null;\n            return;\n        }\n\n        $functionName = $firstMatch->getName();\n\n        $parentComponent = new Component($functionName, $motherUID);\n        if (!$parentComponent->load()) {\n            $this->result = null;\n            return;\n        }\n\n        $parentNamespace = \"namespace \" . $parentComponent->getNamespace() . \";\\n\";\n        $parentFilename = $parentComponent->getSourceFilename();\n        $functionFilename = $parentFilename;\n        $parentDoc = new ComponentDocument($parentComponent);\n        $parentDoc->matchAll();\n\n        $parentHtml = $parentDoc->replaceMatches($doc, $this->html);\n\n        $decl0 = $parentNamespace;\n        $decl1 = substr($parentHtml, 0, $parentComponent->getBodyStart() + 1);\n        $decl3 = substr($parentHtml, $parentComponent->getBodyStart() + 1);\n\n        // Remove useSlot from child component\n        if ($dest !== \"\" && $dest !== null) {\n            $this->html = str_replace($source, \"\", $this->html);\n\n            $uses = '';\n            if (count($this->parent->getUses())) {\n                foreach ($this->parent->getUses() as $use) {\n                    $uses .= \"\\tuse \" . $use . \";\\n\";\n                }\n\n                $uses = \"\\n\" . $uses;\n            }\n\n            $decl0 .= $uses;\n\n            $decl1 = str_replace($parentNamespace, $decl0, $decl1);\n\n            // Add useSlot in mother component\n            $parentHtml = $decl1 . \"\\n\\t\" . $dest . \"\\n\" . $decl3;\n        }\n\n        if ($parentHtml !== '') {\n            File::safeWrite(\\Constants::BUILD_DIR . $motherUID . DIRECTORY_SEPARATOR . $parentFilename, $parentHtml);\n            File::safeWrite(\\Constants::BUILD_DIR . $motherUID . DIRECTORY_SEPARATOR . $this->component->getSourceFilename(), $this->html);\n        }\n\n        if ($doc->getCount() > 0) {\n            ComponentRegistry::save();\n        }\n\n        $this->result = $functionFilename;\n\n    }\n}"}
{"instruction": "Write an Ephect PHP component", "input": "Based on Ephect source: NamespaceParser.php", "output": "<?php\n\nnamespace Ephect\\Modules\\Forms\\Generators\\TokenParsers;\n\nfinal class NamespaceParser extends AbstractTokenParser\n{\n    public function do(null|string|array|object $parameter = null): void\n    {\n        $re = '/namespace( +)(\\w+)( +)?;( +)?/';\n        $subst = 'namespace \\\\2;';\n        //        $subst = 'namespace ' . \"$parameter\\\\\\\\\" . '\\\\2;';\n\n        $str = $this->html;\n\n        $this->html = preg_replace($re, $subst, $str);\n    }\n\n}"}
{"instruction": "Write an Ephect component", "input": "Based on Ephect source: OpenComponentsParser.php", "output": "<?php\n\nnamespace Ephect\\Modules\\Forms\\Generators\\TokenParsers;\n\nuse Ephect\\Framework\\Utils\\File;\nuse Ephect\\Modules\\Forms\\Components\\ComponentDeclaration;\nuse Ephect\\Modules\\Forms\\Components\\ComponentEntityInterface;\nuse Ephect\\Modules\\Forms\\Registry\\ComponentRegistry;\n\nfinal class OpenComponentsParser extends AbstractComponentParser\n{\n    public function do(null|string|array|object $parameter = null): void\n    {\n        $this->result = [];\n        $this->useVariables = $parameter;\n        $this->useTypes = $this->parent ? $this->parent->getUses() : [];\n\n        $comp = $this->component;\n        $comp->resetDeclaration();\n        $decl = $comp->getDeclaration();\n        $cmpz = $decl->getComposition();\n\n        if ($cmpz === null || !$cmpz->hasCloser()) {\n            return;\n        }\n\n        $props = $this->doArgumentsToString($decl->getArguments()) ?? '';\n\n        if ($decl->hasAttributes()) {\n            $this->declareMiddlewares(\n                $this->component->getMotherUID(),\n                null,\n                $decl,\n                $this->component->getFullyQualifiedFunction(),\n                $props,\n            );\n        }\n\n        $subject = $this->html;\n\n        $previous = null;\n\n        /**\n         * @throws \\ReflectionException\n         */\n        $closure = function (\n            ComponentEntityInterface $item,\n            int $index\n        ) use (\n            $comp,\n            &$subject,\n            &$result,\n            &$previous,\n            &$parent\n        ) {\n            $parent = $previous !== null && $previous->getDepth() < $item->getDepth() ? $previous : null;\n\n            if (!$item->hasCloser()) {\n                /**\n                 * Mandatory for middleware parsing...\n                 */\n                $p = new ClosedComponentsParser($comp);\n                $p->do([$parent, $item]);\n                return;\n            }\n            $uid = $item->getUID();\n\n            $opener = $item->getText();\n            $theCloser = (object)$item->getCloser();\n            $closer = $theCloser->text;\n            $componentName = $item->getName();\n            $componentBody = $item->getContents($subject);\n\n            $componentArgs = $this->useVariables;\n            $componentArgs = $item->props() !== null ? array_merge($componentArgs, $item->props()) : $componentArgs;\n\n            if ($componentName == 'FakeFragment') {\n                return;\n            }\n\n            if ($componentName == 'Fragment') {\n                return;\n            }\n\n            if ($componentName == 'Slot') {\n                return;\n            }\n\n            $motherUID = $this->component->getMotherUID();\n            $decl = $this->component->getDeclaration();\n            $props = self::doArgumentsToString($componentArgs) ?? \"[]\";\n\n            $propsKeys = $this->argumentsKeys($this->useVariables);\n\n            $useChildren = $decl->hasArguments() || count($propsKeys) ? $this->useArguments($propsKeys) : ' ';\n\n            $className = $this->component->getFullyQualifiedFunction() ?: $componentName;\n            $name = $this->component->getFunction() ?: $componentName;\n            $classArgs = '[]';\n\n            $fqComponentName = ComponentRegistry::read($componentName);\n\n            $preComponentBody = '';\n            $pkey = '$children';\n            if (count($propsKeys) === 1 && ($propsKeys[0] === $pkey || $propsKeys[0] === '$slot')) {\n                $pkey = $propsKeys[0];\n                $preComponentBody = <<<PHP\n            <?php if (method_exists({$pkey}, 'props')) {\n                \\$props = {$pkey}->props();\n                foreach(\\$props as \\$key => \\$value) {\n                    $\\$key = \\$value;\n                }\n            } ?>\nPHP;\n            }\n\n            $componentRender = <<< PHP\n            <?php \\$struct = new \\\\Ephect\\\\Modules\\\\Forms\\\\Components\\\\ChildrenStructure(['props' => (object) $props, 'buffer' => function()$useChildren{?>\n                    $preComponentBody$componentBody\n            <?php\n            }, 'motherUID' => '$motherUID', 'uid' => '$uid', 'class' => '$className', 'name' => '$name', 'parentProps' => $classArgs]);\n            {$pkey} = new \\\\Ephect\\\\Modules\\\\Forms\\\\Components\\\\Children(\\$struct);\n            \\$fn = $componentName({$pkey}); \\$fn(); \n            ?>\n            PHP;\n\n            $preg_opener = preg_quote($opener, '/');\n            $preg_closer = preg_quote($closer, '/');\n\n            preg_match('/(' . $preg_opener . ')/', $subject, $matches, PREG_OFFSET_CAPTURE);\n            $startsAt = intval($matches[0][1]);\n            $offset = $startsAt + strlen($opener) + strlen($componentBody);\n\n            preg_match('/(' . $preg_closer . ')/', $subject, $matches, PREG_OFFSET_CAPTURE, $offset);\n            $endsAt = intval($matches[0][1]);\n            $length = $endsAt - $startsAt + strlen($closer);\n\n            $outerComponentBody = substr($subject, $startsAt, $length);\n            $subject = str_replace($outerComponentBody, $componentRender, $subject);\n\n            $filename = $this->component->getSourceFilename();\n            File::safeWrite(\\Constants::BUILD_DIR . $this->component->getMotherUID() . DIRECTORY_SEPARATOR . $filename, $subject);\n\n            $this->result[] = $componentName;\n\n            $decl = ComponentDeclaration::byName($fqComponentName);\n            $this->declareMiddlewares($motherUID, $parent, $decl, $fqComponentName, $props);\n            /**\n             * TODO Make a listener for this feature\n             * $attributesEvent = new ComponentAttributesEvent($this->component, $item);\n             * $dispatcher = new EventDispatcher();\n             * $dispatcher->dispatch($attributesEvent);\n             */\n\n            $previous = $item;\n        };\n\n        $closure($cmpz, 0);\n        if ($cmpz->hasChildren()) {\n            $parent = $cmpz;\n            $cmpz->forEach($closure, $cmpz);\n        }\n\n        $this->html = $subject;\n    }\n\n\n\n    private function argumentsKeys(array $componentArgs): ?array\n    {\n        $result = [];\n\n        foreach ($componentArgs as $key => $value) {\n            $result[] = \"\\$\" . $key;\n        }\n\n        return $result;\n    }\n\n    private function useArguments(array $argumentsKeys): ?string\n    {\n        $result = '';\n\n        $args = implode(', ', $argumentsKeys);\n        if ($args === '') {\n            return ' ';\n        }\n\n        return \" use (\" . $args . \")\";\n    }\n}"}
{"instruction": "Write an Ephect PHP component", "input": "Based on Ephect source: ReturnTypeParser.php", "output": "<?php\n\nnamespace Ephect\\Modules\\Forms\\Generators\\TokenParsers;\n\nfinal class ReturnTypeParser extends AbstractTokenParser\n{\n    public function do(null|string|array|object $parameter = null): void\n    {\n        //        $re = '/((function) ([\\w]+)(\\([\\w\\W]*\\))(:( +)?string))/';\n        $re = '/namespace *?([\\w\\\\\\\\]+);([\\w\\W\\\\\\\\]*)function *?([$\\w]+)\\(([\\w\\W]*)\\)(\\W*):? *?(\\w+)?(\\W*)(\\{)/U';\n\n        //        $subst = \"$2 $3$4: \\\\Closure\";\n        $subst = \"namespace $1;$2function $3($4): \\\\Closure$7$8\";\n\n        $this->html = preg_replace($re, $subst, $this->html, 1);\n    }\n}"}
{"instruction": "Write an Ephect PHP component", "input": "Based on Ephect source: TokenParserInterface.php", "output": "<?php\n\nnamespace Ephect\\Modules\\Forms\\Generators\\TokenParsers;\n\nuse Ephect\\Modules\\Forms\\Generators\\ParserServiceInterface;\n\ninterface TokenParserInterface extends ParserServiceInterface\n{\n    public function doCache(): bool;\n\n    public function doUncache(): bool;\n\n    public function do(null|string|array|object $parameter = null): void;\n}"}
{"instruction": "Write an Ephect PHP component", "input": "Based on Ephect source: UseEffectParser.php", "output": "<?php\n\nnamespace Ephect\\Modules\\Forms\\Generators\\TokenParsers;\n\nuse Ephect\\Modules\\Forms\\Generators\\TypesParserTrait;\n\nfinal class UseEffectParser extends AbstractTokenParser\n{\n    use TypesParserTrait;\n\n    public function do(null|string|array|object $parameter = null): void\n    {\n        if (!strpos($this->html, 'useEffect')) {\n            return;\n        }\n\n        $this->doTranslation($parameter);\n        $this->doDeclaration($parameter);\n    }\n\n    private function doTranslation(null|string|array $parameter = null): void\n    {\n        $re = '/useEffect\\(function[ ]*\\(((\\$props|\\$children|\\$slot),[ ]*)?((\\s|.*?)+)\\)[ ]+(use[ ]*\\(((\\s|.*?)+)\\)[ ]*)?{((\\s|.*?)+)}\\);/m';\n\n        $str = $this->html;\n        preg_match_all($re, $str, $matches, PREG_SET_ORDER, 0);\n\n        $params = count($matches) === 0 ?: !isset($matches[0][3]) ?: $matches[0][3];\n        $uses = count($matches) === 0 ?: !isset($matches[0][6]) ?: $matches[0][6];\n\n        if ($params === true) {\n            $this->result = '';\n            return;\n        } elseif ($params !== '') {\n            $params = str_replace('$', '&$', $params) . ', ';\n        }\n\n        $this->html = preg_replace($re, 'useEffect(function() use ($1' . $params . $uses . ') {$8}, $2);', $this->html, 1);\n\n    }\n\n    private function doDeclaration(null|string|array $parameter = null): void\n    {\n        $re = '/useEffect\\(function[ ]*\\(\\)[ ]+use[ ]*\\(((\\s|.*?)+)\\)[ ]*{/m';\n\n        $str = $this->html;\n\n        preg_match_all($re, $str, $matches, PREG_SET_ORDER, 0);\n\n        $match = count($matches) === 0 ?: !isset($matches[0][1]) ?: $matches[0][1];\n        if ($match === true) {\n            $this->result = '';\n            return;\n        }\n\n        $useVars = explode(',', $match);\n        $declVars = array_filter($useVars, function ($item) {\n            return !in_array(trim($item), ['$props', '$children', '$slot', '']);\n        });\n\n        $declVars = count($declVars) === 0 ?: array_map(function ($item) {\n            return $this->declareTypedVariables($item);\n        }, $declVars);\n\n        if ($declVars === true) {\n            $this->result = '';\n            return;\n        }\n\n        $decl2 = implode(' ', $declVars);\n\n        $decl1 = substr($this->html, 0, $this->component->getBodyStart() + 1);\n        $decl3 = substr($this->html, $this->component->getBodyStart() + 1);\n\n        $this->html = $decl1 . \"\\n\\t\" . $decl2 . \"\\n\" . $decl3;\n    }\n}"}
{"instruction": "Write an Ephect PHP component", "input": "Based on Ephect source: UsePropsParser.php", "output": "<?php\n\nnamespace Ephect\\Modules\\Forms\\Generators\\TokenParsers;\n\nuse Ephect\\Modules\\Forms\\Generators\\TypesParserTrait;\nuse JetBrains\\PhpStorm\\Deprecated;\n\n/**\n * Deprecated\n */\n#[Deprecated(\"it does not work\", \"useEffect\", \"0.3\")]\nfinal class UsePropsParser extends AbstractTokenParser\n{\n    use TypesParserTrait;\n\n    public function do(null|string|array|object $parameter = null): void\n    {\n        if (!strpos($this->html, 'useProps')) {\n            return;\n        }\n\n        // $re = '/useProps\\(function[ ]*\\(\\$(props|children), ((\\s|.*?)+)\\)[ ]*{/m';\n        // $re = '/useProps\\(function[ ]*\\((\\$(props|children),[ ]*)?((\\s|.*?)+)\\)[ ]+use[ ]*\\(((\\s|.*?)+)\\)[ ]*{((\\s|.*?)+)}\\);/m';\n        $re = '/useProps\\(function[ ]*\\(((\\$props|\\$children),[ ]*)?((\\s|.*?)+)\\)[ ]+(use[ ]*\\(((\\s|.*?)+)\\)[ ]*)?{((\\s|.*?)+)}\\);/m';\n\n        $str = $this->html;\n\n        preg_match_all($re, $str, $matches, PREG_SET_ORDER, 0);\n\n        $props = count($matches) === 0 ?: !isset($matches[0][1]) ?: $matches[0][1];\n        $params = count($matches) === 0 ?: !isset($matches[0][3]) ?: $matches[0][3];\n        $uses = count($matches) === 0 ?: !isset($matches[0][6]) ?: $matches[0][6];\n\n        if ($params === true) {\n            $this->result = '';\n            return;\n        }\n\n        $paramVars = explode(',', $params);\n        $useslVars = $uses !== '' ? explode(',', $uses) : [];\n        $declVarTypes = array_filter($paramVars, function ($item) {\n            return $item !== '$props' && $item !== '$children' && trim($item) !== '';\n        });\n\n        if (count($useslVars) > 0) {\n            $declVarTypes = array_merge($declVarTypes, $useslVars);\n        }\n\n        $declVarValues = count($declVarTypes) === 0 ?: array_map(function ($item) {\n            return $this->declareTypedVariables($item);\n        }, $declVarTypes);\n\n        if ($declVarValues === true) {\n            $this->result = '';\n            return;\n        }\n\n        $params = str_replace('$', '&$', $params);\n        $uses = str_replace('$', '&$', $uses);\n\n        // $declDefValues = count($declVarTypes) === 0 ?: array_map(function($item) {\n        //     return $this->getDefaultValue($item);\n        // }, $declVarTypes);\n\n        /**\n         *\n         * $this->html =  preg_replace($re, 'useProps(function() use ($1$3,$6) {$8}, [' . implode(', ', $declDefValues) . '], $2);', $this->html, 1);\n         */\n        $this->html = preg_replace($re, 'useProps(function() use ($1' . $params . ', ' . $uses . ') {$8}, $2);', $this->html, 1);\n\n        $decl2 = implode(' ', $declVarValues);\n\n        $decl1 = substr($this->html, 0, $this->component->getBodyStart() + 1);\n        $decl3 = substr($this->html, $this->component->getBodyStart() + 1);\n\n        $this->html = $decl1 . \"\\n\\t\" . $decl2 . \"\\n\" . $decl3;\n    }\n}"}
{"instruction": "Write an Ephect PHP component", "input": "Based on Ephect source: UseSlotParser.php", "output": "<?php\n\nnamespace Ephect\\Modules\\Forms\\Generators\\TokenParsers;\n\nuse Ephect\\Modules\\Forms\\Generators\\TypesParserTrait;\nuse JetBrains\\PhpStorm\\Deprecated;\n\n/** @deprecated It's useless for now */\nfinal class UseSlotParser extends AbstractTokenParser\n{\n    use TypesParserTrait;\n\n    private string $text = '';\n\n    public function do(null|string|array|object $parameter = null): void\n    {\n        if (!strpos($this->html, 'useSlot')) {\n            return;\n        }\n\n        $this->doTranslation($parameter);\n        $this->doDeclaration($parameter);\n    }\n\n    private function doTranslation(null|string|array $parameter = null): void\n    {\n        $re = '/useSlot\\(function[ ]*\\(((\\$props|\\$children),[ ]*)?((\\s|.*?)+)\\)[ ]+(use[ ]*\\(((\\s|.*?)+)\\)[ ]*)?{((\\s|.*?)+)}\\);/m';\n\n        $str = $this->html;\n        preg_match_all($re, $str, $matches, PREG_SET_ORDER, 0);\n\n        $params = count($matches) === 0 ?: !isset($matches[0][3]) ?: $matches[0][3];\n        $uses = count($matches) === 0 ?: !isset($matches[0][6]) ?: $matches[0][6];\n\n        if ($params === true) {\n            $this->result = '';\n            return;\n        } elseif ($params !== '') {\n            $this->text = $matches[0][0];\n            $params = str_replace('$', '&$', $params) . ', ';\n        }\n\n        $this->html = preg_replace($re, 'useSlot(function() use ($1' . $params . $uses . ') {$8});', $this->html, 1);\n\n    }\n\n    private function doDeclaration(null|string|array $parameter = null): void\n    {\n        $re = '/useSlot\\(function[ ]*\\(\\)[ ]+use[ ]*\\(((\\s|.*?)+)\\)[ ]*{((\\s|.*?)+)}\\);/m';\n\n        $str = $this->html;\n\n        preg_match_all($re, $str, $matches, PREG_SET_ORDER, 0);\n\n        $match1 = count($matches) === 0 ?: !isset($matches[0][1]) ?: $matches[0][1];\n        $match2 = count($matches) === 0 ?: !isset($matches[0][3]) ?: $matches[0][3];\n        if ($match1 === true) {\n            $this->result = '';\n            return;\n        }\n\n        // $text = $matches[0][0];\n\n        $useVars = explode(',', $match1);\n        $declVars = array_filter($useVars, function ($item) {\n            return $item !== '$props' && $item !== '$children' && trim($item) !== '';\n\n        });\n\n        $declVars = count($declVars) === 0 ?: array_map(function ($item) {\n            return $this->declareTypedVariables($item);\n        }, $declVars);\n\n        if ($declVars === true) {\n            $this->result = '';\n            return;\n        }\n\n        $this->useVariables = $declVars;\n\n        //$decl2 = implode(' ', $declVars);\n        $decl2 = \"\";\n\n        $useEffect = <<< USEFFECT\n        \\Ephect\\Hooks\\useEffect(function() use ($match1) { $match2 });\n        USEFFECT;\n\n        $this->result = [\n            $this->text,\n            \"\\n\\t\" . $decl2 . \"\\n\" . $useEffect,\n        ];\n\n    }\n}"}
{"instruction": "Write an Ephect PHP component", "input": "Based on Ephect source: UseVariablesParser.php", "output": "<?php\n\nnamespace Ephect\\Modules\\Forms\\Generators\\TokenParsers;\n\nfinal class UseVariablesParser extends AbstractTokenParser\n{\n    public function do(null|string|array|object $parameter = null): void\n    {\n        $this->useVariables = $parameter;\n\n        $useVars = array_values($this->useVariables);\n        $use = count($useVars) > 0 ? 'use(' . implode(', ', $useVars) . ') ' : '';\n\n        $this->html = str_replace('(<<< HTML', 'function () ' . $use . '{?>', $this->html);\n        $this->html = str_replace('HTML);', \"<?php\\n\\t};\", $this->html);\n    }\n\n}"}
{"instruction": "Write an Ephect component", "input": "Based on Ephect source: UsesAsParser.php", "output": "<?php\n\nnamespace Ephect\\Modules\\Forms\\Generators\\TokenParsers;\n\nuse Ephect\\Modules\\Forms\\Registry\\ComponentRegistry;\n\nfinal class UsesAsParser extends AbstractTokenParser\n{\n    public function do(null|string|array|object $parameter = null): void\n    {\n        $compNamespace = $this->component->getNamespace();\n\n        $re = '/use\\s+function\\s+([\\w\\\\\\\\]*\\\\\\\\)?(\\w*)\\s+as\\s+(\\w*);/m';\n\n        preg_match_all($re, $this->html, $matches, PREG_SET_ORDER, 0);\n\n        foreach ($matches as $match) {\n            $componentNamespace = trim($match[1], '\\\\');\n            $componentFunction = $match[2];\n            $componentAlias = $match[3];\n\n            $fqFunctionName = $componentNamespace . '\\\\' . $componentFunction;\n            $this->useTypes[] = $fqFunctionName;\n\n            ComponentRegistry::write($componentAlias, $fqFunctionName);\n        }\n    }\n}"}
{"instruction": "Write an Ephect component", "input": "Based on Ephect source: UsesParser.php", "output": "<?php\n\nnamespace Ephect\\Modules\\Forms\\Generators\\TokenParsers;\n\nuse Ephect\\Framework\\Registry\\FrameworkRegistry;\nuse Ephect\\Modules\\Forms\\Registry\\ComponentRegistry;\n\nfinal class UsesParser extends AbstractTokenParser\n{\n    public function do(null|string|array|object $parameter = null): void\n    {\n        $re = '/use\\s+(function\\s+)?([\\w\\\\\\\\]+)\\\\\\\\(\\w+)\\s*?;/m';\n\n        preg_match_all($re, $this->html, $matches, PREG_SET_ORDER, 0);\n\n        foreach ($matches as $match) {\n            $componentNamespace = trim($match[2], '\\\\');\n            $componentFunction = $match[3];\n\n            $fqFunction = $componentNamespace . '\\\\' . $componentFunction;\n            $this->useTypes[] = $fqFunction;\n\n            if (FrameworkRegistry::read($fqFunction) !== null) {\n                continue;\n            }\n\n            ComponentRegistry::write($componentFunction, $fqFunction);\n        }\n    }\n}"}
{"instruction": "Write an Ephect PHP component", "input": "Based on Ephect source: BreakerParser.php", "output": "<?php\n\nnamespace Ephect\\Modules\\Forms\\Generators\\TokenParsers\\View;\n\nuse Ephect\\Modules\\Forms\\Generators\\TokenParsers\\AbstractTokenParser;\n\nfinal class BreakerParser extends AbstractTokenParser\n{\n    public function do(null|string|array|object $parameter = null): void\n    {\n        $re = '/@(break|continue)/m';\n        $subst = '<% $1; %>';\n        $result = preg_replace($re, $subst, $parameter);\n\n        /*        if(strpos($result,'?> <?') > -1) {*/\n        /*            $result = str_replace('?> <?', '', $result);*/\n        //        }\n\n        $this->result = $result;\n    }\n\n}"}
{"instruction": "Write an Ephect PHP component", "input": "Based on Ephect source: DoParser.php", "output": "<?php\n\nnamespace Ephect\\Modules\\Forms\\Generators\\TokenParsers\\View;\n\nuse Ephect\\Modules\\Forms\\Generators\\TokenParsers\\AbstractTokenParser;\n\nfinal class DoParser extends AbstractTokenParser\n{\n    public function do(null|string|array|object $parameter = null): void\n    {\n        $re = '/@do *$/m';\n        $subst = '<% do {%>';\n        $result = preg_replace($re, $subst, $parameter);\n\n        $this->result = $result;\n    }\n\n}"}
{"instruction": "Write an Ephect PHP component", "input": "Based on Ephect source: DoWhileParser.php", "output": "<?php\n\nnamespace Ephect\\Modules\\Forms\\Generators\\TokenParsers\\View;\n\nuse Ephect\\Modules\\Forms\\Generators\\TokenParsers\\AbstractTokenParser;\n\nfinal class DoWhileParser extends AbstractTokenParser\n{\n    public function do(null|string|array|object $parameter = null): void\n    {\n        $re = '/@while ([\\w @%&!=\\'\"+\\*\\/;\\<\\-\\>\\(\\)\\[\\]]+)/m';\n        $subst = '<%} while($1); %>';\n        $result = preg_replace($re, $subst, $parameter);\n\n        $this->result = $result;\n    }\n\n}"}
{"instruction": "Write an Ephect PHP component", "input": "Based on Ephect source: EchoParser.php", "output": "<?php\n\nnamespace Ephect\\Modules\\Forms\\Generators\\TokenParsers\\View;\n\nuse Ephect\\Modules\\Forms\\Generators\\TokenParsers\\AbstractTokenParser;\n\nfinal class EchoParser extends AbstractTokenParser\n{\n    public function do(null|string|array|object $parameter = null): void\n    {\n        $text = '';\n        if (is_array($parameter)) {\n            $text = $parameter['html'];\n            $this->useVariables = $parameter['useVariables'];\n        }\n\n        $re = '/\\{ ([\\w_@$\\-\\>]*) \\}/m';\n\n        preg_match_all($re, $text, $matches, PREG_SET_ORDER, 0);\n\n        foreach ($matches as $match) {\n            $variable = $match[1];\n\n            $useVar = $variable;\n            $arrowPos = strpos($variable, '->');\n            if ($arrowPos > -1) {\n                $useVar = substr($useVar, 0, $arrowPos);\n            }\n\n            if ($useVar[0] !== '@') {\n                $this->useVariables[$useVar] = '$' . $useVar;\n            }\n\n            $translate = $variable;\n            if ($translate[0] === '@') {\n                $translate = substr($translate, 1);\n            }\n\n            if ($variable === 'children') {\n\n                $text = str_replace('{{ children }}', '<?php $children->render(); ?>', $text);\n                $text = str_replace('{ children }', '$children->getBuffer()', $text);\n\n                continue;\n            }\n\n            $text = str_replace('{{ ' . $variable . ' }}', '<?=$' . $translate . ' ?>', $text);\n            $text = str_replace('{ ' . $variable . ' }', 'echo $' . $translate . ';', $text);\n        }\n\n        $this->result = $text;\n    }\n\n}"}
{"instruction": "Write an Ephect PHP component", "input": "Based on Ephect source: ElseIfParser.php", "output": "<?php\n\nnamespace Ephect\\Modules\\Forms\\Generators\\TokenParsers\\View;\n\nuse Ephect\\Modules\\Forms\\Generators\\TokenParsers\\AbstractTokenParser;\n\nfinal class ElseIfParser extends AbstractTokenParser\n{\n    public function do(null|string|array|object $parameter = null): void\n    {\n        $re = '/@else *if +(([\\w @%&!=\\'\"+\\*\\/;\\<\\-\\>\\(\\)\\[\\]]+)) +do/m';\n        $subst = '<% } elseif ($1) { %>';\n        $result = preg_replace($re, $subst, $parameter);\n\n        $this->result = $result;\n    }\n\n}"}
{"instruction": "Write an Ephect PHP component", "input": "Based on Ephect source: ElseParser.php", "output": "<?php\n\nnamespace Ephect\\Modules\\Forms\\Generators\\TokenParsers\\View;\n\nuse Ephect\\Modules\\Forms\\Generators\\TokenParsers\\AbstractTokenParser;\n\nfinal class ElseParser extends AbstractTokenParser\n{\n    public function do(null|string|array|object $parameter = null): void\n    {\n        $re = '/@else *$/m';\n        $subst = '<% } else { %>';\n        $result = preg_replace($re, $subst, $parameter);\n\n        $this->result = $result;\n    }\n\n}"}
{"instruction": "Write an Ephect PHP component", "input": "Based on Ephect source: EndParser.php", "output": "<?php\n\nnamespace Ephect\\Modules\\Forms\\Generators\\TokenParsers\\View;\n\nuse Ephect\\Modules\\Forms\\Generators\\TokenParsers\\AbstractTokenParser;\n\nfinal class EndParser extends AbstractTokenParser\n{\n    public function do(null|string|array|object $parameter = null): void\n    {\n        $re = '/@done/m';\n        $subst = '<% } %>';\n        $result = preg_replace($re, $subst, $parameter, 1);\n\n        $this->result = $result;\n    }\n\n}"}
{"instruction": "Write an Ephect PHP component", "input": "Based on Ephect source: ForParser.php", "output": "<?php\n\nnamespace Ephect\\Modules\\Forms\\Generators\\TokenParsers\\View;\n\nuse Ephect\\Modules\\Forms\\Generators\\TokenParsers\\AbstractTokenParser;\n\nfinal class ForParser extends AbstractTokenParser\n{\n    public function do(null|string|array|object $parameter = null): void\n    {\n        $re = '/@for +([\\\\w @%&!=\\'\"+\\*\\/;\\<\\-\\>]+) +do/m';\n        $subst = '<% for ($1) {%>';\n        $result = preg_replace($re, $subst, $parameter);\n\n        $this->result = $result;\n    }\n\n}"}
{"instruction": "Write an Ephect PHP component", "input": "Based on Ephect source: ForeachParser.php", "output": "<?php\n\nnamespace Ephect\\Modules\\Forms\\Generators\\TokenParsers\\View;\n\nuse Ephect\\Modules\\Forms\\Generators\\TokenParsers\\AbstractTokenParser;\n\nfinal class ForeachParser extends AbstractTokenParser\n{\n    public function do(null|string|array|object $parameter = null): void\n    {\n        $re = '/@for +((%[\\w\\->()\\[\\]]+) +as +(%\\w+( +=> +%\\w+)?)) +do/m';\n        $subst = \"<% foreach($2 as $3) { %>\";\n        $result = preg_replace($re, $subst, $parameter);\n\n        $this->result = $result;\n    }\n\n}"}
{"instruction": "Write an Ephect PHP component", "input": "Based on Ephect source: IfParser.php", "output": "<?php\n\nnamespace Ephect\\Modules\\Forms\\Generators\\TokenParsers\\View;\n\nuse Ephect\\Modules\\Forms\\Generators\\TokenParsers\\AbstractTokenParser;\n\nfinal class IfParser extends AbstractTokenParser\n{\n    public function do(null|string|array|object $parameter = null): void\n    {\n        $re = '/@if +([\\w \\|@%&!=\\'\"+\\*\\/;\\<\\-\\>\\(\\)\\[\\]]+) +do/m';\n        $subst = \"<% if ($1) {%>\";\n        $result = preg_replace($re, $subst, $parameter);\n\n        //        if(strpos($result,'<% <%if') > -1) {\n        //            $result = str_replace('<%if', 'if', $result);\n        //        }\n        //\n        //        if(strpos($result,'%> <%') > -1) {\n        //            $result = str_replace('%> <%', '', $result);\n        //        }\n\n        $this->result = $result;\n    }\n\n}"}
{"instruction": "Write an Ephect PHP component", "input": "Based on Ephect source: InlineCodeParser.php", "output": "<?php\n\nnamespace Ephect\\Modules\\Forms\\Generators\\TokenParsers\\View;\n\nuse Ephect\\Modules\\Forms\\Generators\\TokenParsers\\AbstractTokenParser;\n\nfinal class InlineCodeParser extends AbstractTokenParser\n{\n    public function do(null|string|array|object $parameter = null): void\n    {\n        $phtml = [];\n\n        $text = $this->html;\n        if (is_array($parameter)) {\n            $text = $parameter['html'];\n            $this->useVariables = $parameter['useVariables'];\n        }\n\n        $lines = explode(PHP_EOL, $text);\n\n        foreach ($lines as $line) {\n            $line = $this->doIf($line);\n            $line = $this->doElseIf($line);\n            $line = $this->doElse($line);\n            $line = $this->doForeach($line);\n            $line = $this->doFor($line);\n            $line = $this->doWhile($line);\n            $line = $this->doDo($line);\n            $line = $this->doDoWhile($line);\n            $line = $this->doBreaker($line);\n            $line = $this->doEnd($line);\n            $line = $this->doOperation($line);\n\n            $phtml[] = $line;\n        }\n\n        $text = implode(PHP_EOL, $phtml);\n\n        $text = $this->doPhpTags($text);\n\n        $text = $this->doEchoes($text);\n        $text = $this->doValues($text);\n        $this->doVariables();\n\n        $text = $this->doPhpCleaner($text);\n\n        $this->result = $text;\n    }\n\n    public function doIf(string $html): string\n    {\n        $parser = new IfParser($this->component);\n        $parser->do($html);\n        return $parser->getResult();\n    }\n\n    public function doElseIf(string $html): string\n    {\n        $parser = new ElseIfParser($this->component);\n        $parser->do($html);\n        return $parser->getResult();\n    }\n\n    public function doElse(string $html): string\n    {\n        $parser = new ElseParser($this->component);\n        $parser->do($html);\n        return $parser->getResult();\n    }\n\n    public function doForeach(string $html): string\n    {\n        $parser = new ForeachParser($this->component);\n        $parser->do($html);\n        return $parser->getResult();\n    }\n\n    public function doFor(string $html): string\n    {\n        $parser = new ForParser($this->component);\n        $parser->do($html);\n        return $parser->getResult();\n    }\n\n    public function doWhile(string $html): string\n    {\n        $parser = new WhileParser($this->component);\n        $parser->do($html);\n        return $parser->getResult();\n    }\n\n    public function doDo(string $html): string\n    {\n        $parser = new DoParser($this->component);\n        $parser->do($html);\n        return $parser->getResult();\n    }\n\n    public function doDoWhile(string $html): string\n    {\n        $parser = new DoWhileParser($this->component);\n        $parser->do($html);\n        return $parser->getResult();\n    }\n\n    public function doBreaker(string $html): string\n    {\n        $parser = new BreakerParser($this->component);\n        $parser->do($html);\n        return $parser->getResult();\n    }\n\n    public function doEnd(string $html): string\n    {\n        $parser = new EndParser($this->component);\n        $parser->do($html);\n        return $parser->getResult();\n    }\n\n    public function doOperation(string $html): string\n    {\n        $parser = new OperationParser($this->component);\n        $parser->do($html);\n        return $parser->getResult();\n    }\n\n    public function doPhpTags(string $html): string\n    {\n        $parser = new PhpTagsParser($this->component);\n        $parser->do($html);\n        return $parser->getResult();\n    }\n\n    public function doEchoes(string $html): string\n    {\n        $parser = new EchoParser($this->component);\n        $parser->do([\n            \"html\" => $html,\n            \"useVariables\" => $this->useVariables,\n        ]);\n        $this->useVariables = $parser->getUseVariables();\n\n        return $parser->getResult();\n    }\n\n    public function doValues(string $html): string\n    {\n        $parser = new ValuesParser($this->component);\n        $parser->do([\n            \"html\" => $html,\n            \"useVariables\" => $this->useVariables,\n        ]);\n\n        $this->useVariables = $parser->getUseVariables();\n        return $parser->getResult();\n    }\n\n    public function doVariables(): void\n    {\n        $parser = new VariablesParser($this->component);\n        $parser->do([\n            \"useVariables\" => $this->useVariables,\n        ]);\n\n        $this->funcVariables = $parser->getFuncVariables();\n        $this->useVariables = $parser->getUseVariables();\n    }\n\n    public function doPhpCleaner(string $html): string\n    {\n        $parser = new PhpTagsCleaner($this->component);\n        $parser->do($html);\n        return $parser->getResult();\n    }\n}"}
{"instruction": "Write an Ephect PHP component", "input": "Based on Ephect source: OperationParser.php", "output": "<?php\n\nnamespace Ephect\\Modules\\Forms\\Generators\\TokenParsers\\View;\n\nuse Ephect\\Modules\\Forms\\Generators\\TokenParsers\\AbstractTokenParser;\n\nfinal class OperationParser extends AbstractTokenParser\n{\n    public function do(null|string|array|object $parameter = null): void\n    {\n        $re = '/@op +(.*)$/m';\n        $subst = \"<% $1; %>\";\n        $result = preg_replace($re, $subst, $parameter);\n\n        $this->result = $result;\n    }\n\n}"}
{"instruction": "Write an Ephect PHP component", "input": "Based on Ephect source: PhpTagsCleaner.php", "output": "<?php\n\nnamespace Ephect\\Modules\\Forms\\Generators\\TokenParsers\\View;\n\nuse Ephect\\Modules\\Forms\\Generators\\TokenParsers\\AbstractTokenParser;\n\nfinal class PhpTagsCleaner extends AbstractTokenParser\n{\n    public function do(null|string|array|object $parameter = null): void\n    {\n        $phtml = $parameter;\n\n        $re = '/\\?>( |\\s+?)<\\?php/m';\n        $phtml = preg_replace($re, \"$1\", $phtml);\n\n        $re = '/<\\?=(\\$\\w+)\\ +\\n/m';\n        $phtml = preg_replace($re, \"<?php echo $1;\\n\", $phtml);\n\n        $this->result = $phtml;\n    }\n}"}
{"instruction": "Write an Ephect PHP component", "input": "Based on Ephect source: PhpTagsParser.php", "output": "<?php\n\nnamespace Ephect\\Modules\\Forms\\Generators\\TokenParsers\\View;\n\nuse Ephect\\Modules\\Forms\\Generators\\TokenParsers\\AbstractTokenParser;\n\nfinal class PhpTagsParser extends AbstractTokenParser\n{\n    public function do(null|string|array|object $parameter = null): void\n    {\n        $phtml = $parameter;\n\n        $re = '/(<%)(( +|\\s+)?)/m';\n        $phtml = preg_replace($re, '<?php $2', $phtml);\n\n        $re = '/%>/m';\n        $phtml = preg_replace($re, ' ?>', $phtml);\n\n        $this->result = $phtml;\n    }\n}"}
{"instruction": "Write an Ephect PHP component", "input": "Based on Ephect source: ValuesParser.php", "output": "<?php\n\nnamespace Ephect\\Modules\\Forms\\Generators\\TokenParsers\\View;\n\nuse Ephect\\Modules\\Forms\\Generators\\TokenParsers\\AbstractTokenParser;\n\nfinal class ValuesParser extends AbstractTokenParser\n{\n    public function do(null|string|array|object $parameter = null): void\n    {\n\n        $text = '';\n        if (is_array($parameter)) {\n            $text = $parameter['html'];\n            $this->useVariables = $parameter['useVariables'];\n        }\n\n        $re = '/%(\\w+)/m';\n        preg_match_all($re, $text, $matches, PREG_SET_ORDER, 0);\n\n        foreach ($matches as $match) {\n            $useVar = $match[1];\n            $this->useVariables[$useVar] = '$' . $useVar;\n\n            $text = str_replace($match[0], '$' . $useVar, $text);\n        }\n\n        $this->result = $text;\n\n    }\n\n}"}
{"instruction": "Write an Ephect PHP component", "input": "Based on Ephect source: VariablesParser.php", "output": "<?php\n\nnamespace Ephect\\Modules\\Forms\\Generators\\TokenParsers\\View;\n\nuse Ephect\\Modules\\Forms\\Generators\\TokenParsers\\AbstractTokenParser;\n\nfinal class VariablesParser extends AbstractTokenParser\n{\n    public function do(null|string|array|object $parameter = null): void\n    {\n\n        if (is_array($parameter)) {\n            $this->useVariables = $parameter['useVariables'];\n        }\n\n        $html = $this->component->getCode();\n\n        $re = '/function \\w+ *?\\([\\$\\w, ]*\\):? *?\\w*?(.|\\s|\\R)? *?\\{/U';\n        preg_match_all($re, $html, $matches, PREG_OFFSET_CAPTURE, 0);\n\n        $match = $matches[0];\n        $start = intval($match[0][1]) + strlen($match[0][0]) + 1;\n\n        $re = '/\\(([\\$\\w ,]*)\\)/';\n        preg_match_all($re, $html, $matches, PREG_OFFSET_CAPTURE, 0);\n\n        $match = $matches[1];\n        $funcArguments = explode(', ', $match[0][0]);\n\n        $re = '/( *?return \\(<<< ?HTML)/';\n        preg_match_all($re, $html, $matches, PREG_OFFSET_CAPTURE, 0);\n\n        $match = $matches[0];\n        $end = $match[0][1];\n\n        $functionCode = substr($html, $start, $end - $start);\n\n        $re = '/(\\$\\w+)([->]+\\w+)?/m';\n        preg_match_all($re, $functionCode, $matches, PREG_SET_ORDER, 0);\n\n        $variables = [];\n        foreach ($matches as $match) {\n            $variables[] = $match[1];\n        }\n\n        $variables = $variables ? array_unique($variables) : [];\n\n        $useVariables = array_keys($this->useVariables);\n\n        $c = count($useVariables);\n\n        for ($i = $c - 1; $i > -1; $i--) {\n            $current = '$' . $useVariables[$i];\n            if (is_array($funcArguments) && in_array($current, $funcArguments)) {\n                continue;\n            }\n            if (!in_array($current, $variables)) {\n                unset($this->useVariables[$useVariables[$i]]);\n            }\n        }\n\n        $this->funcVariables = $variables;\n\n    }\n\n}"}
{"instruction": "Write an Ephect PHP component", "input": "Based on Ephect source: WhileParser.php", "output": "<?php\n\nnamespace Ephect\\Modules\\Forms\\Generators\\TokenParsers\\View;\n\nuse Ephect\\Modules\\Forms\\Generators\\TokenParsers\\AbstractTokenParser;\n\nfinal class WhileParser extends AbstractTokenParser\n{\n    public function do(null|string|array|object $parameter = null): void\n    {\n        $re = '/@while ([\\w @%&!=\\'\"+\\*\\/;\\<\\-\\>\\(\\)\\[\\]]+) do/m';\n        $subst = '<% while($1) { %>';\n        $result = preg_replace($re, $subst, $parameter);\n\n        $this->result = $result;\n    }\n\n}"}
{"instruction": "Write an Ephect PHP component", "input": "Based on Ephect source: useEntityManager.php", "output": "<?php\n\nnamespace Ephect\\Modules\\DoctrineBridge\\Hooks;\n\nuse Doctrine\\DBAL\\DriverManager;\nuse Doctrine\\ORM\\EntityManager;\nuse Doctrine\\ORM\\ORMSetup;\nuse Ephect\\Modules\\DataAccess\\Configuration\\ConnectionConfiguration;\n\nfunction useEntityManager(ConnectionConfiguration $config, bool $isDevMode = false): EntityManager\n{\n    $settings = $config->getStructure()->encode(asArray: true);\n    $paths = [\\Constants::APP_ROOT . 'Entity'];\n    $proxyDir = \\Constants::RUNTIME_DIR . 'doctrine_proxies';\n    \n    // Create proxy directory if it doesn't exist\n    if (!is_dir($proxyDir)) {\n        mkdir($proxyDir, 0755, true);\n    }\n\n    $config = ORMSetup::createAttributeMetadataConfig($paths, $isDevMode);\n    $config->setProxyDir($proxyDir);\n    $config->setProxyNamespace('DoctrineProxies');\n    \n    $connection = DriverManager::getConnection($settings, $config); \n    \n    return new EntityManager($connection, $config);\n}"}
{"instruction": "Write an Ephect PHP component", "input": "Based on Ephect source: ConnectionMiddleware.php", "output": "<?php\n\nnamespace Ephect\\Modules\\DataAccess\\Attributes;\n\nuse Attribute;\nuse Ephect\\Framework\\Middlewares\\AttributeMiddlewareInterface;\nuse Ephect\\Modules\\DataAccess\\Middlewares\\ConnectionParserMiddleware;\n\n#[Attribute(Attribute::TARGET_FUNCTION)]\nclass ConnectionMiddleware implements AttributeMiddlewareInterface\n{\n    public function __construct(\n        protected string $conf\n    ) {\n    }\n\n    public function getMiddlewares(): array\n    {\n        return [\n            ConnectionParserMiddleware::class,\n        ];\n    }\n}"}
{"instruction": "Write an Ephect PHP component", "input": "Based on Ephect source: CrudQueriesTrait.php", "output": "<?php\n\nnamespace Ephect\\Modules\\DataAccess\\CRUD;\n\ntrait CrudQueriesTrait\n{\n    //put your code here\n\n    private $_select = '';\n    private $_insert = '';\n    private $_update = '';\n    private $_delete = '';\n    private $_parameters = '';\n\n\n    /**\n     * SELECT query\n     *\n     * @param string $value SQL query\n     * @param mixed array $params Set of values for the parametered query\n     */\n    public function setSelectQuery(string $value, array $params = []): void\n    {\n        $this->_parameters = $params;\n        $this->_select = $value;\n    }\n\n    public function getSelectQuery(): object\n    {\n        return (object)['sql' => $this->_select, 'params' => $this->_parameters];\n    }\n\n    /**\n     * INSERT query\n     *\n     * @param string $value SQL query\n     * @param mixed array $params Set of values for the parametered query\n     */\n    public function setInsertQuery(string $value, array $params = []): void\n    {\n        $this->_parameters = $params;\n        $this->_insert = $value;\n    }\n\n    public function getInsertQuery(): object\n    {\n        return (object)['sql' => $this->_insert, 'params' => $this->_parameters];\n    }\n\n    /**\n     * UPDATE query\n     *\n     * @param string $value SQL query\n     * @param mixed array $params Set of values for the parametered query\n     */\n    public function setUpdateQuery(string $value, array $params = []): void\n    {\n        $this->_parameters = $params;\n        $this->_update = $value;\n    }\n\n    public function getUpdateQuery(): object\n    {\n        return (object)['sql' => $this->_update, 'params' => $this->_parameters];\n    }\n\n    /**\n     * DELETE query\n     *\n     * @param string $value SQL query\n     * @param mixed array $params Set of values for the parametered query\n     */\n    public function setDeleteQuery(string $value, array $params = []): void\n    {\n        $this->_parameters = $params;\n        $this->_delete = $value;\n    }\n\n    public function getDeleteQuery(): object\n    {\n        return (object)['sql' => $this->_delete, 'params' => $this->_parameters];\n    }\n\n}"}
{"instruction": "Write an Ephect PHP component", "input": "Based on Ephect source: ConnectionConfiguration.php", "output": "<?php\n\nnamespace Ephect\\Modules\\DataAccess\\Configuration;\n\nuse Ephect\\Framework\\Structure\\JsonProperty;\nuse Ephect\\Framework\\Structure\\StructureTrait;\n\nfinal class ConnectionConfiguration\n{\n    private string $driver = '';\n    private string $user = '';\n    private string $databaseName = '';\n    private string $host = '';\n    private string $password = '';\n    private int $port = 0;\n    private string $charset = '';\n\n    use StructureTrait;\n\n    public function __construct(ConnectionStructure $structure)\n    {\n        $this->bindStructure($structure);\n    }\n\n    public function configure(): void\n    {\n    }\n\n    public function getDriver(): string\n    {\n        return $this->driver;\n    }\n\n    public function getDatabaseName(): string\n    {\n        return $this->databaseName;\n    }\n\n    /*\n     * Following properties are default null string in constructor because they may not be used (eg: SQLite)\n     */\n    public function getHost(): string\n    {\n        return $this->host;\n    }\n\n    public function getUser(): string\n    {\n        return $this->user;\n    }\n\n    public function getPassword(): string\n    {\n        return $this->password;\n    }\n\n    public function getPort(): int\n    {\n        return $this->port;\n    }\n\n    public function getCharset(): string\n    {\n        return $this->charset;\n    }\n}"}
{"instruction": "Write an Ephect PHP component", "input": "Based on Ephect source: ConnectionStructure.php", "output": "<?php\n\nnamespace Ephect\\Modules\\DataAccess\\Configuration;\n\nuse Ephect\\Framework\\Structure\\JsonProperty;\nuse Ephect\\Framework\\Structure\\Structure;\n\nclass ConnectionStructure extends Structure\n{\n    public string $driver;\n    public string $user;\n    public string $password;\n    #[JsonProperty(name: 'dbname')]\n    public string $databaseName;\n    public string $host;\n    public int $port;\n    public string $charset = 'utf8mb4';\n}"}
{"instruction": "Write an Ephect PHP component", "input": "Based on Ephect source: DataConfiguration.php", "output": "<?php\n\nnamespace Ephect\\Modules\\DataAccess\\Configuration;\n\nuse Ephect\\Framework\\Configuration\\AbstractConfiguration;\n\nabstract class DataConfiguration extends AbstractConfiguration\n{\n    public function __construct(\n        private readonly string $_driver = '',\n        private readonly string $_host = '',\n        private readonly string $_databaseName = '',\n        private readonly string $_user = '',\n        private readonly string $_password = '',\n        private readonly int $_port = 0,\n    ) {\n        parent::__construct($this);\n    }\n\n    public function configure(): void\n    {\n    }\n\n    public function getDriver(): string\n    {\n        return $this->_driver;\n    }\n\n    public function getDatabaseName(): string\n    {\n        return $this->_databaseName;\n    }\n\n    /*\n     * Following properties are default null string in constructor because they may not be used (eg: SQLite)\n     */\n    public function getHost(): string\n    {\n        return $this->_host;\n    }\n\n    public function getUser(): string\n    {\n        return $this->_user;\n    }\n\n    public function getPassword(): string\n    {\n        return $this->_password;\n    }\n\n    public function getPort(): int\n    {\n        return $this->_port;\n    }\n}"}
{"instruction": "Write an Ephect PHP component", "input": "Based on Ephect source: FileConfiguration.php", "output": "<?php\n\nnamespace Ephect\\Modules\\DataAccess\\Configuration;\n\nuse Ephect\\Framework\\Configuration\\AbstractConfiguration;\nuse Iterator;\n\nclass FileConfiguration extends AbstractConfiguration\n{\n    //put your code here\n    protected array $innerList = [];\n\n    public function configure(): void\n    {\n        $this->innerList = file($this->filename);\n    }\n\n    public function readLine(): Iterator\n    {\n        return yield $this->innerList;\n    }\n}"}
{"instruction": "Write an Ephect PHP component", "input": "Based on Ephect source: JsonConfiguration.php", "output": "<?php\n\nnamespace Ephect\\Modules\\DataAccess\\Configuration;\n\nuse Ephect\\Framework\\Configuration\\AbstractConfiguration;\n\nclass JsonConfiguration extends AbstractConfiguration\n{\n    protected array $contents = [];\n\n    public function configure(): void\n    {\n        $text = file_get_contents($this->filename);\n        $this->contents = json_decode($text, true);\n    }\n}"}
{"instruction": "Write an Ephect domain event", "input": "Based on Ephect source: ConnectionOpenerEvent.php", "output": "<?php\n\nnamespace Ephect\\Modules\\DataAccess\\Events;\n\nuse Ephect\\Framework\\Event\\Event;\n\nclass ConnectionOpenerEvent extends Event\n{\n    public function __construct(\n        private readonly object $arguments\n    ) {\n    }\n\n    public function getArguments(): object\n    {\n        return $this->arguments;\n    }\n}"}
{"instruction": "Write an Ephect PHP component", "input": "Based on Ephect source: useConfig.php", "output": "<?php\n\nnamespace Ephect\\Modules\\DataAccess\\Hooks;\n\nuse Ephect\\Framework\\Utils\\File;\nuse Ephect\\Modules\\DataAccess\\Configuration\\ConnectionConfiguration;\nuse Ephect\\Modules\\DataAccess\\Configuration\\ConnectionStructure;\nuse InvalidArgumentException;\n\nfunction useConfig(string $name): ConnectionConfiguration\n{\n    $congfigurationFile = \\Constants::APP_DATA . $name . \\Constants::JSON_EXTENSION;\n\n    if (!file_exists($congfigurationFile)) {\n        throw new InvalidArgumentException('Configuration file not found.');\n    }\n\n    $json = File::safeRead($congfigurationFile);\n\n    $result = null;\n    try {\n        $structure = new ConnectionStructure();\n        $structure->decode($json);\n        $result = new ConnectionConfiguration($structure);\n    } catch (InvalidArgumentException $e) {\n        throw new InvalidArgumentException('Invalid configuration structure.');\n    }\n\n    // TODO: validate JSON with Structure.\n    return $result;\n}"}
{"instruction": "Write an Ephect PHP component", "input": "Based on Ephect source: useRepository.php", "output": "<?php\n\nnamespace Ephect\\Modules\\DataAccess\\Hooks;\n\nuse Ephect\\Framework\\Registry\\FrameworkRegistry;\nuse Ephect\\Framework\\Repositories\\RepositoryFactoryInterface;\nuse Ephect\\Framework\\Repositories\\RepositoryInterface;\n\nfunction useRepository(string $repositoryClass): ?RepositoryInterface\n{\n    $filename = \\Constants::CONFIG_DIR . \"factories.php\";\n    if (!file_exists($filename)) {\n        return null;\n    }\n\n    $result = null;\n\n    $factories = require_once $filename;\n    foreach ($factories as $factoryClass) {\n        $factoryFile = FrameworkRegistry::read($factoryClass);\n        include_once $factoryFile;\n        if (is_subclass_of($factoryClass, RepositoryFactoryInterface::class)) {\n            $factory = new $factoryClass();\n            $result = $factory->create($repositoryClass);\n            break;\n        }\n    }\n\n    return $result;\n}"}
{"instruction": "Write an Ephect domain event", "input": "Based on Ephect source: ConnectionOpenerListener.php", "output": "<?php\n\nnamespace Ephect\\Modules\\DataAccess\\Listeners;\n\nuse Ephect\\Framework\\Event\\Event;\nuse Ephect\\Framework\\Event\\EventListenerInterface;\nuse Ephect\\Modules\\DataAccess\\Client\\PDO\\PdoConnection;\nuse Ephect\\Modules\\DataAccess\\Events\\ConnectionOpenerEvent;\nuse Ephect\\Modules\\Forms\\Events\\PageFinishedEvent;\n\nuse function Ephect\\Hooks\\useMemory;\n\nclass ConnectionOpenerListener implements EventListenerInterface\n{\n    /**\n     * @param Event|PageFinishedEvent $event\n     * @return void\n     * @throws \\ReflectionException\n     */\n    public function __invoke(Event|ConnectionOpenerEvent $event): void\n    {\n        $arguments = $event->getProps();\n        $conn = PdoConnection::opener($arguments->conf);\n        useMemory([\"$arguments->conf\" => $conn,]);\n    }\n}"}
{"instruction": "Write an Ephect PHP component", "input": "Based on Ephect source: ConnectionOpenerMiddleware.php", "output": "<?php\n\nnamespace Ephect\\Modules\\DataAccess\\Middlewares;\n\nuse Ephect\\Framework\\Logger\\Logger;\nuse Ephect\\Framework\\Middlewares\\ApplicationStateMiddlewareInterface;\nuse Ephect\\Modules\\DataAccess\\Client\\PDO\\PdoConnection;\n\nuse function Ephect\\Hooks\\useMemory;\nuse function Ephect\\Hooks\\useState;\n\nclass ConnectionOpenerMiddleware implements ApplicationStateMiddlewareInterface\n{\n    public function __invoke(object $arguments): void\n    {\n        $conn = PdoConnection::opener($arguments->conf);\n        useMemory([\"$arguments->conf\" => $conn,]);\n        // Dispatch event\n    }\n}"}
{"instruction": "Write an Ephect component", "input": "Based on Ephect source: ConnectionParserMiddleware.php", "output": "<?php\n\nnamespace Ephect\\Modules\\DataAccess\\Middlewares;\n\nuse Ephect\\Framework\\Event\\EventDispatcher;\nuse Ephect\\Framework\\Logger\\Logger;\nuse Ephect\\Framework\\Registry\\StateRegistry;\nuse Ephect\\Modules\\DataAccess\\Events\\ConnectionOpenerEvent;\nuse Ephect\\Modules\\Forms\\Components\\ComponentEntityInterface;\nuse Ephect\\Modules\\Forms\\Middlewares\\ComponentParserMiddlewareInterface;\n\nuse function Ephect\\Hooks\\useState;\n\nclass ConnectionParserMiddleware implements ComponentParserMiddlewareInterface\n{\n    public function parse(\n        ComponentEntityInterface|null $parent,\n        string $motherUID,\n        string $funcName,\n        string $props,\n        array $arguments\n    ): void {\n        //        StateRegistry::saveByMotherUid($motherUID, true);\n        useState([\"middlewares\" => [ConnectionOpenerMiddleware::class => (object)$arguments],]);\n        $middleware = new ConnectionOpenerMiddleware();\n        $middleware((object) $arguments);\n\n        $eventsProvider = useState(get: 'eventsProvider');\n        // TODO: Fix event dispatcher issue\n        //        Logger::create()->dump('eventsProvider', $eventsProvider);\n        //        $connectionEvent = new ConnectionOpenerEvent((object) $arguments);\n        //        $dispatcher = new EventDispatcher();\n        //        $dispatcher->dispatch($connectionEvent);\n\n        //        StateRegistry::save(true);\n    }\n}"}
{"instruction": "Write an Ephect PHP component", "input": "Based on Ephect source: ConnectionInterface.php", "output": "<?php\n\nnamespace Ephect\\Modules\\DataAccess\\Client\\Base;\n\ninterface ConnectionInterface\n{\n    public function getDriver();\n\n    public function getState();\n\n    public function open();\n\n    public function close();\n}"}
{"instruction": "Write an Ephect PHP component", "input": "Based on Ephect source: ConnectorInterface.php", "output": "<?php\n\nnamespace Ephect\\Modules\\DataAccess\\Client\\Base;\n\ninterface ConnectorInterface\n{\n    public function connect();\n\n    public function query($sql);\n\n    public function queryLog($sql, $filename, $lineNumber);\n\n    public function formatLimitedQyery($sql, $offset, $count);\n\n    public function fetchArray($resource);\n\n    public function nextResult($resource);\n\n    public function fetchObject($resource);\n\n    public function numRows($resource);\n\n    public function numFields($resource);\n\n    public function fieldName($resource, $offset);\n\n    public function fieldLen($resource, $offset);\n\n    public function fieldType($resource, $offset);\n\n    public function close();\n\n    public function freeResult($resource);\n\n    public function error();\n\n    public function useTransactions($set);\n\n    public function beginTransaction();\n\n    public function getTransactionLevel();\n\n    public function commit();\n\n    public function rollback();\n\n    public function identity();\n\n    public function getRecordset($sql);\n}"}
{"instruction": "Write an Ephect PHP component", "input": "Based on Ephect source: DataStatementInterface.php", "output": "<?php\n\nnamespace Ephect\\Modules\\DataAccess\\Client\\Base;\n\ninterface DataStatementInterface\n{\n    public function fetch(int $mode): ?array;\n\n    public function fetchAll(int $mode): ?array;\n\n    public function fetchObject(): ?object;\n\n    public function getFieldCount(): ?int;\n\n    public function getRowCount(): ?int;\n\n    public function getFieldName(int $i): string;\n\n    public function getFieldType(int $i): string;\n\n    public function getFieldLen(int $i): int;\n}"}
{"instruction": "Write an Ephect PHP component", "input": "Based on Ephect source: SqlConnectionInterface.php", "output": "<?php\n\nnamespace Ephect\\Modules\\DataAccess\\Client\\Base;\n\ninterface SqlConnectionInterface extends ConnectionInterface\n{\n    public function query(string $sql, array $params = []);\n\n    public function beginTransaction();\n\n    public function commit();\n\n    public function rollback();\n}"}
{"instruction": "Write an Ephect PHP component", "input": "Based on Ephect source: SqlParameters.php", "output": "<?php\n\nnamespace Ephect\\Modules\\DataAccess\\Client\\Base;\n\nuse Ephect\\Modules\\DataAccess\\Client\\Base\\Type\\ServerType;\n\nreadonly class SqlParameters\n{\n    public function __construct(\n        public string $Host = '',\n        public string $User = '',\n        public string $Password = '',\n        public string $DatabaseName = '',\n        public string $ServerType = ServerType::SQLITE,\n    ) {\n    }\n}"}
{"instruction": "Write an Ephect PHP component", "input": "Based on Ephect source: StaticConnectorInterface.php", "output": "<?php\n\nnamespace Ephect\\Modules\\DataAccess\\Client\\Base;\n\ninterface StaticConnectorInterface\n{\n    public static function connect();\n\n    public static function isAlive();\n\n    public static function isConnected();\n\n    public static function query($sql);\n\n    public static function queryLog($sql, $filename, $lineNumber);\n\n    public static function formatLimitedQyery($sql, $offset, $count);\n\n    public static function fetchArray($resource);\n\n    public static function nextResult($resource);\n\n    public static function fetchObject($resource);\n\n    public static function numRows($resource);\n\n    public static function numFields($resource);\n\n    public static function fieldName($resource, $offset);\n\n    public static function fieldLen($resource, $offset);\n\n    public static function fieldType($resource, $offset);\n\n    public static function close();\n\n    public static function kill();\n\n    public static function freeResult($resource);\n\n    public static function error();\n\n    public static function useTransactions($set);\n\n    public static function beginTransaction();\n\n    public static function getTransactionLevel();\n\n    public static function commit();\n\n    public static function rollback();\n\n    public static function identity();\n\n    public static function getRecordset($sql);\n}"}
{"instruction": "Write an Ephect PHP component", "input": "Based on Ephect source: PdoConfiguration.php", "output": "<?php\n\nnamespace Ephect\\Modules\\DataAccess\\Client\\PDO;\n\nuse Ephect\\Framework\\Registry\\StateRegistry;\nuse Ephect\\Modules\\DataAccess\\Client\\Base\\Type\\ServerType;\nuse Ephect\\Modules\\DataAccess\\Configuration\\JsonConfiguration;\n\nclass PdoConfiguration extends JsonConfiguration\n{\n    public function __construct(\n        private string $_driver = '',\n        private string $_host = '',\n        private string $_databaseName = '',\n        private string $_user = '',\n        private string $_password = '',\n        private string $_port = '',\n    ) {\n        parent::__construct($this);\n        $this->canConfigure = false;\n    }\n\n    public function loadConfiguration(string $filename): bool\n    {\n        $result = false;\n\n        if (file_exists($filename)) {\n            $result = parent::loadConfiguration($filename);\n\n            return $result;\n        }\n\n        if (StateRegistry::exists('connections', $filename)) {\n            $this->canConfigure = false;\n            $this->contents = StateRegistry::readItem('connections', $filename);\n\n            $this->configure();\n\n            $result = true;\n        }\n\n        return $result;\n    }\n\n    public function configure(): void\n    {\n        if ($this->canConfigure) {\n            parent::configure();\n        }\n\n        $this->_driver = $this->contents['driver'];\n        $this->_databaseName = $this->contents['database'];\n        if ($this->_driver == ServerType::SQLITE) {\n            $this->_databaseName = \\Constants::APP_DATA . $this->_databaseName;\n        }\n        $this->_host = !isset($this->contents['host']) ? '' : $this->contents['host'];\n        $this->_user = !isset($this->contents['user']) ? '' : $this->contents['user'];\n        $this->_password = !isset($this->contents['password']) ? '' : $this->contents['password'];\n        $this->_port = !isset($this->contents['port']) ? '' : $this->contents['port'];\n    }\n\n    public function getDriver(): string\n    {\n        return $this->_driver;\n    }\n\n    public function getDatabaseName(): string\n    {\n        return $this->_databaseName;\n    }\n\n    /*\n     * Following properties are default null string in constructor because they may not be used (eg: SQLite)\n     */\n    public function getHost(): string\n    {\n        return $this->_host;\n    }\n\n    public function getUser(): string\n    {\n        return $this->_user;\n    }\n\n    public function getPassword(): string\n    {\n        return $this->_password;\n    }\n\n    public function getPort(): string\n    {\n        return $this->_port;\n    }\n}"}
{"instruction": "Write an Ephect PHP component", "input": "Based on Ephect source: PdoConnection.php", "output": "<?php\n\nnamespace Ephect\\Modules\\DataAccess\\Client\\PDO;\n\nuse Ephect\\Framework\\Configuration\\AbstractConfiguration;\nuse Ephect\\Modules\\DataAccess\\Client\\Base\\SqlConnectionInterface;\nuse Ephect\\Modules\\DataAccess\\Client\\Base\\Type\\ServerType;\nuse Ephect\\Modules\\DataAccess\\Client\\PDO\\Exceptions\\PdoConnectionException;\nuse Ephect\\Modules\\DataAccess\\Client\\PDO\\SchemaInfo\\AbstractPdoSchemaInfo;\nuse Ephect\\Modules\\DataAccess\\CRUD\\CrudQueriesTrait;\nuse Exception;\nuse PDO;\nuse PDOException;\nuse PDOStatement;\n\nclass PdoConnection extends AbstractConfiguration implements SqlConnectionInterface\n{\n    use CrudQueriesTrait;\n    private PDO $_state;\n    private PdoConfiguration $_config;\n    private string $_dsn = '';\n    private array|null $_params = null;\n    private AbstractPdoSchemaInfo $_SchemaInfo;\n\n    public function __construct(PdoConfiguration $config)\n    {\n        parent::__construct($this);\n\n        $this->_config = $config;\n        $this->configure();\n    }\n\n    public function configure(): void\n    {\n        $this->_dsn = '';\n        $this->_params = (array)null;\n        if ($this->_config->getDriver() == ServerType::MYSQL) {\n            $this->_params = [PDO::MYSQL_ATTR_INIT_COMMAND => \"SET NAMES utf8\"];\n            $this->_dsn = $this->_config->getDriver() . ':host=' . $this->_config->getHost() . ';dbname=' . $this->_config->getDatabaseName();\n        } elseif ($this->_config->getDriver() == ServerType::SQLSERVER) {\n            $this->_params = [PDO::SQLSRV_ATTR_ENCODING => PDO::SQLSRV_ENCODING_SYSTEM, PDO::SQLSRV_ATTR_DIRECT_QUERY => true];\n            $this->_dsn = $this->_config->getDriver() . ':Server=' . $this->_config->getHost() . ';Database=' . $this->_config->getDatabaseName();\n        } elseif ($this->_config->getDriver() == ServerType::SQLITE) {\n            $this->_dsn = $this->_config->getDriver() . ':' . $this->_config->getDatabaseName();\n        }\n        // $this->_SchemaInfo = AbstractPdoSchemaInfo::builder($this->_config);\n    }\n\n    public function getDriver(): string\n    {\n        return $this->_config->getDriver();\n    }\n\n    public static function opener($confname): PdoConnection\n    {\n        $result = self::builder($confname);\n        $result->open();\n\n        return $result;\n    }\n\n    public static function builder(string $confname): PdoConnection\n    {\n        $result = null;\n        try {\n            $config = new PdoConfiguration();\n            if (!$config->loadConfiguration($confname)) {\n                throw new Exception(\"The configuration `$confname` was not found.\");\n            }\n            $result = new PdoConnection($config);\n        } catch (Exception | PDOException $e) {\n            throw new PdoConnectionException('Something went wrong while building the connection.', 1, $e);\n        } finally {\n            return $result;\n        }\n    }\n\n    public function open(): PDO\n    {\n        try {\n            if ($this->_params != null) {\n                $this->_state = new PDO($this->_dsn, $this->_config->getUser(), $this->_config->getPassword(), $this->_params);\n            } else {\n                $this->_state = new PDO($this->_dsn, $this->_config->getUser(), $this->_config->getPassword(), []);\n            }\n        } catch (PDOException $ex) {\n            self::getlogger()->error($ex, __FILE__, __LINE__);\n        }\n\n        return $this->_state;\n    }\n\n    public function getSchemaInfo(): AbstractPdoSchemaInfo\n    {\n        return $this->_SchemaInfo;\n    }\n\n    public function getState(): PDO\n    {\n        return $this->_state;\n    }\n\n    public function getConfiguration(): PdoConfiguration\n    {\n        return $this->_config;\n    }\n\n    public function querySelect(): ?PdoDataStatement\n    {\n        list($sql, $params) = $this->getSelectQuery();\n        return $this->query($sql, $params);\n    }\n\n    public function query(string $sql = '', ?array $params = null): ?PdoDataStatement\n    {\n        $statement = null;\n        $result = null;\n        $error = null;\n        try {\n            if ($params != null) {\n                $statement = $this->_state->prepare($sql);\n                $statement->execute($params);\n            } else {\n                $statement = $this->_state->query($sql);\n            }\n\n            if (!$statement && count($this->_state->errorInfo()) > 0) {\n                throw new PDOException($this->_state->errorInfo()[2], $this->_state->errorInfo()[1], null);\n            }\n        } catch (Exception | PDOException $ex) {\n            self::getLogger()->sql($sql);\n            if (is_array($params)) {\n                self::getLogger()->sql('WITH PARAMS ' . print_r($params, true));\n            }\n            self::getLogger()->error($ex);\n            $error = $ex;\n            $statement = null;\n        } finally {\n            $result = new PdoDataStatement($statement, $this, $sql, $error);\n        }\n\n        return $result;\n    }\n\n    public function prepare(string $sql): ?PDOStatement\n    {\n        return $this->_state->prepare($sql);\n    }\n\n    public function queryInsert(): int\n    {\n        return $this->exec($this->getInsertQuery());\n    }\n\n    public function exec(string $sql): string\n    {\n        return $this->_state->exec($sql);\n    }\n\n    public function queryUpdate(): int\n    {\n        return $this->exec($this->getUpdateQuery());\n    }\n\n    public function queryDelete(): int\n    {\n        return $this->exec($this->getDeleteQuery());\n    }\n\n    public function addSelectLimit($start, $count)\n    {\n        //        $driver = strtolower($this->_activeConnection->getDriver());\n        //        if(strstr($driver, 'mysql')) {\n        $start = (!$start) ? 1 : $start;\n        $sql = $this->getSelectQuery() . PHP_EOL . ' LIMIT ' . (($start - 1) * $count) . ', ' . $count . PHP_EOL;\n\n        $this->setSelectQuery($sql);\n        //        }\n    }\n\n    public function showTables(): ?PdoDataStatement\n    {\n        $sql = $this->_SchemaInfo->getShowTablesQuery();\n        return $this->query($sql);\n    }\n\n    public function showFieldsFrom(string $table): ?PdoDataStatement\n    {\n        $sql = $this->_SchemaInfo->getShowFieldsQuery($table);\n        return $this->query($sql);\n    }\n\n    public function beginTransaction(): void\n    {\n        $this->_state->beginTransaction();\n    }\n\n    public function commit(): void\n    {\n        $this->_state->commit();\n    }\n\n    public function rollback(): void\n    {\n        $this->_state->rollBack();\n    }\n\n    public function inTransaction(): void\n    {\n        $this->_state->inTransaction();\n    }\n\n    public function setAttribute(string $key, $value): void\n    {\n        $this->_state->setAttribute($key, $value);\n    }\n\n    public function getAttribute(string $key)\n    {\n        return $this->_state->getAttribute($key);\n    }\n\n    public function getLastInsertId(): int\n    {\n        return $this->_state->lastInsertId();\n    }\n\n    public function lastInsertId(): int\n    {\n        return $this->_state->lastInsertId();\n    }\n\n    public function quote(string $value): string\n    {\n        return $this->_state->quote($value);\n    }\n\n    public function __destruct()\n    {\n        $this->close();\n    }\n\n    public function close(): bool\n    {\n        unset($this->_state);\n        return true;\n    }\n}"}
{"instruction": "Write an Ephect PHP component", "input": "Based on Ephect source: PdoDataAccess.php", "output": "<?php\n\nnamespace Ephect\\Modules\\DataAccess\\Client\\PDO;\n\nuse Ephect\\Modules\\DataAccess\\Client\\Base\\Type\\ServerType;\n\nclass PdoDataAccess\n{\n    public static function getCryptoDB(): ?PdoConnection\n    {\n        $databaseName = realpath(\\Constants::SITE_ROOT . 'data' . DIRECTORY_SEPARATOR . 'crypto.db');\n\n        $sqlConfig = new PdoConfiguration(ServerType::SQLITE, $databaseName);\n        $connection = new PdoConnection($sqlConfig);\n\n        $isFound = (file_exists($databaseName));\n        $connection->open();\n\n        if (!$isFound) {\n            $connection->exec(\"CREATE TABLE crypto (id integer primary key autoincrement, token text, userId text, userName text, outdated integer);\");\n            $connection->exec(\"CREATE INDEX crypto_id ON crypto (id);\");\n            $connection->exec(\"CREATE UNIQUE INDEX covering_idx ON crypto (token, userId, userName, outdated);\");\n        }\n\n        return $connection;\n    }\n\n\n    public static function getNidusLiteDB(): ?PdoConnection\n    {\n        $databaseName = APP_DATA . 'niduslite.db';\n        $isFound = (file_exists($databaseName));\n        $size = 0;\n        if ($isFound) {\n            $size = filesize($databaseName);\n        }\n        $sqlConfig = new PdoConfiguration(ServerType::SQLITE, $databaseName);\n        $connection = new PdoConnection($sqlConfig);\n\n        $connection->open();\n\n        if (!$isFound || ($isFound && $size === 0)) {\n            $sqlFilename = \\Constants::EPHECT_APPS_ROOT . 'common' . DIRECTORY_SEPARATOR . 'data' . DIRECTORY_SEPARATOR . 'fxcms.sql';\n            if (file_exists($sqlFilename)) {\n                $sql = file_get_contents($sqlFilename);\n                $connection->exec($sql);\n            }\n        }\n\n        return $connection;\n    }\n}"}
{"instruction": "Write an Ephect PHP component", "input": "Based on Ephect source: PdoDataStatement.php", "output": "<?php\n\nnamespace Ephect\\Modules\\DataAccess\\Client\\PDO;\n\nuse Ephect\\Framework\\Element;\nuse Ephect\\Modules\\DataAccess\\Client\\Base\\DataStatementInterface;\nuse Ephect\\Modules\\DataAccess\\Client\\PDO\\SchemaInfo\\AbstractPdoSchemaInfo;\nuse Exception;\nuse PDO;\nuse PDOException;\nuse PDOStatement;\nuse Throwable;\n\nclass PdoDataStatement extends Element implements DataStatementInterface\n{\n    private array $_values;\n    private int $_fieldCount;\n    private int $_rowCount;\n    private array $_meta = [];\n    private array $_colNames = [];\n    private AbstractPdoSchemaInfo|null $_schemaInfo = null;\n    private PdoConfiguration|null $_config = null;\n    private PDO $_native_connection;\n    private string $_driver;\n    private bool $_hasException = false;\n\n    public function __construct(\n        private readonly ?PDOStatement $_statement,\n        private readonly PdoConnection $_connection,\n        private readonly string $_sql = '',\n        private readonly Throwable|null $_exception = null,\n    ) {\n        parent::__construct($this);\n\n        $this->_hasException = ($this->_exception instanceof PDOException);\n\n        if ($this->_connection !== null) {\n            $this->_native_connection = $this->_connection->getState();\n            $this->_config = $this->_connection->getConfiguration();\n            $this->_driver = $this->_config->getDriver();\n            //            $this->_schemaInfo = $this->_connection->getSchemaInfo();\n            //            if ($this->_sql !== null) {\n            //                $this->_schemaInfo->setQuery($this->_sql);\n            //            }\n        }\n    }\n\n    public function hasException(): bool\n    {\n        return $this->_hasException;\n    }\n\n    public function getException(): Throwable|null\n    {\n        return $this->_exception;\n    }\n\n    public function getValue($i): array\n    {\n        return $this->_values[$i];\n    }\n\n    public function fetchAssoc(): ?array\n    {\n        $this->_values = $this->_statement->fetch(PDO::FETCH_ASSOC);\n        return (!$this->_values) ? null : $this->_values;\n    }\n\n    public function fetch(int $mode = PDO::FETCH_NUM): ?array\n    {\n        $this->_values = $this->_statement->fetch($mode);\n        return (!$this->_values) ? null : $this->_values;\n    }\n\n    public function fetchAllAssoc(): ?array\n    {\n        $this->_values = $this->_statement->fetchAll(PDO::FETCH_ASSOC);\n        return (!$this->_values) ? null : $this->_values;\n    }\n\n    public function fetchAll(int $mode = PDO::FETCH_NUM): ?array\n    {\n        $this->_values = $this->_statement->fetchAll($mode);\n        return (!$this->_values) ? null : $this->_values;\n    }\n\n    public function fetchObject(): ?object\n    {\n        return $this->_statement->fetchObject();\n    }\n\n    public function getRowCount(): ?int\n    {\n        if (!isset($this->_rowCount)) {\n            if ($this->_schemaInfo !== null) {\n                $this->_rowCount = $this->_schemaInfo->getRowCount();\n            } else {\n                try {\n                    $this->_rowCount = $this->_statement->rowCount();\n                } catch (Exception | PDOException $ex) {\n                    if (is_array($this->_values)) {\n                        $this->_rowCount = count($this->_values);\n                    } else {\n                        throw new Exception(\"Cannot count rows of a result set before the resource is fetched\", -1, $ex);\n                    }\n                }\n            }\n        }\n\n        return $this->_rowCount;\n    }\n\n    public function getFieldNames(): array\n    {\n        if (count($this->_colNames) == 0 && $this->_connection !== null) {\n            $c = $this->getFieldCount();\n            for ($i = 0; $i < $c; $i++) {\n                $this->_colNames[] = $this->getFieldName($i);\n            }\n        }\n\n        return $this->_colNames;\n    }\n\n    public function getFieldCount(): ?int\n    {\n        if (!isset($this->_fieldCount)) {\n            try {\n                $this->_fieldCount = $this->_statement->columnCount();\n            } catch (Exception | PDOException $ex) {\n                if (isset($this->_values[0])) {\n                    $this->_fieldCount = count($this->_values[0]);\n                } else {\n                    throw new Exception(\"Cannot count fields of a row before the resource is fetched\", -1, $ex);\n                }\n            }\n        }\n\n        return $this->_fieldCount;\n    }\n\n    public function getFieldName($i): string\n    {\n        $name = '';\n\n        if ($this->_schemaInfo !== null) {\n            $info = $this->_schemaInfo->getInfo($i);\n            $name = $info->name;\n        } else {\n            if (!isset($this->_meta[$i])) {\n                $this->_meta[$i] = $this->_statement->getColumnMeta($i);\n            }\n            $name = $this->_meta[$i]['name'];\n        }\n\n        return $name;\n    }\n\n    public function getFieldType(int $i): string\n    {\n        $type = '';\n\n        if ($this->_schemaInfo !== null) {\n            $info = $this->_schemaInfo->getInfo($i);\n            $type = $info->type;\n        } else {\n            if (!isset($this->_meta[$i])) {\n                $this->_meta[$i] = $this->_statement->getColumnMeta($i);\n            }\n            $type = $this->_meta[$i]['native_type'];\n        }\n\n        return $type;\n    }\n\n    public function getFieldLen(int $i): int\n    {\n        $len = 0;\n\n        if ($this->_schemaInfo !== null) {\n            $info = $this->_schemaInfo->getInfo($i);\n            $len = $info->length;\n        } else {\n            if (!isset($this->_meta[$i])) {\n                $this->_meta[$i] = $this->_statement->getColumnMeta($i);\n            }\n            $len = $this->_meta[$i]['len'];\n        }\n\n        return $len;\n    }\n\n    public function typeNumToName(int $type): string\n    {\n        return $this->_schemaInfo->typeNumToName($type);\n    }\n\n    public function typeNameToPhp(string $type): string\n    {\n        return $this->_schemaInfo->typeNameToPhp($type);\n    }\n\n    public function typeNumToPhp(int $type): string\n    {\n        return $this->_schemaInfo->typeNumToPhp($type);\n    }\n}"}
{"instruction": "Write an Ephect PHP component", "input": "Based on Ephect source: PdoConnectionException.php", "output": "<?php\n\nnamespace Ephect\\Modules\\DataAccess\\Client\\PDO\\Exceptions;\n\nuse Exception;\nuse Throwable;\n\nclass PdoConnectionException extends Exception\n{\n    public function __construct(string $message = \"\", int $code = 0, Throwable $previous = null)\n    {\n        parent::__construct($message, $code, $previous);\n    }\n}"}
{"instruction": "Write an Ephect PHP component", "input": "Based on Ephect source: AbstractPdoSchemaInfo.php", "output": "<?php\n\nnamespace Ephect\\Modules\\DataAccess\\Client\\PDO\\SchemaInfo;\n\nuse Ephect\\Framework\\Configuration\\ConfigurableInterface;\nuse Ephect\\Framework\\Logger\\Logger;\nuse Ephect\\Modules\\DataAccess\\Client\\Base\\DataStatementInterface;\nuse Ephect\\Modules\\DataAccess\\Client\\Base\\Type\\ServerType;\nuse Ephect\\Modules\\DataAccess\\Client\\PDO\\PdoConfiguration;\nuse PDOException;\n\nabstract class AbstractPdoSchemaInfo implements PdoSchemaInfoInterface\n{\n    protected ConfigurableInterface|null $config = null;\n    protected string $driver = ServerType::SQLITE;\n    protected DataStatementInterface $statement;\n    protected array $values;\n    protected int $fieldCount;\n    protected int $rowCount;\n    protected array $meta = [];\n    protected array|null $columnNames = null;\n    protected array|null $columnTypes = null;\n    protected string $query = '';\n    protected mixed $result;\n    protected array $native_types = [];\n    protected array $native2php_assoc = [];\n    protected array $native2php_num = [];\n    protected object|null $typesMapper = null;\n    protected string|null $cs = null;\n    protected object|null $info = null;\n    protected bool $queryIsATable = false;\n\n    public function __construct(PdoConfiguration $config)\n    {\n        $this->config = $config;\n        $this->setTypes();\n    }\n\n    public function setTypes(): void\n    {\n    }\n\n    public static function builder(PdoConfiguration $config): AbstractPdoSchemaInfo\n    {\n        $result = null;\n\n        try {\n            if ($config->getDriver() == ServerType::MYSQL) {\n                $result = new PdoMySQLSchemaInfo($config);\n            }\n\n            if ($config->getDriver() == ServerType::SQLITE) {\n                $result = new PdoSQLiteSchemaInfo($config);\n            }\n        } catch (PDOException $ex) {\n            Logger::create()->error($ex);\n            $result = null;\n        } finally {\n            return $result;\n        }\n    }\n\n    public function getQuery(): string\n    {\n        return $this->query;\n    }\n\n    public function setQuery(string $value): void\n    {\n        $this->query = $value;\n    }\n\n    public function getColumnNames(): ?array\n    {\n        return $this->columnNames;\n    }\n\n    public function getColumnTypes(): ?array\n    {\n        return $this->columnTypes;\n    }\n\n    public function isQueryATable(): bool\n    {\n        if (!$this->queryIsATable) {\n            $sql = str_replace(\"\\r\", ' ', $this->query);\n            $sql = str_replace(\"\\n\", ' ', $sql);\n            $sql = trim($sql);\n            $this->queryIsATable = (strpos($sql, ' ') === false);\n        }\n        return $this->queryIsATable;\n    }\n\n    public function getInfo(int $index): ?object\n    {\n    }\n\n    public function typeNumToName(int $type): string\n    {\n        return $this->native_types[$type];\n    }\n\n    public function typeNameToPhp(string $type): string\n    {\n        return $this->native2php_assoc[$type];\n    }\n\n    public function typeNumToPhp(int $type): string\n    {\n        return $this->native2php_num[$type];\n    }\n\n    public function getShowTablesQuery(): string\n    {\n    }\n\n    public function getShowFieldsQuery(?string $table): string\n    {\n    }\n\n    public function getFieldCount(): int\n    {\n    }\n\n    public function getRowCount(): int\n    {\n    }\n}"}
{"instruction": "Write an Ephect PHP component", "input": "Based on Ephect source: PdoMysqlSchemaInfo.php", "output": "<?php\n\nnamespace Ephect\\Modules\\DataAccess\\Client\\PDO\\SchemaInfo;\n\nuse Ephect\\Modules\\DataAccess\\Client\\PDO\\PdoConnection;\nuse Exception;\n\nclass PdoMysqlSchemaInfo extends AbstractPdoSchemaInfo\n{\n    public function getInfo($index): ?object\n    {\n        if ($this->result === null) {\n            try {\n\n                $connection = new PdoConnection($this->config);\n\n                $this->result = $connection->query($this->query);\n            } catch (Exception $ex) {\n                return null;\n            }\n        }\n\n        $this->info = $this->result->fetch_field_direct($index);\n\n        return $this->info;\n    }\n\n    public function setTypes(): void\n    {\n        $this->native_types = (array)null;\n        $this->native2php_assoc = (array)null;\n        $this->native2php_num = (array)null;\n\n        $this->native_types[1] = \"TINYINT\";\n        $this->native_types[2] = \"SMALLINT\";\n        $this->native_types[3] = \"INT\";\n        $this->native_types[4] = \"FLOAT\";\n        $this->native_types[5] = \"DOUBLE\";\n        $this->native_types[7] = \"TIMESTAMP\";\n        $this->native_types[8] = \"BIGINT\";\n        $this->native_types[9] = \"MEDIUMINT\";\n        $this->native_types[10] = \"DATE\";\n        $this->native_types[11] = \"TIME\";\n        $this->native_types[12] = \"DATETIME\";\n        $this->native_types[13] = \"YEAR\";\n        $this->native_types[16] = \"BIT\";\n        $this->native_types[246] = \"DECIMAL\";\n        $this->native_types[252] = \"BLOB\";\n        $this->native_types[253] = \"VARCHAR\";\n        $this->native_types[254] = \"CHAR\";\n\n        $this->native2php_assoc[\"TINYINT\"] = \"int\";\n        $this->native2php_assoc[\"SMALLINT\"] = \"int\";\n        $this->native2php_assoc[\"INT\"] = \"int\";\n        $this->native2php_assoc[\"FLOAT\"] = \"float\";\n        $this->native2php_assoc[\"DOUBLE\"] = \"float\";\n        $this->native2php_assoc[\"TIMESTAMP\"] = \"int\";\n        $this->native2php_assoc[\"BIGINT\"] = \"int\";\n        $this->native2php_assoc[\"MEDIUMINT\"] = \"int\";\n        $this->native2php_assoc[\"DATE\"] = \"date\";\n        $this->native2php_assoc[\"TIME\"] = \"time\";\n        $this->native2php_assoc[\"DATETIME\"] = \"datetime\";\n        $this->native2php_assoc[\"YEAR\"] = \"year\";\n        $this->native2php_assoc[\"BIT\"] = \"int\";\n        $this->native2php_assoc[\"DECIMAL\"] = \"float\";\n        $this->native2php_assoc[\"BLOB\"] = \"blob\";\n        $this->native2php_assoc[\"VARCHAR\"] = \"string\";\n        $this->native2php_assoc[\"CHAR\"] = \"char\";\n\n        $this->native2php_num[1] = \"int\";\n        $this->native2php_num[2] = \"int\";\n        $this->native2php_num[3] = \"int\";\n        $this->native2php_num[4] = \"float\";\n        $this->native2php_num[5] = \"float\";\n        $this->native2php_num[7] = \"int\";\n        $this->native2php_num[8] = \"int\";\n        $this->native2php_num[9] = \"int\";\n        $this->native2php_num[10] = \"date\";\n        $this->native2php_num[11] = \"time\";\n        $this->native2php_num[12] = \"datetime\";\n        $this->native2php_num[13] = \"year\";\n        $this->native2php_num[16] = \"int\";\n        $this->native2php_num[246] = \"float\";\n        $this->native2php_num[252] = \"blob\";\n        $this->native2php_num[253] = \"string\";\n        $this->native2php_num[254] = \"string\";\n    }\n\n    public function getShowTablesQuery(): string\n    {\n        $sql = <<<SQL\n        show tables from {$this->config->getDatabaseName()};\n        SQL;\n\n        return $sql;\n    }\n\n    public function getShowFieldsQuery(?string $table): string\n    {\n        $sql = <<<SQL\n        show fields from $table;\n        SQL;\n\n        return $sql;\n    }\n\n    public function getFieldCount(): int\n    {\n    }\n}"}
{"instruction": "Write an Ephect PHP component", "input": "Based on Ephect source: PdoSchemaInfoInterface.php", "output": "<?php\n\nnamespace Ephect\\Modules\\DataAccess\\Client\\PDO\\SchemaInfo;\n\ninterface PdoSchemaInfoInterface\n{\n    public function setTypes(): void;\n\n    public function getInfo(int $index): ?object;\n\n    public function typeNumToName(int $type): string;\n\n    public function typeNameToPhp(string $type): string;\n\n    public function typeNumToPhp(int $type): string;\n\n    public function getShowTablesQuery(): string;\n\n    public function getShowFieldsQuery(?string $table): string;\n\n    public function getFieldCount(): int;\n\n    public function getRowCount(): int;\n}"}
{"instruction": "Write an Ephect PHP component", "input": "Based on Ephect source: PdoSqliteSchemaInfo.php", "output": "<?php\n\nnamespace Ephect\\Modules\\DataAccess\\Client\\PDO\\SchemaInfo;\n\nuse Ephect\\Framework\\Logger\\Logger;\nuse PDOException;\nuse SQLite3;\n\nclass PdoSqliteSchemaInfo extends AbstractPdoSchemaInfo\n{\n    public function getInfo($index): ?object\n    {\n        $name = '';\n        $type = '';\n        $len = 0;\n\n        $connection = new SQLite3(\n            $this->config->getDatabaseName()\n        );\n\n        if ($this->columnNames === null && $this->isQueryATable()) {\n            $this->columnNames = [];\n            $this->columnTypes = [];\n            $table = $this->getQuery();\n            $sql = <<<SQL\n                SELECT * FROM PRAGMA_TABLE_INFO('{$table}');\n                SQL;\n\n            $this->result = $connection->query($sql);\n\n            $names = [];\n            $types = [];\n            while ($row = $this->result->fetchArray()) {\n                $this->columnNames[] = $row[1];\n                $this->columnTypes[] = $row[2];\n            }\n        }\n\n        if ($this->columnTypes !== null) {\n            $name = $this->columnNames[$index];\n            $type = $this->columnTypes[$index];\n            $len = 1024;\n        }\n\n        if ($name == '' && !$this->isQueryATable()) {\n\n            try {\n\n                $sql = $this->getQuery();\n\n                $this->result = $connection->query($sql);\n                // $columns = $this->result->fetchArray();\n                // $columnsCount = count($columns);\n\n                // $sql = str_replace(\"\\n\", \" \", $this->sql);\n                // $sql = str_replace(\"\\r\", \" \", $sql);\n                // $sql = strtolower($sql);\n                // $from = \\strpos($sql, 'from');\n                // $query = \\substr($sql, $from - 1);\n\n                // $columnsTypeofArray = array_map(function($columnName) {\n                //     return \"typeof(\" . $columnName . \")\";\n                // }, $columns );\n\n                // $columnsTypeof = join(', ', $columnsTypeofArray);\n                // $sql = 'select ' . $columnsTypeof . $query;\n                // self::getLogger()->sql($sql);\n                // $this->result = $connection->query($query);\n                // $columnsTypes = $this->result->fetchArray();\n                // $type = $columnsTypes[$index];\n\n                $name = $this->result->columnName($index);\n                $type = $this->result->columnType($index);\n                $len = 32768;\n            } catch (PDOException $ex) {\n                Logger::create()->error($ex);\n            }\n        }\n\n        $this->info = (object)['name' => $name, 'type' => $type, 'length' => $len];\n\n        return $this->info;\n    }\n\n    public function setTypes(): void\n    {\n        $this->native_types = (array)null;\n        $this->native2php_assoc = (array)null;\n        $this->native2php_num = (array)null;\n\n        $this->native_types[1] = \"INTEGER\";\n        $this->native_types[2] = \"TEXT\";\n        $this->native_types[3] = \"BLOB\";\n        $this->native_types[4] = \"REAL\";\n        $this->native_types[5] = \"NUMERIC\";\n\n        $this->native2php_assoc[\"INTEGER\"] = \"int\";\n        $this->native2php_assoc[\"TEXT\"] = \"string\";\n        $this->native2php_assoc[\"BLOB\"] = \"blob\";\n        $this->native2php_assoc[\"REAL\"] = \"float\";\n        $this->native2php_assoc[\"NUMERIC\"] = \"float\";\n\n        $this->native2php_num[1] = \"int\";\n        $this->native2php_num[2] = \"string\";\n        $this->native2php_num[3] = \"blob\";\n        $this->native2php_num[4] = \"float\";\n        $this->native2php_num[5] = \"float\";\n    }\n\n    public function getShowTablesQuery(): string\n    {\n        $sql = <<<SQL\n            SELECT\n                name\n            FROM\n                sqlite_master\n            WHERE\n                type ='table' AND\n                name NOT LIKE 'sqlite_%';\n            SQL;\n\n        return $sql;\n    }\n\n    public function getFieldCount(): int\n    {\n        $result = 0;\n\n        $connection = new SQLite3(\n            $this->config->getDatabaseName()\n        );\n\n        if ($this->isQueryATable()) {\n            $sql = $this->getShowFieldsQuery($this->getQuery());\n            $stmt = $connection->query($sql);\n            $count = 0;\n            while ($row = $stmt->fetchArray()) {\n                $count++;\n            }\n            $result = $count;\n        }\n\n        return $result;\n    }\n\n    public function getShowFieldsQuery(?string $table): string\n    {\n        $sql = <<<SQL\n            SELECT name FROM PRAGMA_TABLE_INFO('{$table}');\n            SQL;\n\n        return $sql;\n    }\n\n    public function getRowCount(): int\n    {\n        $result = 0;\n\n        $connection = new SQLite3(\n            $this->config->getDatabaseName()\n        );\n\n        $sql = $this->getQuery();\n        $stmt = $connection->query($sql);\n        $count = 0;\n        while ($row = $stmt->fetchArray()) {\n            $count++;\n        }\n        $result = $count;\n\n        return $result;\n    }\n}"}
{"instruction": "Write an Ephect PHP component", "input": "Based on Ephect source: ServerType.php", "output": "<?php\n\nnamespace Ephect\\Modules\\DataAccess\\Client\\Base\\Type;\n\nclass ServerType\n{\n    public const MYSQL = 'mysql';\n    public const SQLSERVER = 'sqlsrv';\n    public const SQLITE = 'sqlite';\n    public const PGSQL = 'pgsql';\n}"}
{"instruction": "Write an Ephect PHP component", "input": "Based on Ephect source: AggregatorInterface.php", "output": "<?php\n\nnamespace Ephect\\Framework\\Aggregators;\n\ninterface AggregatorInterface\n{\n    public function add(string $className): void;\n\n    public function aggregate(string $filename): void;\n\n}"}
{"instruction": "Write an Ephect PHP component", "input": "Based on Ephect source: AggregatorTrait.php", "output": "<?php\n\nnamespace Ephect\\Framework\\Aggregators;\n\nuse Ephect\\Framework\\Utils\\File;\nuse Ephect\\Framework\\Utils\\Text;\n\ntrait AggregatorTrait\n{\n    protected array $list = [];\n\n    public function add(string $className): void\n    {\n        $this->list[] = $className;\n    }\n\n    public function aggregate(string $filename): void\n    {\n\n        $elementsList = $this->list;\n        $existingList = file_exists($filename) ? require $filename : null;\n\n        if (is_array($existingList)) {\n            $elementsList = [...$existingList, ...$elementsList];\n            $elementsList = array_unique($elementsList);\n        }\n\n        $json = json_encode($elementsList);\n\n        $elements = Text::jsonToPhpReturnedArray($json);\n\n        File::safeWrite($filename, $elements);\n    }\n}"}
{"instruction": "Write an Ephect component", "input": "Based on Ephect source: ComponentParserMiddlewareAggregatorTrait.php", "output": "<?php\n\nnamespace Ephect\\Framework\\Aggregators;\n\nuse Ephect\\Framework\\Utils\\File;\nuse Ephect\\Framework\\Utils\\Text;\n\ntrait ComponentParserMiddlewareAggregatorTrait\n{\n    use AggregatorTrait;\n\n    protected function aggregateComponentParserMiddlewares()\n    {\n        $middlewaresList = $this->list;\n        $existingMiddlewaresList = [];\n        if (file_exists(\\Constants::BUILD_DIR . 'componentsParserMiddlewares.php')) {\n            $existingMiddlewaresList = require \\Constants::BUILD_DIR . 'componentsParserMiddlewares.php';\n        }\n\n        if (is_array($existingMiddlewaresList)) {\n            $middlewaresList = array_merge($existingMiddlewaresList, $this->list);\n            $middlewaresList = array_unique($middlewaresList);\n        }\n\n        $json = json_encode($middlewaresList);\n\n        $middlewares = Text::jsonToPhpReturnedArray($json);\n\n        File::safeWrite(\\Constants::BUILD_DIR . 'componentsParserMiddlewares.php', $middlewares);\n    }\n}"}
{"instruction": "Write an Ephect PHP component", "input": "Based on Ephect source: MiddlewareAggregatorInterface.php", "output": "<?php\n\nnamespace Ephect\\Framework\\Aggregators;\n\ninterface MiddlewareAggregatorInterface\n{\n    public function aggregateMiddlewares(): void;\n}"}
{"instruction": "Write an Ephect command handler", "input": "Based on Ephect source: Application.php", "output": "<?php\n\nnamespace Ephect\\Framework\\CLI;\n\nuse Ephect\\Commands\\Constants\\Lib;\nuse Ephect\\Framework\\Commands\\ApplicationCommands;\nuse Ephect\\Framework\\Commands\\CommandRunner;\nuse Ephect\\Framework\\Core\\AbstractApplication;\nuse Throwable;\n\nclass Application extends AbstractApplication\n{\n    protected array $argv = [];\n    protected int $argc = 0;\n\n    public static function create(...$params): int\n    {\n        self::$instance = new Application();\n        return self::$instance->run(...$params);\n    }\n\n    public function run(...$params): int\n    {\n        $this->argv = $params[0];\n        $this->argc = $params[1];\n\n        $this->appDirectory = \\Constants::APP_CWD;\n\n        $this->loadInFile();\n\n        self::setExecutionMode(Application::PROD_MODE);\n        self::useTransactions(true);\n\n        $this->init();\n\n        return $this->execute();\n    }\n\n    public function init(): void\n    {\n\n    }\n\n    protected function execute(): int\n    {\n        $commands = new ApplicationCommands($this);\n        $runner = new CommandRunner($this, $commands);\n        return $runner->run();\n\n    }\n\n    /**\n     * Get the CLI argv array\n     *\n     * @return array\n     */\n    public function getArgv(): array\n    {\n        return $this->argv;\n    }\n\n    /**\n     * Get the CLI argc value\n     *\n     * @return integer\n     */\n    public function getArgc(): int\n    {\n        return $this->argc;\n    }\n\n    /**\n     * Get CLI argument by index\n     *\n     * @param integer $index\n     * @param string $default\n     * @return null|string NULL when the index is not in $argc range\n     */\n    public function getArgi(int $index, string $default = ''): string\n    {\n        if ($index > -1 && $this->argc > $index) {\n            return $this->argv[$index];\n        }\n\n        return $default;\n    }\n\n    public function displayConstants(): array\n    {\n        try {\n            $command = new Lib($this);\n            $command->displayConstants();\n        } catch (Throwable $ex) {\n            Console::error($ex);\n\n            return [];\n        }\n    }\n\n}"}
{"instruction": "Write an Ephect PHP component", "input": "Based on Ephect source: Console.php", "output": "<?php\n\nnamespace Ephect\\Framework\\CLI;\n\nuse Constants;\nuse Ephect\\Framework\\CLI\\Enums\\ConsoleOptionsEnum;\nuse Ephect\\Framework\\Element;\nuse Ephect\\Framework\\ElementTrait;\nuse Ephect\\Framework\\Utils\\Text;\nuse ErrorException;\nuse Throwable;\n\nclass Console extends Element\n{\n    use ElementTrait;\n\n    public static function write(string|array|object|null $string, ...$params): void\n    {\n        if (Constants::IS_WEB_APP) {\n            return;\n        }\n\n        $value = Text::format($string, $params);\n\n        echo $value;\n    }\n\n    public static function writeLine(string|array|object|null $string, ...$params): void\n    {\n        if (Constants::IS_WEB_APP) {\n            return;\n        }\n\n\n        $value = $string == null ? '' : Text::format($string, $params);\n\n        echo $value . PHP_EOL;\n    }\n\n    public static function readLine(string $prompt): string\n    {\n\n        $result = readline($prompt);\n        readline_add_history($prompt);\n        readline_add_history($result);\n\n        return $result;\n    }\n\n    public static function readYesOrNo(string $question, string $yes = \"y\", string $no = \"n\", bool $defaultIsNegative = true): bool\n    {\n        $yes = strtolower(trim($yes));\n        $no = strtolower(trim($no));\n\n        $yes = !$defaultIsNegative ? strtoupper($yes) : $yes;\n        $no = $defaultIsNegative ? strtoupper($no) : $no;\n\n        $yesOrNoPrompt = \"[$yes/$no]\";\n        $prompt = $question . \" $yesOrNoPrompt: \";\n        $answerYN = readline($prompt);\n\n        $startTime = time();\n        $answerYN = strtolower(trim($answerYN));\n        while ($answerYN != 'y' && $answerYN != 'n' && $answerYN != '') {\n            $answerYN = readline($prompt);\n            $answerYN = strtolower(trim($answerYN));\n            $elapsedTime = time() - $startTime;\n            if ($elapsedTime > 29) {\n                break;\n            }\n        }\n\n        readline_add_history($prompt);\n        readline_add_history($answerYN);\n\n        return $answerYN == $yes;\n    }\n\n\n    public static function info(string|array|object|null $string, ...$params): void\n    {\n        $string = $string ?: '';\n\n        if (Constants::IS_WEB_APP) {\n            self::getLogger()->info($string);\n            return;\n        }\n\n        $value = Text::format($string, $params);\n        echo $value . PHP_EOL;\n    }\n\n    public static function log(string|array|object|null $string, ...$params): void\n    {\n        $string = $string ?: '';\n\n        if (Constants::IS_WEB_APP) {\n            self::getLogger()->debug($string);\n            return;\n        }\n\n        $value = Text::format($string, $params);\n        echo $value . PHP_EOL;\n    }\n\n    public static function error(Throwable $ex, ConsoleOptionsEnum $options = ConsoleOptionsEnum::None): void\n    {\n        if (Constants::IS_WEB_APP) {\n            self::getLogger()->error($ex);\n            return;\n        }\n\n        $message = $options === ConsoleOptionsEnum::ErrorMessageOnly ? $ex->getMessage() : self::formatException($ex);\n        print \"\\033[41m\\033[1;37m\" . $message . \"\\033[0m\\033[0m\";\n    }\n\n    public static function formatException(Throwable $ex): string\n    {\n        $message = '';\n\n        if ($ex instanceof ErrorException) {\n            $message .= 'Error severity: ' . $ex->getSeverity() . PHP_EOL;\n        }\n        $message .= 'Error code: ' . $ex->getCode() . PHP_EOL;\n        $message .= 'In ' . $ex->getFile() . ', line ' . $ex->getLine() . PHP_EOL;\n        $message .= 'With the message: ' . $ex->getMessage() . PHP_EOL;\n        $message .= 'Stack trace: ' . $ex->getTraceAsString() . PHP_EOL;\n\n        return $message;\n    }\n\n}"}
{"instruction": "Write an Ephect PHP component", "input": "Based on Ephect source: ConsoleColors.php", "output": "<?php\n\nnamespace Ephect\\Framework\\CLI;\n\nclass ConsoleColors\n{\n    // Set up shell colors\n    public const BLACK = '0;30';\n    public const DARK_GRAY = '1;30';\n    public const BLUE = '0;34';\n    public const LIGHT_BLUE = '1;34';\n    public const GREEN = '0;32';\n    public const LIGHT_GREEN = '1;32';\n    public const CYAN = '0;36';\n    public const LIGHT_CYAN = '1;36';\n    public const RED = '0;31';\n    public const LIGHT_RED = '1;31';\n    public const PURPLE = '0;35';\n    public const LIGHT_PURPLE = '1;35';\n    public const BROWN = '0;33';\n    public const YELLOW = '1;33';\n    public const LIGHT_GRAY = '0;37';\n    public const WHITE = '1;37';\n\n    public const BACKGROUND_BLACK = '40';\n    public const BACKGROUND_RED = '41';\n    public const BACKGROUND_GREEN = '42';\n    public const BACKGROUND_YELLOW = '43';\n    public const BACKGROUND_BLUE = '44';\n    public const BACKGROUND_MAGENTA = '45';\n    public const BACKGROUND_CYAN = '46';\n    public const BACKGROUND_LIGHT_GRAY = '47';\n\n    // Returns coloRED string\n    public static function getColoredString($string, $foreground_color = null, $background_color = null): string\n    {\n        $colored_string = \"\";\n        $suffix = \"\\033[0m\";\n\n        // Check if given foreground color found\n        if (isset($foreground_color)) {\n            $colored_string .= \"\\033[\" . $foreground_color . \"m\";\n        }\n        // Check if given background color found\n        if (isset($background_color)) {\n            $colored_string = \"\\033[\" . $background_color . \"m\" . $colored_string;\n            $suffix .= $suffix;\n        }\n\n        // Add string and end coloring\n        $colored_string .= $string . $suffix;\n\n        return $colored_string;\n    }\n}"}
{"instruction": "Write an Ephect PHP component", "input": "Based on Ephect source: Cache.php", "output": "<?php\n\nnamespace Ephect\\Framework\\Cache;\n\nuse Ephect\\Framework\\CLI\\Console;\nuse Ephect\\Framework\\StaticElement;\nuse Ephect\\Framework\\Utils\\File;\nuse Throwable;\n\nclass Cache extends StaticElement\n{\n    public static function getCacheFilename(string $basename): string\n    {\n        return \\Constants::CACHE_DIR . str_replace('/', '_', $basename);\n    }\n\n    public static function getBuildFilename(string $basename): string\n    {\n        return \\Constants::BUILD_DIR . str_replace('/', '_', $basename);\n    }\n\n\n    public static function cacheFilenameFromView(string $compName): string\n    {\n\n        // $uri = bin2hex(\\Constants::REQUEST_URI);\n        $uri = '';\n        return \\Constants::REL_RUNTIME_DIR . strtolower($compName) . $uri . \\Constants::CLASS_EXTENSION;\n    }\n\n    public static function absoluteURL(string $relativeURL = ''): string\n    {\n        return (\n            \\Constants::HTTP_HOST !== \\Constants::SERVER_NAME\n                ? \\Constants::SERVER_HOST\n                : \\Constants::SERVER_ROOT\n        ) . \\Constants::REWRITE_BASE . $relativeURL;\n    }\n\n    public static function cachePath(string $filepath): string\n    {\n        return str_replace(DIRECTORY_SEPARATOR, '_', $filepath);\n    }\n\n    public static function cacheFile($filename, $content): void\n    {\n        $filename = \\Constants::BUILD_DIR . $filename;\n        file_put_contents($filename, $content);\n    }\n\n    public static function clearRuntime(): bool\n    {\n        $result = false;\n        try {\n            $result &= self::clearCache();\n            $result &= self::clearRuntimeDirs();\n            $result &= self::clearRuntimeJsDirs();\n        } catch (Throwable $ex) {\n            Console::error($ex);\n\n            $result = false;\n        }\n        return $result;\n    }\n\n    public static function clearCache(): bool\n    {\n        $result = false;\n        if (file_exists(\\Constants::CACHE_DIR)) {\n            $result &= File::delTree(\\Constants::CACHE_DIR);\n        }\n\n        return $result;\n    }\n\n    public static function clearRuntimeDirs(): bool\n    {\n        $result = false;\n        if (file_exists(\\Constants::RUNTIME_DIR)) {\n            $result &= File::delTree(\\Constants::RUNTIME_DIR);\n        }\n        return $result;\n    }\n\n    public static function clearRuntimeJsDirs(): bool\n    {\n        $result = false;\n        if (file_exists(\\Constants::RUNTIME_JS_DIR)) {\n            $result &= File::delTree(\\Constants::RUNTIME_JS_DIR);\n        }\n        return $result;\n    }\n}"}
{"instruction": "Write an Ephect command handler", "input": "Based on Ephect source: AbstractCommand.php", "output": "<?php\n\nnamespace Ephect\\Framework\\Commands;\n\nuse Ephect\\Framework\\CLI\\Application;\nuse Ephect\\Framework\\Element;\n\nabstract class AbstractCommand extends Element implements CommandInterface\n{\n    public function __construct(protected Application $application)\n    {\n        parent::__construct();\n    }\n}"}
{"instruction": "Write an Ephect command handler", "input": "Based on Ephect source: AbstractCommandLib.php", "output": "<?php\n\nnamespace Ephect\\Framework\\Commands;\n\nuse Ephect\\Framework\\CLI\\Application;\nuse Ephect\\Framework\\Element;\n\nabstract class AbstractCommandLib extends Element\n{\n    public function __construct(Application $application)\n    {\n        parent::__construct($application);\n    }\n}"}
{"instruction": "Write an Ephect command handler", "input": "Based on Ephect source: ApplicationCommands.php", "output": "<?php\n\nnamespace Ephect\\Framework\\Commands;\n\nuse Ephect\\Framework\\Core\\AbstractApplication;\nuse Ephect\\Framework\\Element;\nuse Ephect\\Framework\\ElementUtils;\nuse Ephect\\Framework\\Logger\\Logger;\nuse Ephect\\Framework\\Modules\\ModuleInstaller;\nuse Ephect\\Framework\\Registry\\CommandRegistry;\nuse Ephect\\Framework\\Registry\\StateRegistry;\nuse Ephect\\Framework\\Utils\\File;\n\nclass ApplicationCommands extends Element implements CommandCollectionInterface\n{\n    private array $_commands = [];\n\n    public function __construct(private readonly AbstractApplication $_application)\n    {\n        parent::__construct($this->_application);\n\n        $this->collectCommands();\n    }\n\n    private function collectCommands(): void\n    {\n        $usage = [];\n        $commandFiles = File::walkTreeFiltered(\\Constants::COMMANDS_ROOT, ['php']);\n        $allFiles = [\n            (object)[\"root\" => \\Constants::COMMANDS_ROOT, \"files\" => $commandFiles],\n        ];\n\n        if (file_exists(\\Constants::CUSTOM_COMMANDS_ROOT)) {\n            $customCommandFiles = File::walkTreeFiltered(\\Constants::CUSTOM_COMMANDS_ROOT, ['php']);\n            $allFiles[] = (object)[\"root\" => \\Constants::CUSTOM_COMMANDS_ROOT, \"files\" => $customCommandFiles];\n        }\n\n        if (file_exists(\\Constants::PLUGINS_ROOT)) {\n            $moduleCommandFiles = File::walkTreeFiltered(\\Constants::PLUGINS_ROOT, ['php']);\n            $allFiles[] = (object)[\"root\" => \\Constants::PLUGINS_ROOT, \"files\" => $moduleCommandFiles];\n        }\n\n        [$filename, $modulePaths] = ModuleInstaller::readModulePaths();\n        foreach ($modulePaths as $path) {\n            $moduleSrcPathFile = $path . DIRECTORY_SEPARATOR . \\Constants::REL_CONFIG_DIR . \\Constants::REL_CONFIG_APP;\n            $moduleSrcPath = file_exists($moduleSrcPathFile)\n                ? $path . DIRECTORY_SEPARATOR . file_get_contents($moduleSrcPathFile)\n                : $path . DIRECTORY_SEPARATOR . \\Constants::REL_CONFIG_APP;\n            $moduleSrcPath = is_dir($moduleSrcPath) ? $moduleSrcPath : $path;\n\n            $moduleCommandsPath = $moduleSrcPath . DIRECTORY_SEPARATOR . 'Commands';\n\n            if (file_exists($moduleCommandsPath)) {\n                $moduleCommandFiles = File::walkTreeFiltered($moduleCommandsPath, ['php']);\n                $allFiles[] = (object)[\"root\" => $moduleCommandsPath, \"files\" => $moduleCommandFiles];\n            }\n        }\n\n        CommandRegistry::load();\n\n        foreach ($allFiles as $entry) {\n            $root_dir = $entry->root;\n            foreach ($entry->files as $filename) {\n                [$namespace, $class] = ElementUtils::getClassDefinitionFromFile($root_dir . $filename);\n                $fqClass = \"$namespace\\\\$class\";\n\n                $connandClass = CommandRegistry::read($fqClass);\n                if ($connandClass !== null) {\n                    Logger::create()->info(\"$connandClass has already been initialized.\");\n                    continue;\n                }\n\n                if ($class !== 'Main') {\n                    continue;\n                }\n\n                CommandRegistry::write($fqClass, $root_dir . $filename);\n\n                include $root_dir . $filename;\n                $object = new $fqClass($this->_application);\n\n                $attr = Element::getClassAttributesData($object);\n                $commandArgs = $attr[0]['args'];\n\n                $verb = $commandArgs['verb'];\n                $subject = $commandArgs['subject'] ?? '';\n                $desc = $commandArgs['desc'];\n                $isPhar = $commandArgs['isPhar'] ?? '';\n\n                if ($isPhar) {\n                    continue;\n                }\n\n                if ($subject !== '') {\n                    $usage[$verb . $subject] = \"\\t$verb:$subject => $desc\" . PHP_EOL;\n                } else {\n                    $usage[$verb] = \"\\t$verb => $desc\" . PHP_EOL;\n                }\n                $commandArgs['callback'] = $object;\n\n                $this->_commands[] = $commandArgs;\n            }\n        }\n\n        ksort($usage);\n\n        StateRegistry::writeItem('commands', $usage);\n    }\n\n    public function commands(): array\n    {\n        return $this->_commands;\n    }\n}"}
{"instruction": "Write an Ephect command handler", "input": "Based on Ephect source: Builder.php", "output": "<?php\n\nnamespace Ephect\\Framework\\Commands;\n\nuse Ephect\\Framework\\Templates\\TemplateMaker;\n\nclass Builder\n{\n    /**\n     * Third and last creation step of the User Command\n     *\n     * Read templates text, replace the markups and save into user application directory\n     *\n     * @param string $verb\n     * @param string $subject\n     * @param string $description\n     * @param string $methodName\n     * @param array $arguments\n     * @param string $srcDir\n     * @param string $destDir\n     * @return void\n     */\n    public function copyTemplates(string $verb, string $subject, string $description, string $methodName, array $arguments, string $srcDir, string $destDir): void\n    {\n        $commandNamespace = ucfirst($verb) . ucfirst($subject);\n        $commandAttributes = 'verb: \"' . $verb . '\"';\n        $commandAttributes = $subject !== \"\" ? $commandAttributes . ', subject: \"' . $subject . '\"' : $commandAttributes;\n        $commandTemplatesDir = \\Constants::EPHECT_ROOT . 'Templates' . DIRECTORY_SEPARATOR . 'Commands' . DIRECTORY_SEPARATOR;\n\n        $mainTextMaker = new TemplateMaker($commandTemplatesDir . 'Main.tpl');\n        $libTextMaker = new TemplateMaker($commandTemplatesDir . 'Lib.tpl');\n\n        $mainTextMaker->make([\n            'ApplicationNamespace' => \\Constants::CONFIG_NAMESPACE,\n            'CommandNamespace' => $commandNamespace,\n            'CommandAttributes' => $commandAttributes,\n            'Description' => $description,\n            'MethodName' => $methodName,\n        ]);\n\n        $libTextMaker->make([\n            'ApplicationNamespace' => \\Constants::CONFIG_NAMESPACE,\n            'CommandNamespace' => $commandNamespace,\n            'MethodName' => $methodName,\n        ]);\n\n        if (count($arguments) > 0) {\n            $getargs = '';\n            $l = count($arguments);\n            for ($i = 0; $i < $l; $i++) {\n                $j = $i + 2;\n                $getargs .= <<< ARGS\n                \\$$arguments[$i] = \\$this->application->getArgi($j);\\n\n                ARGS;\n                $getargs .= '        ';\n            }\n\n            $libParams = array_map(function ($property) {\n                return \"\\$$property\";\n            }, $arguments);\n            $setargs = implode(', ', $libParams);\n\n            $properties = array_map(function ($property) {\n                return \"string \\$$property\";\n            }, $arguments);\n\n            $parameters = implode(', ', $properties);\n\n            $mainTextMaker->make([\n                'GetArgs' => $getargs,\n                'SetArgs' => $setargs,\n            ]);\n\n            $libTextMaker->make([\n                'Parameters' => $parameters,\n            ]);\n        } else {\n            $mainTextMaker->make([\n                'GetArgs' => '',\n                'SetArgs' => '',\n            ]);\n\n            $libTextMaker->make([\n                'Parameters' => '',\n            ]);\n        }\n\n        $mainTextMaker->save($destDir . \"Main.php\");\n        $libTextMaker->save($destDir . \"Lib.php\");\n    }\n}"}
{"instruction": "Write an Ephect command handler", "input": "Based on Ephect source: CommandCollectionInterface.php", "output": "<?php\n\nnamespace Ephect\\Framework\\Commands;\n\ninterface CommandCollectionInterface\n{\n    public function commands(): array;\n}"}
{"instruction": "Write an Ephect command handler", "input": "Based on Ephect source: CommandInterface.php", "output": "<?php\n\nnamespace Ephect\\Framework\\Commands;\n\ninterface CommandInterface\n{\n    public function run(): int;\n}"}
{"instruction": "Write an Ephect command handler", "input": "Based on Ephect source: CommandRunner.php", "output": "<?php\n\nnamespace Ephect\\Framework\\Commands;\n\nuse Ephect\\Framework\\CLI\\Application;\nuse Ephect\\Framework\\CLI\\Console;\nuse Ephect\\Framework\\Element;\n\nclass CommandRunner extends Element\n{\n    public function __construct(\n        private readonly Application                $_application,\n        private readonly CommandCollectionInterface $_commands\n    ) {\n    }\n\n    public function run(): int\n    {\n        $callback = null;\n\n        $isFound = false;\n        $commands = $this->_commands->commands();\n\n        foreach ($commands as $command) {\n            $struct = new CommandStructure($command);\n\n            $callback = $struct->callback;\n\n            $verb = $struct->verb;\n            $subject = $struct->subject;\n\n            $call = $subject != '' ? $verb . ':' . $subject : $verb;\n            $commandLabel = !isset($aav[1]) ? '' : $aav[1];\n\n            $aac = $this->_application->getArgc();\n            $aav = $this->_application->getArgv();\n\n            for ($i = 1; $i < $aac; $i++) {\n                if ($aav[$i] == $call) {\n                    $isFound = true;\n\n                    if (isset($aav[$i + 1])) {\n                        if (!str_starts_with($aav[$i + 1], '-')) {\n                            $arguments = $aav[$i + 1];\n                        }\n                    }\n\n                    break;\n                }\n            }\n\n            if ($isFound) {\n                break;\n            }\n        }\n\n        $status = 1;\n        if ($callback !== null && $isFound) {\n            $status = $callback->run();\n        }\n\n        if (!$isFound) {\n            Console::writeLine(\"A command labelled %s was not found\", $commandLabel);\n        }\n\n        return $status;\n    }\n}"}
{"instruction": "Write an Ephect command handler", "input": "Based on Ephect source: CommandStructure.php", "output": "<?php\n\nnamespace Ephect\\Framework\\Commands;\n\nuse Ephect\\Framework\\Structure\\Structure;\n\nclass CommandStructure extends Structure\n{\n    public string $subject = '';\n    public string $verb = '';\n    public string $desc = '';\n    public bool $isPhar = false;\n    public $callback = null;\n}"}
{"instruction": "Write an Ephect PHP component", "input": "Based on Ephect source: AbstractConfiguration.php", "output": "<?php\n\nnamespace Ephect\\Framework\\Configuration;\n\nuse Ephect\\Framework\\Element;\n\nabstract class AbstractConfiguration extends Element implements ConfigurableInterface\n{\n    protected $filename = '';\n    protected $canConfigure = false;\n\n    public function loadConfiguration(string $filename): bool\n    {\n        $this->canConfigure = file_exists($filename);\n\n        if (!$this->canConfigure) {\n            return false;\n        }\n\n        $this->filename = $filename;\n        $this->configure();\n\n        return true;\n    }\n}"}
{"instruction": "Write an Ephect PHP component", "input": "Based on Ephect source: ConfigElement.php", "output": "<?php\n\nnamespace Ephect\\Framework\\Configuration;\n\nuse Ephect\\Framework\\Element;\n\nclass ConfigElement extends Element\n{\n    private string $name = '';\n    private string $value = '';\n    private string $type = '';\n\n    public function __construct($id, $name, $value)\n    {\n        parent::__construct($this);\n        $this->id = $id;\n        $this->name = $name;\n        $this->value = $value;\n    }\n\n    public function getName(): string\n    {\n        return $this->name;\n    }\n\n    public function getValue(): string\n    {\n        return $this->value;\n    }\n\n    public function getType(): string\n    {\n        return $this->type;\n    }\n\n\n}"}
{"instruction": "Write an Ephect PHP component", "input": "Based on Ephect source: ConfigurableInterface.php", "output": "<?php\n\nnamespace Ephect\\Framework\\Configuration;\n\ninterface ConfigurableInterface\n{\n    public function configure(): void;\n\n    public function loadConfiguration(string $filename): bool;\n}"}
{"instruction": "Write an Ephect PHP component", "input": "Based on Ephect source: AbstractApplication.php", "output": "<?php\n\nnamespace Ephect\\Framework\\Core;\n\nuse Ephect\\Framework\\Cache\\Cache;\nuse Ephect\\Framework\\CLI\\Console;\nuse Ephect\\Framework\\Element;\nuse Ephect\\Framework\\Registry\\StateRegistry;\nuse Ephect\\Plugins\\Authentication\\AuthenticationService;\nuse Throwable;\n\nabstract class AbstractApplication extends Element\n{\n    use IniLoaderTrait;\n\n    public const DEBUG_MODE = 'DEBUG';\n    public const TEST_MODE = 'TEST';\n    public const PROD_MODE = 'PROD';\n\n    private static string $executionMode = self::PROD_MODE;\n    private static bool $verboseMode = false;\n    private static bool $useTransactions = true;\n\n    protected array $commands = [];\n    protected array $callbacks = [];\n    protected string|null $appName = 'app';\n    protected string $appTitle = '';\n    protected string $scriptName = 'app.php';\n    protected string $appDirectory = '';\n    protected bool $canStop = false;\n    protected string $dataConfName = '';\n    private string $usage = '';\n    private array $appini = [];\n\n    public function __construct()\n    {\n        parent::__construct();\n    }\n\n    public static function getExecutionMode(): string\n    {\n        return self::$executionMode;\n    }\n\n    public static function setExecutionMode($myExecutionMode): void\n    {\n        if (!$myExecutionMode) {\n            $myExecutionMode = (\\Constants::IS_WEB_APP) ? 'debug' : 'prod';\n        }\n\n        $prod = ($myExecutionMode == 'prod');\n        $test = ($myExecutionMode == 'test' || $myExecutionMode == 'devel' || $myExecutionMode == 'dev');\n        $debug = ($myExecutionMode == 'debug');\n\n        if ($prod) {\n            self::$executionMode = self::PROD_MODE;\n        }\n        if ($test) {\n            self::$executionMode = self::TEST_MODE;\n        }\n        if ($debug) {\n            self::$executionMode = self::DEBUG_MODE;\n        }\n    }\n\n    public static function getVerboseMode(): bool\n    {\n        return self::$verboseMode;\n    }\n\n    public static function setVerboseMode($set = false): void\n    {\n        self::$verboseMode = $set;\n    }\n\n    public static function getTransactionUse(): bool\n    {\n        return self::$useTransactions;\n    }\n\n    public static function useTransactions($set = true): void\n    {\n        self::$useTransactions = $set;\n    }\n\n    public static function isProd(): bool\n    {\n        return self::$executionMode == self::PROD_MODE;\n    }\n\n    public static function isTest(): bool\n    {\n        return self::$executionMode == self::TEST_MODE;\n    }\n\n    public static function isDebug(): bool\n    {\n        return self::$executionMode == self::DEBUG_MODE;\n    }\n\n    public static function authenticateByToken($token): string\n    {\n\n        // On prend le token en cours\n        if (is_string($token)) {\n            // avec ce token on r\u00e9cup\u00e8re l'utilisateur et un nouveau token\n            $token = AuthenticationService::getPermissionByToken($token);\n        }\n\n        return $token;\n    }\n\n    abstract public function run(...$params): int;\n\n    abstract public function displayConstants(): array;\n\n    public function clearLogs(): string\n    {\n        $result = '';\n        try {\n            self::getLogger()->clearAll();\n\n            $result = 'All logs cleared';\n        } catch (Throwable $ex) {\n            Console::error($ex);\n\n            $result = 'Impossible to clear logs';\n        }\n        return $result;\n    }\n\n    public function clearRuntime(): string\n    {\n        $result = '';\n        try {\n            Cache::clearRuntime();\n\n            $result = 'All runtime files deleted';\n        } catch (Throwable $ex) {\n            Console::error($ex);\n\n            $result = 'Impossible to delete runtime files';\n        }\n        return $result;\n    }\n\n    public function clearCache(): string\n    {\n        $result = '';\n        try {\n            Cache::clearCache();\n\n            $result = 'All cache files deleted';\n        } catch (Throwable $ex) {\n            Console::error($ex);\n\n            $result = 'Impossible to delete cache files';\n        }\n        return $result;\n    }\n\n    public function getDebugLog(): string\n    {\n        return self::getLogger()->getDebugLog();\n    }\n\n    public function getPhpErrorLog(): string\n    {\n        return self::getLogger()->getPhpErrorLog();\n    }\n\n    public function loadInFile(): void\n    {\n        try {\n            $exist = $this->loadINI(\\Constants::CONFIG_DIR);\n            if (!$exist) {\n                return;\n            }\n\n            $this->appName = StateRegistry::readItem('application', 'name');\n            $this->appTitle = StateRegistry::readItem('application', 'title');\n\n        } catch (Throwable $ex) {\n            Console::error($ex);\n        }\n    }\n\n    public function help(): int\n    {\n        $help = '';\n        Console::writeLine($this->getName());\n        Console::writeLine('Expected commands : ');\n        $usage = StateRegistry::item('commands');\n        foreach ($usage as $long => $desc) {\n            $help .= $desc;\n        }\n        Console::writeLine($help);\n\n        return 0;\n    }\n\n    public function getName(): string|null\n    {\n        if (empty($this->appName) || $this->appName == 'app') {\n            $this->appName = StateRegistry::ini('application', 'name');\n        }\n\n        return $this->appName;\n    }\n\n    public function getTitle(): string\n    {\n        return $this->appTitle;\n    }\n\n    public function getDirectory(): string\n    {\n        return $this->appDirectory;\n    }\n\n    public function canStop(): bool\n    {\n        return $this->canStop;\n    }\n\n    public function getOS(): string\n    {\n        return PHP_OS;\n    }\n\n    abstract protected function execute(): int;\n\n    //    protected function execute(): int {\n    //        return 0;\n    //    }\n}"}
{"instruction": "Write an Ephect PHP component", "input": "Based on Ephect source: Autoloader.php", "output": "<?php\n\nnamespace Ephect\\Framework\\Core;\n\nuse Ephect\\Framework\\Logger\\Logger;\nuse Ephect\\Framework\\Registry\\FrameworkRegistry;\n\nclass Autoloader\n{\n    /**\n     * Registers the autoloader class with the PHP SPL autoloader.\n     *\n     * @param bool $prepend Prepend the autoloader on the stack instead of appending it.\n     */\n    public static function register(bool $prepend = false): void\n    {\n        spl_autoload_register(array(new self(), 'load'), true, $prepend);\n    }\n\n    public static function load($className): void\n    {\n        $classFilename = FrameworkRegistry::read($className);\n        if (empty($classFilename)) {\n            Logger::create()->debug(\"Autoloader: Class `$className` not found in registry\");\n            return;\n        }\n\n        include $classFilename;\n    }\n}"}
{"instruction": "Write an Ephect component", "input": "Based on Ephect source: ConstantsMaker.php", "output": "<?php\n\nnamespace Ephect\\Framework\\Core;\n\nuse Ephect\\Framework\\CLI\\Console;\nuse Ephect\\Framework\\Utils\\File;\nuse Ephect\\Framework\\Utils\\Text;\n\nclass ConstantsMaker\n{\n    private array $constants = [];\n\n    private bool $isWebApp = false;\n\n    public function __construct()\n    {\n        $this->define();\n    }\n\n    private function define()\n    {\n        // TODO: Implement __invoke() method.\n        $document_root = isset($_SERVER['DOCUMENT_ROOT']) && !empty($_SERVER['DOCUMENT_ROOT']) ? $_SERVER['DOCUMENT_ROOT'] . DIRECTORY_SEPARATOR : '';\n\n        $this->isWebApp = $document_root !== '';\n        $this->constants['DONT_USE_IS_WEB_APP'] = $this->isWebApp;\n        $this->constants['DONT_USE_IS_PHAR_APP'] = false; //(Phar::running() !== '');\n        //        $this->constants['DONT_USE_IS_CLI_APP'] = (Phar::running() === '') && !DONT_USE_IS_WEB_APP;\n        $this->constants['DONT_USE_IS_CLI_APP'] = !$this->isWebApp;\n        $this->constants['DONT_USE_REL_CONFIG_DIR'] = 'config' . DIRECTORY_SEPARATOR;\n        $this->constants['DONT_USE_REL_CONFIG_APP'] = 'app';\n\n        if ($this->isWebApp) {\n            $this->constants['DONT_USE_DOCUMENT_ROOT'] = $document_root;\n\n            $site_root = dirname($this->constants['DONT_USE_DOCUMENT_ROOT']) . DIRECTORY_SEPARATOR;\n\n            $this->constants['DONT_USE_SITE_ROOT'] = $site_root;\n            $this->constants['DONT_USE_CONFIG_DIR'] = $this->constants['DONT_USE_SITE_ROOT'] . $this->constants['DONT_USE_REL_CONFIG_DIR'];\n            $this->constants['DONT_USE_CONFIG_FRAMEWORK'] = str_replace(\n                '/',\n                DIRECTORY_SEPARATOR,\n                file_exists($this->constants['DONT_USE_CONFIG_DIR'] . 'framework')\n                    ? trim(file_get_contents($this->constants['DONT_USE_CONFIG_DIR'] . 'framework'))\n                    : 'vendor/ephect-io/framework/Ephect'\n            );\n\n            $this->constants['DONT_USE_AJIL_CONFIG'] = str_replace(\n                '/',\n                DIRECTORY_SEPARATOR,\n                file_exists($this->constants['DONT_USE_CONFIG_DIR'] . 'javascripts')\n                    ? trim(file_get_contents($this->constants['DONT_USE_CONFIG_DIR'] . 'javascripts'))\n                    : 'vendor/ephect-io/javascripts/Ajil'\n            );\n\n            $this->constants['DONT_USE_CONFIG_APP'] = file_exists($this->constants['DONT_USE_CONFIG_DIR'] . $this->constants['DONT_USE_REL_CONFIG_APP'])\n                ? trim(file_get_contents($this->constants['DONT_USE_CONFIG_DIR'] . $this->constants['DONT_USE_REL_CONFIG_APP']))\n                : $this->constants['DONT_USE_REL_CONFIG_APP'];\n            $this->constants['DONT_USE_SRC_ROOT'] = $this->constants['DONT_USE_SITE_ROOT'] . $this->constants['DONT_USE_CONFIG_APP'] . DIRECTORY_SEPARATOR;\n\n            $this->constants['DONT_USE_EPHECT_ROOT'] = $this->constants['DONT_USE_SITE_ROOT'] . $this->constants['DONT_USE_CONFIG_FRAMEWORK'] . DIRECTORY_SEPARATOR;\n            $this->constants['DONT_USE_AJIL_ROOT'] = $this->constants['DONT_USE_SITE_ROOT'] . $this->constants['DONT_USE_AJIL_CONFIG'] . DIRECTORY_SEPARATOR;\n\n            $appname = pathinfo($this->constants['DONT_USE_SITE_ROOT'], PATHINFO_FILENAME);\n            $this->constants['DONT_USE_APP_NAME'] = $appname;\n\n            $this->constants['DONT_USE_AJIL_VENDOR_SRC'] = $this->constants['DONT_USE_AJIL_ROOT'];\n            $this->constants['DONT_USE_EPHECT_VENDOR_SRC'] = $this->constants['DONT_USE_EPHECT_ROOT'];\n            $this->constants['DONT_USE_EPHECT_VENDOR_LIB'] = $this->constants['DONT_USE_EPHECT_VENDOR_SRC'] . 'Framework' . DIRECTORY_SEPARATOR;\n            $this->constants['DONT_USE_EPHECT_VENDOR_APPS'] = $this->constants['DONT_USE_EPHECT_VENDOR_SRC'] . 'Apps' . DIRECTORY_SEPARATOR;\n\n            $rewrite_base = '/';\n\n            if (file_exists($this->constants['DONT_USE_CONFIG_DIR'] . 'DONT_USE_REWRITE_BASE') && $rewrite_base = file_get_contents($this->constants['DONT_USE_CONFIG_DIR'] . 'DONT_USE_REWRITE_BASE')) {\n                $rewrite_base = trim($rewrite_base);\n            }\n            $this->constants['DONT_USE_REWRITE_BASE'] = $rewrite_base;\n\n            $scheme = 'http';\n            if (str_contains($_SERVER['SERVER_SOFTWARE'], 'IIS')) {\n                $scheme = ($_SERVER['HTTPS'] == 'off') ? 'http' : 'https';\n            } elseif (str_contains($_SERVER['SERVER_SOFTWARE'], 'Apache')) {\n                $scheme = $_SERVER['REQUEST_SCHEME'];\n            } elseif (str_contains($_SERVER['SERVER_SOFTWARE'], 'lighttpd')) {\n                $scheme = str_contains($_SERVER['SERVER_PROTOCOL'], 'HTPPS') ? 'https' : 'http';\n            } elseif (str_contains($_SERVER['SERVER_SOFTWARE'], 'nginx')) {\n                $scheme = str_contains($_SERVER['SERVER_PROTOCOL'], 'HTPPS') ? 'https' : 'http';\n            }\n\n            $this->constants['DONT_USE_HTTP_PROTOCOL'] = $scheme;\n            $this->constants['DONT_USE_HTTP_USER_AGENT'] = $_SERVER['HTTP_USER_AGENT'] ?? '';\n            $this->constants['DONT_USE_HTTP_HOST'] = $_SERVER['HTTP_HOST'];\n            $this->constants['DONT_USE_HTTP_ORIGIN'] = $_SERVER['HTTP_ORIGIN'] ?? '';\n            $this->constants['DONT_USE_HTTP_ACCEPT'] = $_SERVER['HTTP_ACCEPT'] ?: '';\n            $this->constants['DONT_USE_HTTP_PORT'] = $_SERVER['SERVER_PORT'];\n            $this->constants['DONT_USE_COOKIE'] = $_COOKIE;\n            $this->constants['DONT_USE_REQUEST_URI'] = $_SERVER['REQUEST_URI'];\n            $this->constants['DONT_USE_REQUEST_METHOD'] = $_SERVER['REQUEST_METHOD'];\n            $this->constants['DONT_USE_QUERY_STRING'] = parse_url($this->constants['DONT_USE_REQUEST_URI'], PHP_URL_QUERY) ?: '';\n            $this->constants['DONT_USE_SERVER_NAME'] = $_SERVER['SERVER_NAME'];\n            $this->constants['DONT_USE_SERVER_HOST'] = $this->constants['DONT_USE_HTTP_PROTOCOL'] . '://' . $this->constants['DONT_USE_HTTP_HOST'];\n            $this->constants['DONT_USE_SERVER_ROOT'] = $this->constants['DONT_USE_HTTP_PROTOCOL'] . '://' . $this->constants['DONT_USE_SERVER_NAME'] . (($this->constants['DONT_USE_HTTP_PORT'] !== '80' && $this->constants['DONT_USE_HTTP_PORT'] !== '443') ? ':' . $this->constants['DONT_USE_HTTP_PORT'] : '');\n            $this->constants['DONT_USE_BASE_URI'] = $this->constants['DONT_USE_SERVER_NAME'] . (($this->constants['DONT_USE_HTTP_PORT'] !== '80') ? ':' . $this->constants['DONT_USE_HTTP_PORT'] : '') . (($this->constants['DONT_USE_REQUEST_URI'] !== '') ? $this->constants['DONT_USE_REQUEST_URI'] : '');\n            $this->constants['DONT_USE_FULL_URI'] = $this->constants['DONT_USE_HTTP_PROTOCOL'] . '://' . $this->constants['DONT_USE_BASE_URI'];\n            $this->constants['DONT_USE_FULL_SSL_URI'] = 'https://' . $this->constants['DONT_USE_BASE_URI'];\n        }\n\n        if (!$this->isWebApp) {\n            [$app_path] = get_included_files();\n            $script_name = pathinfo($app_path, PATHINFO_BASENAME);\n            $script_dir = pathinfo($app_path, PATHINFO_DIRNAME);\n            $appName = pathinfo($script_name)['filename'];\n            $script_root = $script_dir . DIRECTORY_SEPARATOR;\n\n            $this->constants['DONT_USE_APP_CWD'] = str_replace($script_name, '', $app_path);\n            $this->constants['DONT_USE_SITE_ROOT'] = $script_root;\n\n            $this->constants['DONT_USE_CONFIG_DIR'] = $this->constants['DONT_USE_SITE_ROOT'] . 'config' . DIRECTORY_SEPARATOR;\n            $this->constants['DONT_USE_CONFIG_FRAMEWORK'] = str_replace(\n                '/',\n                DIRECTORY_SEPARATOR,\n                file_exists($this->constants['DONT_USE_CONFIG_DIR'] . 'framework')\n                    ? trim(file_get_contents($this->constants['DONT_USE_CONFIG_DIR'] . 'framework'))\n                    : 'vendor/ephect-io/framework/Ephect'\n            );\n\n            $this->constants['DONT_USE_EPHECT_ROOT'] = $this->constants['DONT_USE_SITE_ROOT'] . $this->constants['DONT_USE_CONFIG_FRAMEWORK'] . DIRECTORY_SEPARATOR;\n            $this->constants['DONT_USE_CONFIG_APP'] = file_exists($this->constants['DONT_USE_CONFIG_DIR'] . 'app') ? trim(file_get_contents($this->constants['DONT_USE_CONFIG_DIR'] . 'app')) : 'app';\n            $this->constants['DONT_USE_SRC_ROOT'] = $script_root . $this->constants['DONT_USE_CONFIG_APP'] . DIRECTORY_SEPARATOR;\n\n            $vendor_dir = 'vendor' . DIRECTORY_SEPARATOR . 'ephect-io' . DIRECTORY_SEPARATOR;\n            $portable_dir = 'Epehct' . DIRECTORY_SEPARATOR;\n            $bootstrap = 'bootstrap.php';\n\n            $ephect_dir = $vendor_dir . 'framework' . DIRECTORY_SEPARATOR . 'Ephect' . DIRECTORY_SEPARATOR;\n            $ajil_dir = $vendor_dir . 'javascripts' . DIRECTORY_SEPARATOR . 'Ajil' . DIRECTORY_SEPARATOR;\n\n            $this->constants['DONT_USE_APP_NAME'] = $appName;\n\n            if (file_exists($this->constants['DONT_USE_SITE_ROOT'] . $portable_dir . $bootstrap)) {\n                $ephect_dir = $portable_dir;\n            }\n            $ephect_vendor_lib = $ephect_dir . 'Framework' . DIRECTORY_SEPARATOR;\n            $ephect_vendor_apps = $ephect_dir . 'Apps' . DIRECTORY_SEPARATOR;\n\n            $this->constants['DONT_USE_EPHECT_VENDOR_SRC'] = $ephect_dir;\n            $this->constants['DONT_USE_AJIL_VENDOR_SRC'] = $ajil_dir;\n            $this->constants['DONT_USE_EPHECT_VENDOR_LIB'] = $ephect_vendor_lib;\n            $this->constants['DONT_USE_EPHECT_VENDOR_APPS'] = $ephect_vendor_apps;\n\n            $this->constants['DONT_USE_EPHECT_APPS_ROOT'] = $this->constants['DONT_USE_SITE_ROOT'] . $this->constants['DONT_USE_EPHECT_VENDOR_APPS'];\n\n            $this->constants['DONT_USE_REQUEST_URI'] = 'https://localhost/';\n            $this->constants['DONT_USE_REQUEST_METHOD'] = 'GET';\n            $this->constants['DONT_USE_QUERY_STRING'] = parse_url($this->constants['DONT_USE_REQUEST_URI'], PHP_URL_QUERY);\n\n            $this->constants['DONT_USE_AJIL_ROOT'] = $this->constants['DONT_USE_SITE_ROOT'] . $this->constants['DONT_USE_AJIL_VENDOR_SRC'];\n        }\n\n        $this->constants['DONT_USE_CONFIG_DOCROOT'] = file_exists($this->constants['DONT_USE_CONFIG_DIR'] . 'DONT_USE_DOCUMENT_ROOT') ? trim(file_get_contents($this->constants['DONT_USE_CONFIG_DIR'] . 'DONT_USE_DOCUMENT_ROOT')) : 'public';\n        $this->constants['DONT_USE_CONFIG_HOSTNAME'] = file_exists($this->constants['DONT_USE_CONFIG_DIR'] . 'hostname') ? trim(file_get_contents($this->constants['DONT_USE_CONFIG_DIR'] . 'hostname')) : 'localhost';\n        $this->constants['DONT_USE_CONFIG_NAMESPACE'] = file_exists($this->constants['DONT_USE_CONFIG_DIR'] . 'namespace') ? trim(file_get_contents($this->constants['DONT_USE_CONFIG_DIR'] . 'namespace')) : $this->constants['DONT_USE_APP_NAME'];\n        $this->constants['DONT_USE_CONFIG_COMMANDS'] = file_exists($this->constants['DONT_USE_CONFIG_DIR'] . 'commands') ? trim(file_get_contents($this->constants['DONT_USE_CONFIG_DIR'] . 'commands')) : 'Commands';\n        $this->constants['DONT_USE_CONFIG_PAGES'] = file_exists($this->constants['DONT_USE_CONFIG_DIR'] . 'pages') ? trim(file_get_contents($this->constants['DONT_USE_CONFIG_DIR'] . 'pages')) : 'Pages';\n        $this->constants['DONT_USE_CONFIG_LIBRARY'] = file_exists($this->constants['DONT_USE_CONFIG_DIR'] . 'library') ? trim(file_get_contents($this->constants['DONT_USE_CONFIG_DIR'] . 'library')) : 'Library';\n        $this->constants['DONT_USE_CONFIG_COMPONENTS'] = file_exists($this->constants['DONT_USE_CONFIG_DIR'] . 'components') ? trim(file_get_contents($this->constants['DONT_USE_CONFIG_DIR'] . 'components')) : 'Components';\n        $this->constants['DONT_USE_CONFIG_HOOKS'] = file_exists($this->constants['DONT_USE_CONFIG_DIR'] . 'hooks') ? trim(file_get_contents($this->constants['DONT_USE_CONFIG_DIR'] . 'hooks')) : 'Hooks';\n        $this->constants['DONT_USE_CONFIG_AUTOLOAD'] = file_exists($this->constants['DONT_USE_CONFIG_DIR'] . 'autoload') ? trim(file_get_contents($this->constants['DONT_USE_CONFIG_DIR'] . 'autoload') == 'true') : false;\n\n        if (!$this->isWebApp) {\n            $this->constants['DONT_USE_DOCUMENT_ROOT'] = $this->constants['DONT_USE_SITE_ROOT'] . $this->constants['DONT_USE_CONFIG_DOCROOT'] . DIRECTORY_SEPARATOR;\n        }\n        $this->constants['REL_RUNTIME_JS_DIR'] = 'js' . DIRECTORY_SEPARATOR . 'runtime' . DIRECTORY_SEPARATOR;\n        $this->constants['REL_RUNTIME_CSS_DIR'] = 'css' . DIRECTORY_SEPARATOR . 'runtime' . DIRECTORY_SEPARATOR;\n        $this->constants['RUNTIME_JS_DIR'] = $this->constants['DONT_USE_DOCUMENT_ROOT'] . $this->constants['REL_RUNTIME_JS_DIR'];\n        $this->constants['RUNTIME_CSS_DIR'] = $this->constants['DONT_USE_DOCUMENT_ROOT'] . $this->constants['REL_RUNTIME_CSS_DIR'];\n\n\n        $this->constants['EPHECT_VENDOR_WIDGETS'] = $this->constants['DONT_USE_EPHECT_VENDOR_SRC'] . 'Widgets' . DIRECTORY_SEPARATOR;\n        $this->constants['EPHECT_VENDOR_PLUGINS'] = $this->constants['DONT_USE_EPHECT_VENDOR_SRC'] . 'Modules' . DIRECTORY_SEPARATOR;\n        $this->constants['EPHECT_WIDGETS_ROOT'] = $this->constants['DONT_USE_SITE_ROOT'] . $this->constants['EPHECT_VENDOR_WIDGETS'];\n        $this->constants['EPHECT_PLUGINS_ROOT'] = $this->constants['DONT_USE_SITE_ROOT'] . $this->constants['EPHECT_VENDOR_PLUGINS'];\n\n        $this->constants['APP_DIR'] = $this->constants['DONT_USE_CONFIG_APP'] . DIRECTORY_SEPARATOR;\n        $this->constants['APP_ROOT'] = $this->constants['DONT_USE_SRC_ROOT'];\n        $this->constants['APP_SCRIPTS'] = $this->constants['APP_ROOT'] . 'scripts' . DIRECTORY_SEPARATOR;\n        $this->constants['APP_CLIENT'] = $this->constants['APP_ROOT'] . 'client' . DIRECTORY_SEPARATOR;\n        $this->constants['APP_DATA'] = $this->constants['DONT_USE_SITE_ROOT'] . 'data' . DIRECTORY_SEPARATOR;\n        $this->constants['APP_BUSINESS'] = $this->constants['APP_ROOT'] . 'business' . DIRECTORY_SEPARATOR;\n        $this->constants['CONTROLLER_ROOT'] = $this->constants['APP_ROOT'] . 'controllers' . DIRECTORY_SEPARATOR;\n        $this->constants['BUSINESS_ROOT'] = $this->constants['APP_ROOT'] . 'business' . DIRECTORY_SEPARATOR;\n        $this->constants['MODEL_ROOT'] = $this->constants['APP_ROOT'] . 'models' . DIRECTORY_SEPARATOR;\n        $this->constants['REST_ROOT'] = $this->constants['APP_ROOT'] . 'rest' . DIRECTORY_SEPARATOR;\n        $this->constants['VIEW_ROOT'] = $this->constants['APP_ROOT'] . 'views' . DIRECTORY_SEPARATOR;\n\n        $this->constants['REL_RUNTIME_DIR'] = 'runtime' . DIRECTORY_SEPARATOR;\n        $this->constants['RUNTIME_DIR'] = $this->constants['DONT_USE_SITE_ROOT'] . $this->constants['REL_RUNTIME_DIR'];\n        $this->constants['REL_CACHE_DIR'] = 'cache' . DIRECTORY_SEPARATOR;\n        $this->constants['CACHE_DIR'] = $this->constants['DONT_USE_SITE_ROOT'] . $this->constants['REL_CACHE_DIR'];\n        $this->constants['REL_STATIC_DIR'] = 'static' . DIRECTORY_SEPARATOR;\n        $this->constants['STATIC_DIR'] = $this->constants['CACHE_DIR'] . $this->constants['REL_STATIC_DIR'];\n        $this->constants['REL_STORE_DIR'] = 'store' . DIRECTORY_SEPARATOR;\n        $this->constants['STORE_DIR'] = $this->constants['CACHE_DIR'] . $this->constants['REL_STORE_DIR'];\n        $this->constants['REL_COPY_DIR'] = 'copy' . DIRECTORY_SEPARATOR;\n        $this->constants['COPY_DIR'] = $this->constants['CACHE_DIR'] . $this->constants['REL_COPY_DIR'];\n        $this->constants['REL_UNIQUE_DIR'] = 'unique' . DIRECTORY_SEPARATOR;\n        $this->constants['UNIQUE_DIR'] = $this->constants['CACHE_DIR'] . $this->constants['REL_UNIQUE_DIR'];\n        $this->constants['LOG_PATH'] = $this->constants['DONT_USE_SITE_ROOT'] . 'logs' . DIRECTORY_SEPARATOR;\n        $this->constants['INFO_LOG'] = $this->constants['LOG_PATH'] . 'info.log';\n        $this->constants['DEBUG_LOG'] = $this->constants['LOG_PATH'] . 'debug.log';\n        $this->constants['ERROR_LOG'] = $this->constants['LOG_PATH'] . 'error.log';\n        $this->constants['SQL_LOG'] = $this->constants['LOG_PATH'] . 'sql.log';\n        $this->constants['ROUTES_JSON'] = $this->constants['RUNTIME_DIR'] . 'routes.json';\n\n        $this->constants['FRAMEWORK_ROOT'] = $this->constants['DONT_USE_EPHECT_ROOT'] . 'Framework' . DIRECTORY_SEPARATOR;\n        $this->constants['HOOKS_ROOT'] = $this->constants['DONT_USE_EPHECT_ROOT'] . 'Hooks' . DIRECTORY_SEPARATOR;\n        $this->constants['PLUGINS_ROOT'] = $this->constants['DONT_USE_EPHECT_ROOT'] . 'Plugins' . DIRECTORY_SEPARATOR;\n        $this->constants['COMMANDS_ROOT'] = $this->constants['DONT_USE_EPHECT_ROOT'] . 'Commands' . DIRECTORY_SEPARATOR;\n        $this->constants['CUSTOM_COMMANDS_ROOT'] = $this->constants['DONT_USE_SRC_ROOT'] . $this->constants['DONT_USE_CONFIG_COMMANDS'] . DIRECTORY_SEPARATOR;\n        $this->constants['CUSTOM_PAGES_ROOT'] = $this->constants['DONT_USE_SRC_ROOT'] . $this->constants['DONT_USE_CONFIG_PAGES'] . DIRECTORY_SEPARATOR;\n        $this->constants['CUSTOM_COMPONENTS_ROOT'] = $this->constants['DONT_USE_SRC_ROOT'] . $this->constants['DONT_USE_CONFIG_COMPONENTS'] . DIRECTORY_SEPARATOR;\n        $this->constants['CUSTOM_HOOKS_ROOT'] = $this->constants['DONT_USE_SRC_ROOT'] . $this->constants['DONT_USE_CONFIG_HOOKS'] . DIRECTORY_SEPARATOR;\n        $this->constants['CONFIG_AUTOLOAD'] = $this->constants['DONT_USE_CONFIG_AUTOLOAD'];\n\n\n        $this->constants['CLASS_EXTENSION'] = '.class.php';\n        $this->constants['HTML_EXTENSION'] = '.html';\n        $this->constants['PREHTML_EXTENSION'] = '.phtml';\n        $this->constants['CSS_EXTENSION'] = '.css';\n        $this->constants['JS_EXTENSION'] = '.js';\n        $this->constants['TS_EXTENSION'] = '.ts';\n        $this->constants['JSON_EXTENSION'] = '.json';\n        $this->constants['CLASS_JS_EXTENSION'] = '.class.js';\n        $this->constants['CLASS_TS_EXTENSION'] = '.class.ts';\n        $this->constants['MJS_EXTENSION'] = '.mjs';\n        $this->constants['TPL_EXTENSION'] = '.tpl';\n        $this->constants['TXT_EXTENSION'] = '.txt';\n    }\n\n    public function list(): array\n    {\n        return $this->constants;\n    }\n\n    public function log(): void\n    {\n        foreach ($this->constants as $key => $value) {\n            Console::Log($key . ' => ' . $value);\n        }\n    }\n\n    public function make()\n    {\n        $filename = $this->constants['DONT_USE_EPHECT_ROOT'] . ($this->isWebApp ? 'web' : 'cli') . '_constants.php';\n\n        $lines = \"<?php\" . PHP_EOL;\n        foreach ($this->constants as $key => $value) {\n            if (is_bool($value)) {\n                $lines .= \"const \" . $key . \" = \" . ($value ? 'true' : 'false') . \";\" . PHP_EOL;\n            } elseif (is_int($value) || is_float($value)) {\n                $lines .= \"const \" . $key . \" = \" . $value . \";\" . PHP_EOL;\n            } elseif (is_array($value)) {\n                $lines .= \"const \" . $key . \" = \" . Text::arrayToString($value, true) . \";\" . PHP_EOL;\n            } else {\n                $lines .= \"const \" . $key . \" = '\" . str_replace('\\\\', '\\\\\\\\', $value) . \"';\" . PHP_EOL;\n            }\n        }\n        $lines .= PHP_EOL;\n\n        File::safeWrite($filename, $lines);\n\n        include $filename;\n    }\n\n};"}
{"instruction": "Write an Ephect PHP component", "input": "Based on Ephect source: Enumerator.php", "output": "<?php\n\nnamespace Ephect\\Framework\\Core;\n\nclass Enumerator implements EnumeratorInterface\n{\n    protected static Enumerator|null $instance = null;\n    protected int $value = 0;\n\n    protected function __construct(int $value)\n    {\n        $this->value = $value;\n    }\n\n    public static function enum(?int $value = null): ?int\n    {\n        if ($value !== null) {\n            static::$instance = new Enumerator($value);\n            return null;\n        }\n        return static::$instance->getValue();\n    }\n\n    public function getValue(): int\n    {\n        return $this->value;\n    }\n}"}
{"instruction": "Write an Ephect PHP component", "input": "Based on Ephect source: EnumeratorInterface.php", "output": "<?php\n\nnamespace Ephect\\Framework\\Core;\n\ninterface EnumeratorInterface\n{\n    public static function enum(?int $value = null): ?int;\n\n    public function getValue();\n}"}
{"instruction": "Write an Ephect PHP component", "input": "Based on Ephect source: IniLoaderTrait.php", "output": "<?php\n\nnamespace Ephect\\Framework\\Core;\n\nuse Ephect\\Framework\\Registry\\StateRegistry;\n\nuse function pathinfo;\n\ntrait IniLoaderTrait\n{\n    public function loadINI(string $path = ''): bool\n    {\n        if (!file_exists($path . 'app.ini')) {\n            return false;\n        }\n\n        $ini = parse_ini_file($path . 'app.ini', true, INI_SCANNER_TYPED);\n        if (isset($ini['application']['name'])) {\n            StateRegistry::writeItem('application', 'name', $ini['application']['name']);\n        }\n        if (isset($ini['application']['title'])) {\n            StateRegistry::writeItem('application', 'title', $ini['application']['title']);\n        }\n\n        foreach ($ini as $key => $values) {\n            StateRegistry::writeItem('ini', $key, $values);\n        }\n        unset($ini);\n\n        $dataPath = realpath(dirname($path) . DIRECTORY_SEPARATOR . 'data');\n        if (file_exists($dataPath)) {\n            $dataDir = dir($dataPath);\n\n            while (($entry = $dataDir->read()) !== false) {\n                $info = (object)pathinfo($entry);\n\n                if ($info->extension == 'json') {\n                    $conf = file_get_contents($dataPath . DIRECTORY_SEPARATOR . $entry);\n                    $conf = json_decode($conf, true);\n                    StateRegistry::writeItem('connections', $info->filename, $conf);\n                }\n            }\n            $dataDir->close();\n        }\n\n        return true;\n    }\n}"}
{"instruction": "Write an Ephect PHP component", "input": "Based on Ephect source: Crypto.php", "output": "<?php\n\nnamespace Ephect\\Framework\\Crypto;\n\nclass Crypto\n{\n    public static function createToken(string $key = ''): string\n    {\n        if ($key != '') {\n            $token = uniqid($key, true);\n        } else {\n            $token = uniqid(rand());\n        }\n        return base64_encode($token);\n    }\n\n    public static function createOID(): string\n    {\n        return str_replace('-', '', self::createUID());\n    }\n\n    public static function createUID(): string\n    {\n        return sprintf(\n            '%04X%04X-%04X-%04X-%04X-%04X%04X%04X',\n            mt_rand(0, 65535),\n            mt_rand(0, 65535),\n            mt_rand(0, 65535),\n            mt_rand(16384, 20479),\n            mt_rand(32768, 49151),\n            mt_rand(0, 65535),\n            mt_rand(0, 65535),\n            mt_rand(0, 65535)\n        );\n    }\n}"}
{"instruction": "Write an Ephect PHP component", "input": "Based on Ephect source: Entity.php", "output": "<?php\n\nnamespace Ephect\\Framework\\Entity;\n\nuse Ephect\\Framework\\ElementInterface;\nuse Ephect\\Framework\\ElementTrait;\nuse Ephect\\Framework\\Structure\\StructureInterface;\nuse Ephect\\Framework\\Utils\\File;\nuse Ephect\\Framework\\Utils\\Text;\nuse ErrorException;\nuse JsonException;\n\nclass Entity implements ElementInterface\n{\n    use ElementTrait;\n\n    protected string $filename = '';\n    protected array $data = [];\n\n    public function __construct(private ?StructureInterface $structure = null)\n    {\n    }\n\n    public static function create(?StructureInterface $struct = null): ElementInterface\n    {\n        return new self($struct);\n    }\n\n    public function getStructure(): ?StructureInterface\n    {\n        return $this->structure;\n    }\n\n    public function getFilename(): string\n    {\n        return $this->filename;\n    }\n\n    /**\n     * @throws ErrorException\n     * @throws JsonException\n     */\n    public function load(bool $asPhpArray = false): void\n    {\n        $json = [];\n        $info = pathinfo($this->filename);\n\n        if ($asPhpArray) {\n            $filename = $info['dirname'] . DIRECTORY_SEPARATOR . $info['filename'] . \".php\";\n            if (!file_exists($filename)) {\n                throw new ErrorException(\"File '$filename' not found\");\n            }\n            $json = require $filename;\n        } else {\n            $filename = $info['dirname'] . DIRECTORY_SEPARATOR . $info['filename'] . \".json\";\n            $json = File::safeRead($filename);\n            if (!json_validate($json)) {\n                throw new JsonException(\"Entity data is not valid\");\n            }\n            $json = json_decode($json, JSON_OBJECT_AS_ARRAY);\n        }\n\n        $this->data = $json;\n    }\n\n    public function save(bool $asPhpArray = false): void\n    {\n        $array = $this->structure->toArray();\n        $info = pathinfo($this->filename);\n\n        if ($asPhpArray) {\n            $filename = $info['dirname'] . DIRECTORY_SEPARATOR . $info['filename'] . \".php\";\n            $phpArray = Text::jsonToPhpReturnedArray($array);\n            File::safeWrite($filename, $phpArray);\n        } else {\n            $filename = $info['dirname'] . DIRECTORY_SEPARATOR . $info['filename'] . \".json\";\n            $json = $this->structure->encode(JSON_UNESCAPED_SLASHES | JSON_PRETTY_PRINT);\n            File::safeWrite($filename, $json);\n        }\n    }\n}"}
{"instruction": "Write an Ephect domain event", "input": "Based on Ephect source: Event.php", "output": "<?php\n\nnamespace Ephect\\Framework\\Event;\n\nabstract class Event implements StoppableEventInterface\n{\n    private bool $progpagationStopped = false;\n\n    public function isPropagationStopped(): bool\n    {\n        return $this->progpagationStopped;\n    }\n\n    public function stopPropagation(): void\n    {\n        $this->progpagationStopped = true;\n    }\n}"}
{"instruction": "Write an Ephect domain event", "input": "Based on Ephect source: EventDispatcher.php", "output": "<?php\n\nnamespace Ephect\\Framework\\Event;\n\nuse function Ephect\\Hooks\\useState;\n\nclass EventDispatcher implements EventDispatcherInterface\n{\n    private iterable $listeners = [];\n\n    /**\n     * @param StoppableEventInterface $event\n     * @return StoppableEventInterface\n     */\n    public function dispatch(StoppableEventInterface $event): StoppableEventInterface\n    {\n\n        $eventListeners = $this->getListenersForEvent($event);\n        foreach ($eventListeners as $listener) {\n            if ($event instanceof StoppableEventInterface && $event->isPropagationStopped()) { //\n                return $event;\n            }\n\n            $listener($event);\n        }\n\n        return $event;\n    }\n\n    /**\n     * @param StoppableEventInterface $event\n     *   An event for which to return the relevant listeners.\n     * @return iterable<callable>\n     *   An iterable (array, iterator, or generator) of callables.  Each\n     *   callable MUST be type-compatible with $event.\n     */\n    public function getListenersForEvent(StoppableEventInterface $event): iterable\n    {\n        [$events] = useState(get: 'events');\n\n        if ($events === null) {\n            return [];\n        }\n\n        if (count($this->listeners) === 0) {\n            foreach ($events as $eventClass => $listeners) {\n                foreach (array_unique($listeners) as $listener) {\n                    $this->addListener($eventClass, new $listener());\n                }\n            }\n        }\n\n        $eventName = get_class($event);\n        if (array_key_exists($eventName, $this->listeners)) {\n            return $this->listeners[$eventName];\n        }\n\n        return [];\n    }\n\n    /**\n     * @param string $eventName\n     * @param callable $listener\n     * @return $this\n     */\n    public function addListener(string $eventName, callable $listener): EventDispatcher\n    {\n        $this->listeners[$eventName][] = $listener;\n\n        return $this;\n    }\n}"}
{"instruction": "Write an Ephect domain event", "input": "Based on Ephect source: EventDispatcherInterface.php", "output": "<?php\n\nnamespace Ephect\\Framework\\Event;\n\ninterface EventDispatcherInterface\n{\n    public function dispatch(StoppableEventInterface $event): StoppableEventInterface;\n\n}"}
{"instruction": "Write an Ephect domain event", "input": "Based on Ephect source: EventListenerInterface.php", "output": "<?php\n\nnamespace Ephect\\Framework\\Event;\n\ninterface EventListenerInterface\n{\n    public function __invoke(Event $event): void;\n}"}
{"instruction": "Write an Ephect domain event", "input": "Based on Ephect source: StoppableEventInterface.php", "output": "<?php\n\nnamespace Ephect\\Framework\\Event;\n\ninterface StoppableEventInterface\n{\n    public function isPropagationStopped(): bool;\n\n}"}
{"instruction": "Write an Ephect PHP component", "input": "Based on Ephect source: Logger.php", "output": "<?php\n\nnamespace Ephect\\Framework\\Logger;\n\nuse Ephect\\Framework\\Utils\\Text;\nuse ErrorException;\nuse Throwable;\n\nuse function file_exists;\nuse function file_get_contents;\n\nclass Logger\n{\n    private static Logger|null $logger = null;\n\n    private function __construct()\n    {\n    }\n\n    public static function create(): Logger\n    {\n        if (self::$logger === null) {\n            self::$logger = new Logger();\n        }\n        return self::$logger;\n    }\n\n    public function dump(string $message, object|array $object): void\n    {\n        $this->debug($message . '::' . print_r($object, true) . PHP_EOL);\n    }\n\n    public function debug(string|array|object $message, string $filename = '', int $line = -1): void\n    {\n        $this->__log(\\Constants::DEBUG_LOG, $message, $filename, $line);\n    }\n\n    private function __log(string $filepath, string|array|object $message, string $filename = '', int $line = -1): void\n    {\n        $message = (is_array($message) || is_object($message)) ? print_r($message, true) : $message;\n\n        if (!file_exists(dirname($filepath))) {\n            mkdir(dirname($filepath), 0755);\n        }\n\n        $handle = fopen($filepath, 'a');\n\n        if (\\Constants::SRC_ROOT) {\n            $filename = substr($filename, strlen(\\Constants::SRC_ROOT));\n        }\n        $message = date('Y-m-d h:i:s') . (isset($filename) ? \":$filename\" : '') . ($line > -1 ? \":$line\" : '') . \" : $message\" . PHP_EOL;\n        fwrite($handle, $message . PHP_EOL);\n        fclose($handle);\n    }\n\n    public function info(string $string, ...$params): void\n    {\n        $message = Text::format($string, $params);\n        $this->__log(\\Constants::INFO_LOG, $message);\n    }\n\n    public function sql(string|array|object $message, string $filename = '', int $line = -1): void\n    {\n        $this->__log(\\Constants::SQL_LOG, $message, $filename, $line);\n    }\n\n    public function error(Throwable $ex, string $filename = '', int $line = -1): void\n    {\n        $message = '';\n\n        if ($ex instanceof ErrorException) {\n            $message .= 'Error severity: ' . $ex->getSeverity() . PHP_EOL;\n        }\n        $message .= 'Error code: ' . $ex->getCode() . PHP_EOL;\n        $message .= 'In ' . $ex->getFile() . ', line ' . $ex->getLine() . PHP_EOL;\n        $message .= 'With the message: ' . $ex->getMessage() . PHP_EOL;\n        $message .= 'Stack trace: ' . $ex->getTraceAsString() . PHP_EOL;\n\n        $this->__log(\\Constants::ERROR_LOG, $message, $filename, $line);\n    }\n\n    public function getInfoLog(): string\n    {\n        if (!file_exists(\\Constants::INFO_LOG)) {\n            return '';\n        }\n        return file_get_contents(\\Constants::INFO_LOG);\n    }\n\n    public function getDebugLog(): string\n    {\n        if (!file_exists(\\Constants::DEBUG_LOG)) {\n            return '';\n        }\n        return file_get_contents(\\Constants::DEBUG_LOG);\n    }\n\n    public function getErrorLog(): string\n    {\n        if (!file_exists(\\Constants::ERROR_LOG)) {\n            return '';\n        }\n        return file_get_contents(\\Constants::ERROR_LOG);\n    }\n\n    public function getSqlLog(): string\n    {\n        if (!file_exists(\\Constants::SQL_LOG)) {\n            return '';\n        }\n        return file_get_contents(\\Constants::SQL_LOG);\n    }\n\n    public function getPhpErrorLog(): string\n    {\n        if (!file_exists(\\Constants::DOCUMENT_ROOT . 'php_errors.log')) {\n            return '';\n        }\n        return file_get_contents(\\Constants::DOCUMENT_ROOT . 'php_errors.log');\n    }\n\n    public function clearAll(): void\n    {\n        if (file_exists(\\Constants::INFO_LOG)) {\n            unlink(\\Constants::INFO_LOG);\n        }\n\n        if (file_exists(\\Constants::DEBUG_LOG)) {\n            unlink(\\Constants::DEBUG_LOG);\n        }\n\n        if (file_exists(\\Constants::ERROR_LOG)) {\n            unlink(\\Constants::ERROR_LOG);\n        }\n\n        if (file_exists(\\Constants::SQL_LOG)) {\n            unlink(\\Constants::SQL_LOG);\n        }\n\n        if (file_exists(\\Constants::DOCUMENT_ROOT . 'php_errors.log')) {\n            unlink(\\Constants::DOCUMENT_ROOT . 'php_errors.log');\n        }\n    }\n}"}
{"instruction": "Write an Ephect PHP component", "input": "Based on Ephect source: ManifestEntity.php", "output": "<?php\n\nnamespace Ephect\\Framework\\Manifest;\n\nuse Ephect\\Framework\\Entity\\Entity;\n\nabstract class ManifestEntity extends Entity implements ManifestEntityInterface\n{\n}"}
{"instruction": "Write an Ephect PHP component", "input": "Based on Ephect source: ManifestEntityInterface.php", "output": "<?php\n\nnamespace Ephect\\Framework\\Manifest;\n\nuse Ephect\\Framework\\ElementInterface;\n\ninterface ManifestEntityInterface extends ElementInterface\n{\n}"}
{"instruction": "Write an Ephect PHP component", "input": "Based on Ephect source: ManifestReader.php", "output": "<?php\n\nnamespace Ephect\\Framework\\Manifest;\n\nuse Ephect\\Framework\\Utils\\File;\nuse JsonException;\n\nabstract class ManifestReader\n{\n    abstract public function read(?string $manifestDirectory = null): ManifestEntityInterface;\n\n    /**\n     * @throws JsonException\n     */\n    protected function readManifest(\n        string                   $manifestDirectory,\n        ManifestReaderInputEnum  $inputOption = ManifestReaderInputEnum::IS_OBJECT,\n        ManifestReaderOutputEnum $returnOption = ManifestReaderOutputEnum::AS_IS\n    ): array|string|null {\n        $asPhpArray = $inputOption == ManifestReaderInputEnum::IS_ARRAY;\n        $filename = $manifestDirectory . DIRECTORY_SEPARATOR . 'manifest' . ($asPhpArray ? \".php\" : \".json\");\n\n        $result = null;\n        if ($asPhpArray) {\n            $result = require $filename;\n\n            if ($returnOption == ManifestReaderOutputEnum::AS_STRING) {\n                $result = json_encode($result, JSON_PRETTY_PRINT);\n            }\n        } else {\n            $result = File::safeRead($filename);\n            if (!json_validate($result)) {\n                throw new JsonException(\"Manifest '$filename' is not valid\");\n            }\n            if ($returnOption == ManifestReaderOutputEnum::AS_STRING) {\n                return $result;\n            }\n\n            $result = json_decode($result, JSON_OBJECT_AS_ARRAY);\n        }\n\n        return $result;\n    }\n}"}
{"instruction": "Write an Ephect PHP component", "input": "Based on Ephect source: ManifestReaderInputEnum.php", "output": "<?php\n\nnamespace Ephect\\Framework\\Manifest;\n\nenum ManifestReaderInputEnum\n{\n    case IS_OBJECT;\n    case IS_ARRAY;\n}"}
{"instruction": "Write an Ephect PHP component", "input": "Based on Ephect source: ManifestReaderOutputEnum.php", "output": "<?php\n\nnamespace Ephect\\Framework\\Manifest;\n\nenum ManifestReaderOutputEnum\n{\n    case AS_IS;\n    case AS_STRING;\n}"}
{"instruction": "Write an Ephect PHP component", "input": "Based on Ephect source: ManifestStructure.php", "output": "<?php\n\nnamespace Ephect\\Framework\\Manifest;\n\nuse Ephect\\Framework\\Structure\\Structure;\n\nclass ManifestStructure extends Structure\n{\n}"}
{"instruction": "Write an Ephect PHP component", "input": "Based on Ephect source: ManifestWriter.php", "output": "<?php\n\nnamespace Ephect\\Framework\\Manifest;\n\nabstract class ManifestWriter\n{\n    public function __construct(private readonly ManifestStructure $struct)\n    {\n    }\n\n    abstract public function write(): void;\n}"}
{"instruction": "Write an Ephect PHP component", "input": "Based on Ephect source: ApplicationStateMiddlewareInterface.php", "output": "<?php\n\nnamespace Ephect\\Framework\\Middlewares;\n\ninterface ApplicationStateMiddlewareInterface\n{\n    public function __invoke(object $arguments);\n}"}
{"instruction": "Write an Ephect PHP component", "input": "Based on Ephect source: AttributeMiddlewareInterface.php", "output": "<?php\n\nnamespace Ephect\\Framework\\Middlewares;\n\ninterface AttributeMiddlewareInterface\n{\n    public function getMiddlewares(): array;\n\n}"}
{"instruction": "Write an Ephect PHP component", "input": "Based on Ephect source: PhpInfo.php", "output": "<?php\n\nnamespace Ephect\\Framework\\Misc;\n\nuse Ephect\\Framework\\Registry\\StateRegistry;\nuse stdClass;\n\nfinal class PhpInfo\n{\n    public static function getGeneralSection(bool $asArray = false)\n    {\n        $section = self::getSection(INFO_GENERAL, $asArray);\n        return ($asArray) ? $section['section']['values'] : $section->section->values;\n    }\n\n    public static function getSection(int $section, bool $asArray = false)\n    {\n\n        if (StateRegistry::exists('ini', $section)) {\n            return StateRegistry::readItem('ini', $section);\n        }\n\n        $root = [];\n        $cat = 'general';\n\n        if (!$asArray) {\n            $root = new stdClass();\n            $root->section = new stdClass();\n            $root->section->name = $cat;\n            $root->section->values = new stdClass();\n        }\n\n        ob_start();\n        phpinfo($section);\n        $lines = explode(\"\\n\", strip_tags(ob_get_clean(), \"<tr><td><h2>\"));\n\n        foreach ($lines as $line) {\n            if (false !== preg_match(\"~<h2>(.*)</h2>~\", $line, $title) && ((isset($title[1]) && ($cat = $title[1])))) {\n                // new cat?\n                $cat = self::__formatKey($cat);\n                if (!$asArray) {\n                    $root->section = new stdClass();\n                    $root->section->name = $cat;\n                    $root->section->values = new stdClass();\n                }\n\n                if ($asArray) {\n                    $root['section'] = [];\n                    $root['section']['name'] = $cat;\n                    $root['section']['values'] = [];\n                }\n            }\n\n            if (preg_match(\"~<tr><td[^>]+>([^<]*)</td><td[^>]+>([^<]*)</td></tr>~\", $line, $val)) {\n                $key = self::__formatKey($val[1]);\n                $value = self::__formatValue($val[2]);\n\n                if ($cat !== 'php_variables') {\n                    if (!$asArray) {\n                        $root->section->values->$key = $value;\n                    }\n                    if ($asArray) {\n                        $root['section']['values'][$key] = $value;\n                    }\n                }\n\n                if ($cat == 'php_variables') {\n                    if (preg_match('~\\$_(server|cookie)\\[\\'([a-z_]*)\\'\\]~', $key, $val)) {\n                        $subcat = $val[1];\n                        $subkey = $val[2];\n\n                        if (!$asArray) {\n                            if (!property_exists($root->section->values, $subcat)) {\n                                $root->section->values->$subcat = new stdClass();\n                            }\n                            $root->section->values->$subcat->$subkey = $value;\n                        }\n\n                        if ($asArray) {\n                            $root['section']['values'][$subcat][$subkey] = $value;\n                        }\n                    }\n                }\n            } elseif (\n                preg_match(\n                    \"~<tr><td[^>]+>([^<]*)</td><td[^>]+>([^<]*)</td><td[^>]+>([^<]*)</td></tr>~\",\n                    $line,\n                    $val\n                )\n            ) {\n                $key = self::__formatKey($val[1]);\n                $local = self::__formatValue($val[2]);\n                $master = self::__formatValue($val[3]);\n\n                if (!$asArray) {\n                    $root->section->values->$key = new stdClass();\n                    $root->section->values->$key->local = $local;\n                    $root->section->values->$key->master = $master;\n                }\n\n                if ($asArray) {\n                    $root['section']['values'][$key] = ['local' => $local, 'master' => $master];\n                }\n            }\n        }\n        StateRegistry::writeItem('ini', $section, $root);\n\n        return $root;\n    }\n\n    private static function __formatKey(string $key): string\n    {\n        $key = trim($key);\n        $key = str_replace('(', '', $key);\n        $key = str_replace(')', '', $key);\n        $key = str_replace('/', '_', $key);\n        $key = str_replace(' ', '_', $key);\n        $key = str_replace('__', '_', $key);\n        $key = strtolower($key);\n\n        return $key;\n    }\n\n    private static function __formatValue(string $value): string\n    {\n        // $value = str_replace(\"\\/\", '/', $value);\n\n        return trim($value);\n    }\n\n    public static function getConfigurationSection(bool $asArray = false)\n    {\n        $section = self::getSection(INFO_CONFIGURATION, $asArray);\n        return ($asArray) ? $section['section']['values'] : $section->section->values;\n    }\n\n    public static function getModulesSection(bool $asArray = false)\n    {\n        $section = self::getSection(INFO_MODULES, $asArray);\n        return ($asArray) ? $section['section']['values'] : $section->section->values;\n    }\n\n    public static function getEnvironmentSection(bool $asArray = false)\n    {\n        $section = self::getSection(INFO_ENVIRONMENT, $asArray);\n        return ($asArray) ? $section['section']['values'] : $section->section->values;\n    }\n\n    public static function getPhpVariablesSection(bool $asArray = false)\n    {\n        $section = self::getSection(INFO_VARIABLES, $asArray);\n        return ($asArray) ? $section['section']['values'] : $section->section->values;\n    }\n\n    public static function getPhpCreditstSection(bool $asArray = false)\n    {\n        $section = self::getSection(INFO_CREDITS, $asArray);\n        return ($asArray) ? $section['section']['values'] : $section->section->values;\n    }\n\n    public static function getLicenseSection(bool $asArray = false)\n    {\n        $section = self::getSection(INFO_LICENSE, $asArray);\n        return ($asArray) ? $section['section']['values'] : $section->section->values;\n    }\n\n    public static function displaySection(int $infoSection, bool $asJSON = false): void\n    {\n        $array = self::getSection($infoSection);\n\n        if ($asJSON) {\n            echo '<pre>' . PHP_EOL;\n            echo json_encode($array, JSON_PRETTY_PRINT);\n            echo '</pre>' . PHP_EOL;\n\n            return;\n        }\n\n        foreach ($array as $section => $data) {\n            echo '<p>' . $section . '</p> ' . PHP_EOL;\n            echo '<ul>' . PHP_EOL;\n            foreach ($data as $key => $value) {\n                if (!is_array($value)) {\n                    echo '<li>' . $key . '= ' . $value . '</li> ' . PHP_EOL;\n                }\n                if (is_array($value)) {\n                    echo '<li>' . PHP_EOL;\n                    echo '<p>' . $key . '</p> ' . PHP_EOL;\n                    echo '<ul>' . PHP_EOL;\n                    foreach ($value as $subkey => $subvalue) {\n                        echo '<li>' . $subkey . '= ' . $subvalue . '</li> ' . PHP_EOL;\n                    }\n                    echo '</ul>' . PHP_EOL;\n                    echo '</li>' . PHP_EOL;\n                }\n            }\n            echo '</ul>' . PHP_EOL;\n        }\n    }\n}"}
{"instruction": "Write an Ephect PHP component", "input": "Based on Ephect source: ModuleBootstrapInterface.php", "output": "<?php\n\nnamespace Ephect\\Framework\\Modules;\n\ninterface ModuleBootstrapInterface\n{\n    public function boot(): void;\n}"}
{"instruction": "Write an Ephect PHP component", "input": "Based on Ephect source: ModuleInstaller.php", "output": "<?php\n\nnamespace Ephect\\Framework\\Modules;\n\nuse Ephect\\Framework\\CLI\\Console;\nuse Ephect\\Framework\\ElementUtils;\nuse Ephect\\Framework\\Modules\\Composer\\ComposerConfigReader;\nuse Ephect\\Framework\\Registry\\FrameworkRegistry;\nuse Ephect\\Framework\\Registry\\HooksRegistry;\nuse Ephect\\Framework\\Utils\\File;\nuse Ephect\\Framework\\Utils\\Text;\nuse ErrorException;\nuse JsonException;\n\nuse function Ephect\\Hooks\\useState;\nuse function siteConfigPath;\n\nclass ModuleInstaller\n{\n    public function __construct(private string $workingDirectory)\n    {\n    }\n\n    public static function findAllAndInitialize(): void\n    {\n        [$filename, $paths] = self::readModulePaths();\n        foreach ($paths as $path) {\n            $moduleHooksDir = $path . DIRECTORY_SEPARATOR . HOOKS_DIR;\n            if(file_exists($moduleHooksDir) || is_dir($moduleHooksDir)) {\n                HooksRegistry::register($moduleHooksDir);\n            }\n    \n            $bootstrapFile = $path . DIRECTORY_SEPARATOR . \"Bootstrap.php\";\n            if (!file_exists($bootstrapFile)) {\n                continue;\n            }\n    \n            [$namespace, $className] = ElementUtils::getClassDefinitionFromFile($bootstrapFile);\n            $fqBootstrap = $namespace . '\\\\' . $className;\n\n            $bootstrap = new $fqBootstrap();\n            $bootstrap->boot();\n        }\n\n        useState(['eventProvider' => []]);\n    }\n\n    public static function readModuleBootstrapPaths(): array\n    {\n        $configDir = siteConfigPath();\n        $filename = $configDir . \"modulesBootstrapPaths.php\";\n\n        $paths = [];\n        if (file_exists($filename)) {\n            $paths = require $filename;\n        }\n\n        return [$filename, $paths];\n    }\n\n    /**\n     * @throws JsonException\n     * @throws ErrorException\n     */\n    public function install(): void\n    {\n        FrameworkRegistry::load(true);\n        $srcDir = $this->workingDirectory . DIRECTORY_SEPARATOR . \\Constants::CONFIG_APP . DIRECTORY_SEPARATOR;\n        $configDir = $this->workingDirectory . DIRECTORY_SEPARATOR . \\Constants::REL_CONFIG_DIR;\n        $srcDir = is_dir($srcDir) ? $srcDir : $this->workingDirectory;\n        $configDir = is_dir($configDir) ? $configDir : $this->workingDirectory;\n\n        [$filename, $paths] = self::readModulePaths();\n        if (is_array($paths)) {\n            $paths[] = $this->workingDirectory;\n        }\n        $paths = array_unique($paths);\n        self::saveModulePaths($paths);\n\n        [$filename, $paths] = self::readModuleBootstrapPaths();\n        if (is_array($paths)) {\n            $bootstrapFile = $srcDir . 'bootstrap.php';\n            if (file_exists($bootstrapFile)) {\n                $paths[] = $bootstrapFile;\n            }\n            $constantsFile = $srcDir . 'constants.php';\n            if (file_exists($constantsFile)) {\n                $paths[] = $constantsFile;\n            }\n        }\n        $paths = array_unique($paths);\n        self::saveModuleBootstrapPaths($paths);\n\n        Console::writeLine(\"Module path %s is now declared.\", $this->workingDirectory);\n\n        $customClasses = FrameworkRegistry::collectCustomClasses($srcDir);\n\n        foreach ($customClasses as $class => $filename) {\n            FrameworkRegistry::write($class, $filename);\n        }\n        FrameworkRegistry::save(true);\n\n        $moduleManifestReader = new ModuleManifestReader();\n        $moduleManifest = $moduleManifestReader->read($configDir);\n\n        $composerConfigReader = new ComposerConfigReader();\n        $composerConfig = $composerConfigReader->read();\n\n        $moduleConfigReader = new ModulesConfigReader();\n        $moduleConfig = $moduleConfigReader->read();\n\n        $requires = $composerConfig->getRequire();\n        $package = $moduleManifest->getName();\n        $version = $moduleManifest->getVersion();\n        foreach ($requires as $requireName => $requireVersion) {\n            if ($package == $requireName && $requireVersion !== $version && !empty($requireVersion)) {\n                $moduleConfig->addModule($package, $requireVersion);\n            } else {\n                $moduleConfig->addModule($package, $moduleManifest->getVersion());\n            }\n        }\n\n        $moduleConfig->save();\n\n        Console::writeLine(\"Module classes are now registered.\");\n\n    }\n\n    public static function readModulePaths(): array\n    {\n        $configDir = siteConfigPath();\n        $filename = $configDir . \"modulesPaths.php\";\n\n        $paths = [];\n        if (file_exists($filename)) {\n            $paths = require $filename;\n        }\n\n        return [$filename, $paths];\n    }\n\n    public static function saveModulePaths(array $paths): void\n    {\n        $configDir = siteConfigPath();\n        $filename = $configDir . \"modulesPaths.php\";\n\n        $json = json_encode($paths);\n        $modulesPaths = Text::jsonToPhpReturnedArray($json, true);\n\n        File::safeWrite($filename, $modulesPaths);\n    }\n\n    public static function saveModuleBootstrapPaths(array $paths): void\n    {\n        $configDir = siteConfigPath();\n        $filename = $configDir . \"modulesBootstrapPaths.php\";\n\n        $json = json_encode($paths);\n        $modulesPaths = Text::jsonToPhpReturnedArray($json, true);\n\n        File::safeWrite($filename, $modulesPaths);\n    }\n\n    /**\n     * @throws JsonException\n     * @throws ErrorException\n     */\n    public function remove(): void\n    {\n        FrameworkRegistry::load(true);\n        $workingDirectory = $this->workingDirectory;\n\n        [$filename, $paths] = self::readModulePaths();\n        if (is_array($paths)) {\n            $paths = array_filter($paths, function ($path) use ($workingDirectory) {\n                return $path !== $workingDirectory;\n            });\n        }\n\n        self::saveModulePaths($paths);\n\n        $srcDir = $this->workingDirectory . DIRECTORY_SEPARATOR . \\Constants::CONFIG_APP . DIRECTORY_SEPARATOR;\n        $configDir = $this->workingDirectory . DIRECTORY_SEPARATOR . \\Constants::REL_CONFIG_DIR;\n        $srcDir = is_dir($srcDir) ? $srcDir : $this->workingDirectory;\n        $configDir = is_dir($configDir) ? $configDir : $this->workingDirectory;\n\n        $bootstrapFile = $srcDir . 'bootstrap.php';\n        $constantsFile = $srcDir . 'constants.php';\n\n        [$filename, $paths] = self::readModuleBootstrapPaths();\n        if (is_array($paths)) {\n            $paths = array_filter($paths, function ($path) use ($bootstrapFile, $constantsFile) {\n                return $path !== $bootstrapFile && $path !== $constantsFile;\n            });\n        }\n\n        self::saveModuleBootstrapPaths($paths);\n\n        Console::writeLine(\"Module path %s is now removed.\", $workingDirectory);\n\n        $customClasses = FrameworkRegistry::collectCustomClasses($this->workingDirectory);\n\n        foreach ($customClasses as $class => $filename) {\n            FrameworkRegistry::delete($class);\n        }\n        FrameworkRegistry::save(true);\n\n        $moduleManifestReader = new ModuleManifestReader();\n        $moduleManifest = $moduleManifestReader->read($configDir);\n\n        $moduleConfigReader = new ModulesConfigReader();\n        $moduleConfig = $moduleConfigReader->read();\n        $moduleConfig->removeModule($moduleManifest->getName());\n        $moduleConfig->save();\n\n        Console::writeLine(\"Module classes are now unregistered.\");\n\n    }\n\n}"}
{"instruction": "Write an Ephect PHP component", "input": "Based on Ephect source: ModuleManifestEntity.php", "output": "<?php\n\nnamespace Ephect\\Framework\\Modules;\n\nuse Ephect\\Framework\\Manifest\\ManifestEntity;\nuse Ephect\\Framework\\Structure\\StructureTrait;\n\nclass ModuleManifestEntity extends ManifestEntity implements ModuleManifestEntityInterface\n{\n    use StructureTrait;\n\n    private string $tag = '';\n    private string $name = '';\n    private ?string $entrypoint = null;\n    private string $templates = '';\n    private string $description = '';\n    private string $version = '';\n\n    public function __construct(ModuleManifestStructure $structure)\n    {\n        parent::__construct($structure);\n        $this->bindStructure($structure);\n    }\n\n    public function getTag(): string\n    {\n        return $this->tag;\n    }\n\n    public function getName(): string\n    {\n        return $this->name;\n    }\n\n    public function getEntrypoint(): ?string\n    {\n        return $this->entrypoint;\n    }\n\n    public function getTemplates(): string\n    {\n        return $this->templates;\n    }\n\n    public function getDescription(): string\n    {\n        return $this->description;\n    }\n\n    public function getVersion(): string\n    {\n        return $this->version;\n    }\n\n}"}
{"instruction": "Write an Ephect PHP component", "input": "Based on Ephect source: ModuleManifestEntityInterface.php", "output": "<?php\n\nnamespace Ephect\\Framework\\Modules;\n\nuse Ephect\\Framework\\Manifest\\ManifestEntityInterface;\n\ninterface ModuleManifestEntityInterface extends ManifestEntityInterface\n{\n    public function getTag(): string;\n\n    public function getName(): string;\n\n    public function getEntrypoint(): ?string;\n\n    public function getTemplates(): string;\n\n    public function getDescription(): string;\n\n    public function getVersion(): string;\n}"}
{"instruction": "Write an Ephect PHP component", "input": "Based on Ephect source: ModuleManifestReader.php", "output": "<?php\n\nnamespace Ephect\\Framework\\Modules;\n\nuse Ephect\\Framework\\Manifest\\ManifestReader;\nuse Ephect\\Framework\\Manifest\\ManifestReaderInputEnum;\nuse ErrorException;\nuse JsonException;\n\nclass ModuleManifestReader extends ManifestReader\n{\n    /**\n     * @throws JsonException\n     * @throws ErrorException\n     */\n    public function read(?string $manifestDirectory = null): ModuleManifestEntity\n    {\n        $jsonArray = $this->readManifest($manifestDirectory, ManifestReaderInputEnum::IS_ARRAY);\n\n        $struct = new ModuleManifestStructure($jsonArray);\n        return new ModuleManifestEntity($struct);\n    }\n}"}
{"instruction": "Write an Ephect PHP component", "input": "Based on Ephect source: ModuleManifestStructure.php", "output": "<?php\n\nnamespace Ephect\\Framework\\Modules;\n\nuse Ephect\\Framework\\Manifest\\ManifestStructure;\n\nclass ModuleManifestStructure extends ManifestStructure\n{\n    public string $tag = '';\n    public string $name = '';\n    public ?string $entrypoint = '';\n    public string $templates = 'templates';\n    public string $description = '';\n    public string $version = '';\n}"}
{"instruction": "Write an Ephect PHP component", "input": "Based on Ephect source: ModulesConfigEntity.php", "output": "<?php\n\nnamespace Ephect\\Framework\\Modules;\n\nuse Ephect\\Framework\\Manifest\\ManifestEntity;\nuse Ephect\\Framework\\Structure\\StructureTrait;\nuse Override;\n\nuse function siteRoot;\n\nclass ModulesConfigEntity extends ManifestEntity\n{\n    use StructureTrait;\n\n    private array $modules = [];\n    private array $modulesDev = [];\n\n    public function __construct(private ?ModulesConfigStructure $structure = null)\n    {\n        $this->filename = siteRoot() . \"modules.json\";\n\n        parent::__construct($structure);\n\n        if ($structure instanceof ModulesConfigStructure) {\n            $this->bindStructure($this->structure);\n        }\n    }\n\n    public function getModules(): array\n    {\n        return $this->modules;\n    }\n\n    public function getModulesDev(): array\n    {\n        return $this->modulesDev;\n    }\n\n    public function addModule(string $name, $version): void\n    {\n        $this->modules[$name] = $version;\n    }\n\n    public function removeModule(string $name): void\n    {\n        unset($this->modules[$name]);\n    }\n\n    #[Override]\n    public function load(bool $asPhpArray = false): void\n    {\n        parent::load($asPhpArray);\n        $this->structure = new ModulesConfigStructure($this->data);\n        $this->bindStructure($this->structure);\n    }\n\n    #[Override]\n    public function save(bool $asPhpArray = false): void\n    {\n        $this->structure = new ModulesConfigStructure([\"modules\" => $this->modules]);\n        parent::save($asPhpArray);\n    }\n\n}"}
{"instruction": "Write an Ephect PHP component", "input": "Based on Ephect source: ModulesConfigReader.php", "output": "<?php\n\nnamespace Ephect\\Framework\\Modules;\n\nuse Ephect\\Framework\\Manifest\\ManifestReader;\nuse Ephect\\Framework\\Utils\\File;\nuse ErrorException;\nuse JsonException;\n\nuse function siteRoot;\n\nclass ModulesConfigReader extends ManifestReader\n{\n    /**\n     * @throws JsonException\n     * @throws ErrorException\n     */\n    public function read(?string $manifestDirectory = null): ModulesConfigEntity\n    {\n        $json = File::safeRead(siteRoot() . \"modules.json\");\n        $struct = new ModulesConfigStructure();\n\n        if ($json !== null) {\n            $struct->decode($json);\n        }\n\n        return new ModulesConfigEntity($struct);\n    }\n}"}
{"instruction": "Write an Ephect PHP component", "input": "Based on Ephect source: ModulesConfigStructure.php", "output": "<?php\n\nnamespace Ephect\\Framework\\Modules;\n\nuse Ephect\\Framework\\Structure\\JsonProperty;\nuse Ephect\\Framework\\Structure\\Structure;\n\nclass ModulesConfigStructure extends Structure\n{\n    public array $modules = [];\n\n    #[JsonProperty(name: \"modules-dev\")]\n    public array $modulesDev = [];\n}"}
{"instruction": "Write an Ephect PHP component", "input": "Based on Ephect source: Utils.php", "output": "<?php\n\nnamespace Ephect\\Framework\\Modules;\n\nclass Utils\n{\n    public function __construct(private string $currentDirectory)\n    {\n    }\n\n    public function getModuleDir()\n    {\n        $moduleConfigDir = dirname($this->currentDirectory, 2) . DIRECTORY_SEPARATOR . \\Constants::REL_CONFIG_DIR;\n\n        return (is_dir($moduleConfigDir) ?\n            dirname($this->currentDirectory, 2) : dirname($this->currentDirectory)) . DIRECTORY_SEPARATOR;\n    }\n\n    public function getModuleSrcDir()\n    {\n        return dirname($this->currentDirectory) . DIRECTORY_SEPARATOR;\n    }\n\n    public function getModuleConfDir()\n    {\n        $moduleConfigDir = dirname($this->currentDirectory, 2) . DIRECTORY_SEPARATOR . \\Constants::REL_CONFIG_DIR;\n        return is_dir($moduleConfigDir) ? $moduleConfigDir : dirname($this->currentDirectory) . DIRECTORY_SEPARATOR;\n    }\n\n    public function getModuleManifest(): ModuleManifestEntity\n    {\n        $manifestReader = new ModuleManifestReader();\n        return $manifestReader->read($this->getModuleConfDir());\n    }\n}"}
{"instruction": "Write an Ephect PHP component", "input": "Based on Ephect source: PluginInstaller.php", "output": "<?php\n\nnamespace Ephect\\Framework\\Plugins;\n\nuse Ephect\\Framework\\CLI\\Console;\nuse Ephect\\Framework\\Modules\\Composer\\ComposerConfigReader;\nuse Ephect\\Framework\\Modules\\ModuleManifestReader;\nuse Ephect\\Framework\\Modules\\ModulesConfigReader;\nuse Ephect\\Framework\\Registry\\FrameworkRegistry;\nuse Ephect\\Framework\\Utils\\File;\nuse Ephect\\Framework\\Utils\\Text;\nuse ErrorException;\nuse JsonException;\n\nclass PluginInstaller\n{\n    public function __construct(private string $workingDirectory)\n    {\n\n    }\n\n    public static function loadBootstraps(): void\n    {\n        [$filename, $paths] = self::readPluginBootstrapPaths();\n        foreach ($paths as $path) {\n            require $path;\n        }\n    }\n\n    public static function readPluginBootstrapPaths(): array\n    {\n        $configDir = siteConfigPath();\n        $filename = $configDir . \"pluginsBootstrapPaths.php\";\n\n        $paths = [];\n        if (file_exists($filename)) {\n            $paths = require $filename;\n        }\n\n        return [$filename, $paths];\n    }\n\n    /**\n     * @throws JsonException\n     * @throws ErrorException\n     */\n    public function install(): void\n    {\n        FrameworkRegistry::load(true);\n        $srcDir = $this->workingDirectory . DIRECTORY_SEPARATOR . \\Constants::CONFIG_APP . DIRECTORY_SEPARATOR;\n        $configDir = $this->workingDirectory . DIRECTORY_SEPARATOR . \\Constants::REL_CONFIG_DIR;\n\n        [$filename, $paths] = self::readPluginPaths();\n        if (is_array($paths)) {\n            $paths[] = $this->workingDirectory;\n        }\n        $paths = array_unique($paths);\n        self::savePluginPaths($paths);\n\n        [$filename, $paths] = self::readPluginBootstrapPaths();\n        if (is_array($paths)) {\n            $bootstrapFile = $srcDir . 'bootstrap.php';\n            if (file_exists($bootstrapFile)) {\n                $paths[] = $bootstrapFile;\n            }\n            $constantsFile = $srcDir . 'constants.php';\n            if (file_exists($constantsFile)) {\n                $paths[] = $constantsFile;\n            }\n        }\n        $paths = array_unique($paths);\n        self::savePluginBootstrapPaths($paths);\n\n        Console::writeLine(\"Plugin path %s is now declared.\", $this->workingDirectory);\n\n        $customClasses = FrameworkRegistry::collectCustomClasses($srcDir);\n\n        foreach ($customClasses as $class => $filename) {\n            FrameworkRegistry::write($class, $filename);\n        }\n        FrameworkRegistry::save(true);\n\n        $moduleManifestReader = new ModuleManifestReader();\n        $moduleManifest = $moduleManifestReader->read($configDir);\n\n        $composerConfigReader = new ComposerConfigReader();\n        $composerConfig = $composerConfigReader->read();\n\n        $moduleConfigReader = new ModulesConfigReader();\n        $moduleConfig = $moduleConfigReader->read();\n\n        $requires = $composerConfig->getRequire();\n        $package = $moduleManifest->getName();\n        $version = $moduleManifest->getVersion();\n        foreach ($requires as $requireName => $requireVersion) {\n            if ($package == $requireName && $requireVersion !== $version && !empty($requireVersion)) {\n                $moduleConfig->addModule($package, $requireVersion);\n            } else {\n                $moduleConfig->addModule($package, $moduleManifest->getVersion());\n            }\n        }\n\n        $moduleConfig->save();\n\n        Console::writeLine(\"Plugin classes are now registered.\");\n    }\n\n    public static function readPluginPaths(): array\n    {\n        $configDir = siteConfigPath();\n        $filename = $configDir . \"pluginsPaths.php\";\n\n        $paths = [];\n        if (file_exists($filename)) {\n            $paths = require $filename;\n        }\n\n        return [$filename, $paths];\n    }\n\n    public static function savePluginPaths(array $paths): void\n    {\n        $configDir = siteConfigPath();\n        $filename = $configDir . \"pluginsPaths.php\";\n\n        $json = json_encode($paths);\n        $pluginsPaths = Text::jsonToPhpReturnedArray($json, true);\n\n        File::safeWrite($filename, $pluginsPaths);\n    }\n\n    public static function savePluginBootstrapPaths(array $paths): void\n    {\n        $configDir = siteConfigPath();\n        $filename = $configDir . \"pluginsBootstrapPaths.php\";\n\n        $json = json_encode($paths);\n        $pluginsPaths = Text::jsonToPhpReturnedArray($json, true);\n\n        File::safeWrite($filename, $pluginsPaths);\n    }\n\n    /**\n     * @throws JsonException\n     * @throws ErrorException\n     */\n    public function remove(): void\n    {\n        FrameworkRegistry::load(true);\n        $workingDirectory = $this->workingDirectory;\n\n        [$filename, $paths] = self::readPluginPaths();\n        if (is_array($paths)) {\n            $paths = array_filter($paths, function ($path) use ($workingDirectory) {\n                return $path !== $workingDirectory;\n            });\n        }\n\n        self::savePluginPaths($paths);\n\n        $srcDir = $this->workingDirectory . DIRECTORY_SEPARATOR . \\Constants::CONFIG_APP . DIRECTORY_SEPARATOR;\n        $configDir = $this->workingDirectory . DIRECTORY_SEPARATOR . \\Constants::REL_CONFIG_DIR;\n\n        $bootstrapFile = $srcDir . 'bootstrap.php';\n        $constantsFile = $srcDir . 'constants.php';\n\n        [$filename, $paths] = self::readPluginBootstrapPaths();\n        if (is_array($paths)) {\n            $paths = array_filter($paths, function ($path) use ($bootstrapFile, $constantsFile) {\n                return $path !== $bootstrapFile && $path !== $constantsFile;\n            });\n        }\n\n        self::savePluginBootstrapPaths($paths);\n\n        Console::writeLine(\"Plugin path %s is now removed.\", $workingDirectory);\n\n        $customClasses = FrameworkRegistry::collectCustomClasses($this->workingDirectory);\n\n        foreach ($customClasses as $class => $filename) {\n            FrameworkRegistry::delete($class);\n        }\n        FrameworkRegistry::save(true);\n\n        $moduleManifestReader = new ModuleManifestReader();\n        $moduleManifest = $moduleManifestReader->read($configDir);\n\n        $moduleConfigReader = new ModulesConfigReader();\n        $moduleConfig = $moduleConfigReader->read();\n        $moduleConfig->removeModule($moduleManifest->getName());\n        $moduleConfig->save();\n\n        Console::writeLine(\"Plugin classes are now unregistered.\");\n    }\n}"}
{"instruction": "Write an Ephect PHP component", "input": "Based on Ephect source: AbstractRegistry.php", "output": "<?php\n\nnamespace Ephect\\Framework\\Registry;\n\nuse Ephect\\Framework\\ElementTrait;\nuse Ephect\\Framework\\Utils\\File;\nuse Ephect\\Framework\\Utils\\Text;\n\nabstract class AbstractRegistry implements RegistryInterface\n{\n    use ElementTrait;\n\n    protected array $entries = [];\n    protected bool $isLoaded = false;\n    protected string $baseDirectory = \\Constants::BUILD_DIR;\n    protected string $cacheFilename = '';\n    protected string $flatFilename = '';\n\n    protected string $buildDirectory = \\Constants::BUILD_DIR;\n\n    public function __write(string $key, $value): void\n    {\n        $this->entries[$key] = $value;\n    }\n\n    public function __read($key, $value = null): mixed\n    {\n        if (!isset($this->entries[$key])) {\n            return null;\n        }\n\n        if ($value === null) {\n            return $this->entries[$key];\n        }\n\n        if (!isset($this->entries[$key][$value])) {\n            return null;\n        }\n\n        return $this->entries[$key][$value];\n    }\n\n    public function __delete(string $key): void\n    {\n        unset($this->entries[$key]);\n    }\n\n    public function __exists(string $key): bool\n    {\n        return isset($this->entries[$key]);\n    }\n\n    public function __save(bool $asArray = false): bool\n    {\n        $entries = $this->__items();\n\n        $result = json_encode($entries, JSON_PRETTY_PRINT);\n\n        if ($asArray) {\n            $result = Text::jsonToPhpReturnedArray($result);\n            $ephect_root = \\Constants::EPHECT_ROOT;\n            if (DIRECTORY_SEPARATOR === '\\\\') {\n                $ephect_root = str_replace('\\\\', '\\\\\\\\', \\Constants::EPHECT_ROOT);\n            }\n\n            $result = str_replace('\"' . $ephect_root, 'EPHECT_ROOT . \"', $result);\n            $result = str_replace('\"' . \\Constants::SRC_ROOT, 'SRC_ROOT . \"', $result);\n        }\n\n        $registryFilename = $this->__getCacheFileName($asArray);\n        $len = File::safeWrite($registryFilename, $result);\n\n        return $len !== null;\n    }\n\n    public function __items(): array\n    {\n        return $this->entries;\n    }\n\n    public function __getCacheFileName(bool $asArray = false): string\n    {\n        $this->cacheFilename = $this->baseDirectory . $this->__getFlatFilename($asArray);\n\n        return $this->cacheFilename . ($asArray ? '.php' : '.json');\n    }\n\n    public function __getFlatFilename(): string\n    {\n        return $this->flatFilename ?: $this->flatFilename = strtolower(str_replace('\\\\', '_', get_class($this)));\n    }\n\n    public function __load(bool $asArray = false): bool\n    {\n        $this->isLoaded = false;\n\n        $registryFilename = $this->__getCacheFileName($asArray);\n\n        $ok = is_file($registryFilename);\n\n        if ($ok && !$asArray) {\n            $text = file_get_contents($registryFilename);\n            $this->entries = json_decode($text, JSON_OBJECT_AS_ARRAY);\n            $this->isLoaded = true;\n        }\n\n        if ($ok && $asArray) {\n            $this->entries = require $registryFilename;\n            $this->isLoaded = true;\n        }\n\n        return $this->isLoaded;\n    }\n\n    public function __setCacheDirectory(string $directory): void\n    {\n        $directory = substr($directory, -1) !== DIRECTORY_SEPARATOR ? $directory . DIRECTORY_SEPARATOR : $directory;\n        $this->baseDirectory = $directory;\n    }\n\n    protected function __shortClassName(): string\n    {\n        $fqname = get_class($this);\n        $nameParts = explode('\\\\', $fqname);\n        $basename = array_pop($nameParts);\n\n        return $basename;\n    }\n}"}
{"instruction": "Write an Ephect PHP component", "input": "Based on Ephect source: AbstractStateRegistry.php", "output": "<?php\n\nnamespace Ephect\\Framework\\Registry;\n\nuse Ephect\\Framework\\Utils\\File;\nuse Ephect\\Framework\\Utils\\Text;\n\nabstract class AbstractStateRegistry extends AbstractRegistry implements RegistryInterface\n{\n    protected function __saveByMotherUid(string $motherUid, bool $asArray = false): void\n    {\n        $entries = $this->__items();\n\n        $result = json_encode($entries, JSON_PRETTY_PRINT);\n\n        if ($asArray) {\n            $result = Text::jsonToPhpReturnedArray($result);\n        }\n\n        $this->__setCacheDirectory($this->buildDirectory . $motherUid);\n        $registryFilename = $this->__getCacheFileName($asArray);\n        $len = File::safeWrite($registryFilename, $result);\n    }\n\n    protected function __loadByMotherUid(string $motherUid, bool $asArray = false): void\n    {\n        $this->__setCacheDirectory($this->buildDirectory . $motherUid);\n        $this->__load($asArray);\n    }\n\n    protected function __writeItem(string|int $item, ...$params): void\n    {\n        $concat = function (string|int $key, mixed $value) use ($item): mixed {\n            $result = $value;\n            if (isset($this->entries[$item][$key]) && is_array($this->entries[$item][$key]) && is_array($value)) {\n                $result = array_merge_recursive($this->entries[$item][$key], $value);\n            }\n\n            return $result;\n        };\n\n        if (!isset($this->entries[$item])) {\n            $this->entries[$item] = [];\n        }\n\n        if (count($params) === 1) {\n            $param0 = $params[0];\n            if (is_object($param0)) {\n                $param0 = json_encode($param0);\n                $param0 = json_decode($param0, JSON_OBJECT_AS_ARRAY);\n            }\n            if (is_array($param0) && count($param0) > 0) {\n                foreach ($param0 as $key => $value) {\n                    $this->entries[$item][$key] = $concat($key, $value);\n                }\n            }\n        }\n\n        if (count($params) === 2) {\n            $key = $params[0];\n            $value = $params[1];\n            $this->entries[$item][$key] = $concat($key, $value);\n        }\n    }\n\n    protected function __unshift(string|int $item, string|int $key, mixed $value): void\n    {\n        if (!isset($this->entries[$item])) {\n            $this->push($item, $key, $value);\n        }\n\n        if (!isset($this->entries[$item][$key])) {\n            $this->entries[$item][$key] = $value;\n        }\n\n        if (isset($this->entries[$item][$key]) && !is_array($this->entries[$item][$key])) {\n            $tmp = $this->entries[$item][$key];\n            $this->entries[$item][$key] = [];\n            $this->entries[$item][$key][] = $tmp;\n        }\n\n        array_unshift($this->entries[$item][$key], $value);\n    }\n\n    protected function __push(string|int $item, string|int $key, mixed $value): void\n    {\n        if (!isset($this->entries[$item])) {\n            $this->entries[$item] = [];\n        }\n\n        if (!isset($this->entries[$item][$key])) {\n            $this->entries[$item][$key] = $value;\n        }\n\n        if (isset($this->entries[$item][$key]) && !is_array($this->entries[$item][$key])) {\n            $tmp = $this->entries[$item][$key];\n            $this->entries[$item][$key] = [];\n            $this->entries[$item][$key][] = $tmp;\n        }\n\n        $this->entries[$item][$key][] = $value;\n    }\n\n    protected function __keys(string|null $item = null): array\n    {\n        if ($item === null) {\n            return array_keys($this->entries);\n        } elseif (is_array($this->entries)) {\n            return array_keys($this->entries[$item]);\n        } else {\n            return [];\n        }\n    }\n\n    protected function __item(string|int $item, string|null $value = null): ?array\n    {\n        if ($item === '' || $item === null) {\n            return null;\n        }\n\n        if (isset($this->entries[$item])) {\n            if ($value != null) {\n                $this->entries[$item] = $value;\n            } else {\n                return $this->entries[$item];\n            }\n        }\n        if (!isset($this->entries[$item])) {\n            $this->entries[$item] = [];\n            return $this->entries[$item];\n        }\n\n        return null;\n    }\n\n    protected function __ini(string $section, string|null $key = null): string|null\n    {\n        $section = $this->__readItem('ini', $section);\n        $value = null;\n\n        if ($key === null) {\n            return $section;\n        }\n\n        if (is_array($section)) {\n            $value = $section[$key] ?? $value;\n        }\n\n        return $value;\n    }\n\n    protected function __readItem(string|int $item, string|int $key, mixed $defaultValue = null): mixed\n    {\n        $result = null;\n\n        if ($this->entries[$item] !== null) {\n            $result = $this->entries[$item][$key] ?? (($defaultValue !== null) ? $defaultValue : null);\n        }\n\n        return $result;\n    }\n}"}
{"instruction": "Write an Ephect PHP component", "input": "Based on Ephect source: AbstractStaticRegistry.php", "output": "<?php\n\nnamespace Ephect\\Framework\\Registry;\n\nabstract class AbstractStaticRegistry extends AbstractRegistry implements StaticRegistryInterface, RegistryInterface\n{\n    use StaticRegistryTrait;\n}"}
{"instruction": "Write an Ephect command handler", "input": "Based on Ephect source: CommandRegistry.php", "output": "<?php\n\nnamespace Ephect\\Framework\\Registry;\n\nclass CommandRegistry extends AbstractStaticRegistry\n{\n    private static ?CommandRegistry $instance = null;\n\n    public static function reset(): void\n    {\n        self::$instance = new CommandRegistry();\n        unlink(self::$instance->getCacheFilename());\n    }\n\n    public static function getInstance(): CommandRegistry\n    {\n        if (self::$instance === null) {\n            self::$instance = new CommandRegistry();\n        }\n\n        return self::$instance;\n    }\n}"}
{"instruction": "Write an Ephect domain event", "input": "Based on Ephect source: EventRegistry.php", "output": "<?php\n\nnamespace Ephect\\Framework\\Registry;\n\nclass EventRegistry extends AbstractStaticRegistry\n{\n    private static ?EventRegistry $instance = null;\n\n    public static function reset(): void\n    {\n        self::$instance = new EventRegistry();\n        unlink(self::$instance->getCacheFilename());\n    }\n\n    public static function getInstance(): EventRegistry\n    {\n        if (self::$instance === null) {\n            self::$instance = new EventRegistry();\n        }\n\n        return self::$instance;\n    }\n}"}
{"instruction": "Write an Ephect component", "input": "Based on Ephect source: FrameworkRegistry.php", "output": "<?php\n\nnamespace Ephect\\Framework\\Registry;\n\nuse Ephect\\Framework\\ElementUtils;\nuse Ephect\\Framework\\Modules\\ModuleInstaller;\nuse Ephect\\Framework\\Utils\\File;\n\nclass FrameworkRegistry extends AbstractStaticRegistry\n{\n    private static ?FrameworkRegistry $instance = null;\n\n    public static function reset(): void\n    {\n        $runtimeDir = siteRuntimePath();\n        self::$instance = new FrameworkRegistry();\n        self::$instance->__setCacheDirectory($runtimeDir);\n        unlink(self::$instance->getCacheFilename());\n    }\n\n    public static function getInstance(): FrameworkRegistry\n    {\n        if (self::$instance === null) {\n            $runtimeDir = siteRuntimePath();\n            self::$instance = new FrameworkRegistry();\n            self::$instance->__setCacheDirectory($runtimeDir);\n        }\n\n        return self::$instance;\n    }\n\n    public static function register(): void\n    {\n        if (!FrameworkRegistry::load(true)) {\n            $frameworkFiles = File::walkTreeFiltered(\\Constants::FRAMEWORK_ROOT, ['php']);\n\n            foreach ($frameworkFiles as $filename) {\n                if (\n                    $filename === 'bootstrap.php'\n                    || str_contains($filename, 'constants.php')\n                    || str_contains($filename, 'Autoloader.php')\n                ) {\n                    continue;\n                }\n\n                if (str_ends_with($filename, 'Interface.php')) {\n                    [$namespace, $interface] = ElementUtils::getInterfaceDefinitionFromFile(\n                        \\Constants::FRAMEWORK_ROOT . $filename\n                    );\n                    $fqname = $namespace . '\\\\' . $interface;\n                    FrameworkRegistry::write($fqname, \\Constants::FRAMEWORK_ROOT . $filename);\n                    continue;\n                }\n\n                if (str_ends_with($filename, 'Enum.php')) {\n                    [$namespace, $enum] = ElementUtils::getEnumDefinitionFromFile(\n                        \\Constants::FRAMEWORK_ROOT . $filename\n                    );\n                    $fqname = $namespace . '\\\\' . $enum;\n                    FrameworkRegistry::write($fqname, \\Constants::FRAMEWORK_ROOT . $filename);\n                    continue;\n                }\n\n                if (str_ends_with($filename, 'Trait.php')) {\n                    [$namespace, $trait] = ElementUtils::getTraitDefinitionFromFile(\n                        \\Constants::FRAMEWORK_ROOT . $filename\n                    );\n                    $fqname = $namespace . '\\\\' . $trait;\n                    FrameworkRegistry::write($fqname, \\Constants::FRAMEWORK_ROOT . $filename);\n                    continue;\n                }\n\n                [$namespace, $class] = ElementUtils::getClassDefinitionFromFile(\\Constants::FRAMEWORK_ROOT . $filename);\n                $fqname = $namespace . '\\\\' . $class;\n                if ($class === '') {\n                    [$namespace, $function] = ElementUtils::getFunctionDefinitionFromFile(\n                        \\Constants::FRAMEWORK_ROOT . $filename\n                    );\n                    $fqname = $namespace . '\\\\' . $function;\n                }\n                if ($fqname !== '\\\\') {\n                    FrameworkRegistry::write($fqname, \\Constants::FRAMEWORK_ROOT . $filename);\n                }\n            }\n\n            self::registerCustomClasses(\\Constants::COMMANDS_ROOT);\n            self::registerCustomClasses(\\Constants::SRC_ROOT);\n            self::registerModulesClasses();\n\n            FrameworkRegistry::save(true);\n\n        }\n    }\n\n    public static function registerCustomClasses(string $customDir): void\n    {\n        if (!file_exists($customDir)) {\n            return;\n        }\n        $collectedClasses = self::collectCustomClasses($customDir);\n\n        foreach ($collectedClasses as $class => $filename) {\n            FrameworkRegistry::write($class, $filename);\n        }\n    }\n\n    public static function collectCustomClasses(string $customDir): array\n    {\n        if (!file_exists($customDir)) {\n            return [];\n        }\n\n        $result = [];\n\n        $sourceFiles = File::walkTreeFiltered($customDir, ['php']);\n\n        foreach ($sourceFiles as $filename) {\n            if (\n                $filename == 'bootstrap.php'\n                || $filename == 'constants.php'\n            ) {\n                continue;\n            }\n\n            if (str_ends_with($filename, 'Interface.php')) {\n                [$namespace, $interface] = ElementUtils::getInterfaceDefinitionFromFile($customDir . $filename);\n                $fqname = $namespace . '\\\\' . $interface;\n                $result[$fqname] = $customDir . $filename;\n                continue;\n            }\n\n            if (str_ends_with($filename, 'Trait.php')) {\n                [$namespace, $trait] = ElementUtils::getTraitDefinitionFromFile($customDir . $filename);\n                $fqname = $namespace . '\\\\' . $trait;\n                $result[$fqname] = $customDir . $filename;\n                continue;\n            }\n\n            if (str_ends_with($filename, 'Enum.php')) {\n                [$namespace, $enum] = ElementUtils::getEnumDefinitionFromFile($customDir . $filename);\n                $fqname = $namespace . '\\\\' . $enum;\n                $result[$fqname] = $customDir . $filename;\n                continue;\n            }\n\n            [$namespace, $class] = ElementUtils::getClassDefinitionFromFile($customDir . $filename);\n            $fqname = $namespace . '\\\\' . $class;\n            if ($class === '') {\n                [$namespace, $function] = ElementUtils::getFunctionDefinitionFromFile($customDir . $filename);\n                $fqname = $namespace . '\\\\' . $function;\n            }\n            if ($fqname !== '\\\\') {\n                $result[$fqname] = $customDir . $filename;\n            }\n        }\n\n        return $result;\n    }\n\n    public static function registerModulesClasses(): void\n    {\n        [$filename, $paths] = ModuleInstaller::readModulePaths();\n        foreach ($paths as $path) {\n            self::registerCustomClasses($path);\n        }\n    }\n\n    public static function registerBuiltComponents()\n    {\n        self::registerCustomClasses(\\Constants::BUILD_DIR);\n    }\n\n}"}
{"instruction": "Write an Ephect PHP component", "input": "Based on Ephect source: HooksRegistry.php", "output": "<?php\n\nnamespace Ephect\\Framework\\Registry;\n\nuse Ephect\\Framework\\Utils\\File;\nuse Ephect\\Framework\\Utils\\Text;\n\nclass HooksRegistry\n{\n    private static $instance = null;\n    private static string $hooksFile = \\Constants::RUNTIME_DIR . 'HooksRegistry.php';\n\n    private function ___construct()\n    {\n    }\n\n    public static function load(): void\n    {\n        self::create()->__load();\n    }\n\n    public static function register(string $path = \\Constants::HOOKS_ROOT): void\n    {\n        self::create()->__register($path);\n    }\n\n    protected function __load(): void\n    {\n        if (!file_exists(self::$hooksFile)) {\n            return;\n        }\n\n        $hooks = include self::$hooksFile;\n        foreach ($hooks as $hook) {\n            include_once $hook;\n        }\n    }   \n\n    protected function __register(string $path): void\n    {\n        $hooksFile = \\Constants::RUNTIME_DIR . 'HooksRegistry.php';\n\n        if (!\\Constants::IS_PHAR_APP) {\n            if (!file_exists($path)) {\n                return;\n            }\n\n            $hooks = [];\n            $dir_handle = opendir($path);\n\n            while (false !== $filename = readdir($dir_handle)) {\n                if ($filename == '.' || $filename == '..') {\n                    continue;\n                }\n\n                $hooks[] = str_replace(\n                    DIRECTORY_SEPARATOR,\n                    PHP_OS === 'WINNT' ? DIRECTORY_SEPARATOR . DIRECTORY_SEPARATOR  : DIRECTORY_SEPARATOR,\n                    $path . $filename\n                );\n\n            }\n            \n            if(file_exists($hooksFile) !== false) {\n                $existingHooks = include $hooksFile;\n                if(is_array($existingHooks)) {\n                    $hooks = array_unique([...$existingHooks, ...$hooks]);\n                }\n            }\n\n            $hooksRegistry = Text::jsonToPhpReturnedArray(json_encode($hooks));\n\n            File::safeWrite($hooksFile, $hooksRegistry);\n        }\n    }\n\n    public static function create(): HooksRegistry\n    {\n        if (self::$instance === null) {\n            self::$instance = new HooksRegistry();\n        }\n\n        return self::$instance;\n    }\n}"}
{"instruction": "Write an Ephect PHP component", "input": "Based on Ephect source: MemoryRegistry.php", "output": "<?php\n\nnamespace Ephect\\Framework\\Registry;\n\nuse Ephect\\Framework\\Logger\\Logger;\n\nclass MemoryRegistry extends AbstractStateRegistry implements RegistryInterface\n{\n    use StaticRegistryTrait;\n\n    private static ?MemoryRegistry $instance = null;\n\n    public static function reset(): void\n    {\n        self::$instance = new MemoryRegistry();\n    }\n\n    public static function getInstance(): MemoryRegistry\n    {\n        if (self::$instance === null) {\n            self::$instance = new MemoryRegistry();\n        }\n\n        return self::$instance;\n    }\n\n    public static function save(bool $asArray = false): bool\n    {\n        return $asArray;\n    }\n\n    public static function load(bool $asArray = false): bool\n    {\n        return $asArray;\n    }\n\n    public static function dump(string $key): void\n    {\n        Logger::create()->dump('Registry key ' . $key, StateRegistry::item($key));\n    }\n\n    public static function item(string|int $item, string|null $value = null): ?array\n    {\n        return static::getInstance()->__item($item, $value);\n    }\n\n    public static function readItem(string|int $item, string|int $key, mixed $defaultValue = null): mixed\n    {\n        return static::getInstance()->__readItem($item, $key, $defaultValue);\n    }\n\n    public static function writeItem(string|int $item, ...$params): void\n    {\n        static::getInstance()->__writeItem($item, ...$params);\n    }\n\n    public static function unshift(string|int $item, string|int $key, mixed $value): void\n    {\n        static::getInstance()->__unshift($item, $key, $value);\n    }\n\n    public static function push(string|int $item, string|int $key, mixed $value): void\n    {\n        static::getInstance()->__push($item, $key, $value);\n    }\n\n    public static function keys(string|null $item = null): array\n    {\n        return static::getInstance()->__keys($item = null);\n    }\n\n}"}
{"instruction": "Write an Ephect PHP component", "input": "Based on Ephect source: MiddlewareRegistry.php", "output": "<?php\n\nnamespace Ephect\\Framework\\Registry;\n\nclass MiddlewareRegistry extends AbstractStaticRegistry\n{\n    private static ?MiddlewareRegistry $instance = null;\n\n    public static function reset(): void\n    {\n        self::$instance = new MiddlewareRegistry();\n        unlink(self::$instance->getCacheFilename());\n    }\n\n    public static function getInstance(): MiddlewareRegistry\n    {\n        if (self::$instance === null) {\n            self::$instance = new MiddlewareRegistry();\n        }\n\n        return self::$instance;\n    }\n}"}
{"instruction": "Write an Ephect PHP component", "input": "Based on Ephect source: PharRegistry.php", "output": "<?php\n\nnamespace Ephect\\Framework\\Registry;\n\nclass PharRegistry extends AbstractStaticRegistry\n{\n    private static ?PharRegistry $instance = null;\n\n    public static function reset(): void\n    {\n        self::$instance = new PharRegistry();\n        self::$instance->__setCacheDirectory(RUNTIME_DIR);\n        unlink(self::$instance->getCacheFilename());\n    }\n\n    public static function getInstance(): PharRegistry\n    {\n        if (self::$instance === null) {\n            self::$instance = new PharRegistry();\n            self::$instance->__setCacheDirectory(RUNTIME_DIR);\n        }\n\n        return self::$instance;\n    }\n\n    public static function register(): void\n    {\n        FrameworkRegistry::load(true);\n        $items = FrameworkRegistry::items();\n\n        foreach ($items as $key => $value) {\n            $value = str_replace(\\Constants::EPHECT_ROOT, '', $value);\n            $value = str_replace(DIRECTORY_SEPARATOR, '_', $value);\n\n            PharRegistry::write($key, $value);\n        }\n\n        PharRegistry::save();\n    }\n}"}
{"instruction": "Write an Ephect PHP component", "input": "Based on Ephect source: RegistryInterface.php", "output": "<?php\n\nnamespace Ephect\\Framework\\Registry;\n\ninterface RegistryInterface\n{\n    public function __write(string $key, $value): void;\n\n    public function __read($key, $value = null): mixed;\n\n    public function __items(): array;\n\n    public function __save(bool $asArray = false): bool;\n\n    public function __load(bool $asArray = false): bool;\n\n    public function __exists(string $key): bool;\n\n    public function __delete(string $key): void;\n\n    public function __setCacheDirectory(string $directory): void;\n\n    public function __getCacheFilename(bool $asArray = false): string;\n\n    public function __getFlatFilename(): string;\n}"}
{"instruction": "Write an Ephect PHP component", "input": "Based on Ephect source: StateRegistry.php", "output": "<?php\n\nnamespace Ephect\\Framework\\Registry;\n\nuse Ephect\\Framework\\Logger\\Logger;\n\nclass StateRegistry extends AbstractStateRegistry implements RegistryInterface\n{\n    use StaticRegistryTrait;\n\n    private static ?StateRegistry $instance = null;\n\n    public static function reset(): void\n    {\n        self::$instance = new StateRegistry();\n        unlink(self::$instance->getCacheFilename());\n    }\n\n    public static function saveByMotherUid(string $motherUid, bool $asArray = false): void\n    {\n        static::getInstance()->__saveByMotherUid($motherUid, $asArray);\n    }\n\n    public static function getInstance(): StateRegistry\n    {\n        if (self::$instance === null) {\n            self::$instance = new StateRegistry();\n        }\n\n        return self::$instance;\n    }\n\n    public static function loadByMotherUid(string $motherUid, bool $asArray = false): void\n    {\n        static::getInstance()->__loadByMotherUid($motherUid, $asArray);\n    }\n\n    public static function dump(string $key): void\n    {\n        Logger::create()->dump('Registry key ' . $key, StateRegistry::item($key));\n    }\n\n    public static function item(string|int $item, string|null $value = null): ?array\n    {\n        return static::getInstance()->__item($item, $value);\n    }\n\n    public static function readItem(string|int $item, string|int $key, mixed $defaultValue = null): mixed\n    {\n        return static::getInstance()->__readItem($item, $key, $defaultValue);\n    }\n\n    public static function writeItem(string|int $item, ...$params): void\n    {\n        static::getInstance()->__writeItem($item, ...$params);\n    }\n\n    public static function unshift(string|int $item, string|int $key, mixed $value): void\n    {\n        static::getInstance()->__unshift($item, $key, $value);\n    }\n\n    public static function push(string|int $item, string|int $key, mixed $value): void\n    {\n        static::getInstance()->__push($item, $key, $value);\n    }\n\n    public static function keys(string|null $item = null): array\n    {\n        return static::getInstance()->__keys($item = null);\n    }\n\n    public static function ini(string $section, string|null $key = null): string|null\n    {\n        return static::getInstance()->__ini($section, $key);\n    }\n}"}
{"instruction": "Write an Ephect PHP component", "input": "Based on Ephect source: StaticRegistryInterface.php", "output": "<?php\n\nnamespace Ephect\\Framework\\Registry;\n\ninterface StaticRegistryInterface\n{\n    public static function getInstance(): RegistryInterface;\n\n    public static function write(string $key, $item): void;\n\n    public static function read($key, $item = null);\n\n    public static function items(): array;\n\n    public static function save(): bool;\n\n    public static function load(): bool;\n\n    public static function delete(string $key): void;\n\n    public static function exists(string $key): bool;\n\n    public static function setCacheDirectory(string $directory): void;\n\n    public static function getCacheFilename(): string;\n\n    public static function getFlatFilename(): string;\n}"}
{"instruction": "Write an Ephect PHP component", "input": "Based on Ephect source: StaticRegistryTrait.php", "output": "<?php\n\nnamespace Ephect\\Framework\\Registry;\n\ntrait StaticRegistryTrait\n{\n    abstract public static function reset(): void;\n\n    public static function safeWrite(string $key, $item): bool\n    {\n        if (false === $result = static::exists($key)) {\n            static::write($key, $item);\n        }\n\n        return $result;\n    }\n\n    public static function exists(string $key): bool\n    {\n        return static::getInstance()->__exists($key);\n    }\n\n    abstract public static function getInstance(): RegistryInterface;\n\n    public static function write(string $key, $item): void\n    {\n        static::getInstance()->__write($key, $item);\n    }\n\n    public static function read($key, $item = null): mixed\n    {\n        return static::getInstance()->__read($key, $item);\n    }\n\n    public static function items(): array\n    {\n        return static::getInstance()->__items();\n    }\n\n    public static function save(bool $asArray = false): bool\n    {\n        return static::getInstance()->__save($asArray);\n    }\n\n    public static function load(bool $asArray = false): bool\n    {\n        return static::getInstance()->__load($asArray);\n    }\n\n    public static function delete(string $key): void\n    {\n        static::getInstance()->__delete($key);\n    }\n\n    public static function setCacheDirectory(string $directory): void\n    {\n        static::getInstance()->__setCacheDirectory($directory);\n    }\n\n    public static function getCacheFilename(bool $asArray = false): string\n    {\n        return static::getInstance()->__getCacheFilename($asArray);\n    }\n\n    public static function getFlatFilename(): string\n    {\n        return static::getInstance()->__getFlatFilename();\n    }\n\n}"}
{"instruction": "Write an Ephect PHP component", "input": "Based on Ephect source: RepositoryFactoryInterface.php", "output": "<?php\n\nnamespace Ephect\\Framework\\Repositories;\n\ninterface RepositoryFactoryInterface\n{\n    public function create(string $repositoryClass): RepositoryInterface|null;\n\n}"}
{"instruction": "Write an Ephect PHP component", "input": "Based on Ephect source: RepositoryInterface.php", "output": "<?php\n\nnamespace Ephect\\Framework\\Repositories;\n\ninterface RepositoryInterface\n{\n    public function getName(): string;\n}"}
{"instruction": "Write an Ephect PHP component", "input": "Based on Ephect source: ServiceFactoryInterface.php", "output": "<?php\n\nnamespace Ephect\\Framework\\Services;\n\ninterface ServiceFactoryInterface\n{\n    public function create(string $serviceClass): ServiceInterface|null;\n\n}"}
{"instruction": "Write an Ephect PHP component", "input": "Based on Ephect source: ServiceInterface.php", "output": "<?php\n\nnamespace Ephect\\Framework\\Services;\n\ninterface ServiceInterface\n{\n    public function getName(): string;\n}"}
{"instruction": "Write an Ephect PHP component", "input": "Based on Ephect source: ServiceProviderInterface.php", "output": "<?php\n\nnamespace Ephect\\Framework\\Services;\n\ninterface ServiceProviderInterface\n{\n    public function register(): void;\n}"}
{"instruction": "Write an Ephect PHP component", "input": "Based on Ephect source: Session.php", "output": "<?php\n\nnamespace Ephect\\Framework\\Session;\n\nfinal class Session\n{\n    public function __construct()\n    {\n        if (session_id() === null) {\n            session_start();\n        }\n    }\n\n    public function read(string $key): mixed\n    {\n        if (session_id() !== null && isset($_SESSION[$key])) {\n            return $_SESSION[$key];\n        }\n\n        return null;\n    }\n\n    public function write(string $key, mixed $value): void\n    {\n        if (session_id() !== null) {\n            $_SESSION[$key] = $value;\n        }\n    }\n\n    public function delete(): void\n    {\n        session_unset();\n        session_destroy();\n        session_gc();\n        session_abort();\n    }\n\n}"}
{"instruction": "Write an Ephect PHP component", "input": "Based on Ephect source: JsonProperty.php", "output": "<?php\n\nnamespace Ephect\\Framework\\Structure;\n\nuse Attribute;\n\n#[Attribute(Attribute::TARGET_METHOD | Attribute::TARGET_PROPERTY)]\nclass JsonProperty\n{\n    public function __construct(\n        private string $name,\n    ) {\n    }\n}"}
{"instruction": "Write an Ephect PHP component", "input": "Based on Ephect source: Structure.php", "output": "<?php\n\nnamespace Ephect\\Framework\\Structure;\n\nuse Error;\nuse ReflectionClass;\nuse ReflectionProperty;\nuse stdClass;\n\nclass Structure implements StructureInterface\n{\n    public function __construct(object|array|null $props = null)\n    {\n        if (!is_array($props) && !is_object($props)) {\n            return;\n        }\n\n        foreach ($props as $key => $value) {\n            if (!property_exists($this, $key)) {\n                throw new Error(\"The property [$key] is not defined.\");\n            }\n\n            $this->{$key} = $value;\n        }\n    }\n\n    public static function create(...$params): static\n    {\n        $struct = new static(...$params);\n\n        return $struct;\n    }\n\n    public function toArray(): array\n    {\n        return get_object_vars($this);\n    }\n\n    public function encode(int $jsonOptions = JSON_PRETTY_PRINT, bool $asArray = false): array|string\n    {\n        $result = $this->recursiveEncode($this);\n        $json = json_encode($result, $jsonOptions);\n\n        return $asArray ? json_decode($json, $asArray) : $json;\n    }\n\n    private function recursiveEncode(StructureInterface $structure)\n    {\n        $result = new stdClass();\n\n        $ref = new ReflectionClass($structure);\n        $publicProps = $ref->getProperties(ReflectionProperty::IS_PUBLIC);\n        foreach ($publicProps as $prop) {\n            $propName = $prop->getName();\n\n            /*\n             * The structure doesn't have a value for this field.\n             * So, we go to the next field.\n             */\n            if (!isset($structure->{$propName})) {\n                continue;\n            }\n\n            $attrs = $prop->getAttributes();\n            $propType = $prop->getType();\n            $propValue = $structure->{$propName};\n\n            $resultPropName = $propName;\n\n            foreach ($attrs as $attr) {\n                if ($attr->getName() !== JsonProperty::class) {\n                    continue;\n                }\n\n                $args = $attr->getArguments();\n                $argName = $args['name'];\n\n                $resultPropName = $argName;\n                break;\n            }\n\n            if (!$propType->isBuiltin() && in_array(StructureInterface::class, class_implements($propType->getName()))) {\n                $result->{$resultPropName} = $this->recursiveEncode($propValue);\n            } else {\n                $result->{$resultPropName} = $propValue;\n            }\n        }\n\n        return $result;\n    }\n\n    public function decode(string|array $input): void\n    {\n        $array = $input;\n        if (is_string($input)) {\n            $array = json_decode($input, true);\n        }\n\n        $this->recursiveDecode($this, $array);\n    }\n\n    private function recursiveDecode(StructureInterface $structure, array $values): StructureInterface\n    {\n        $ref = new ReflectionClass($structure);\n        $publicProps = $ref->getProperties(ReflectionProperty::IS_PUBLIC);\n        foreach ($publicProps as $prop) {\n            $attrs = $prop->getAttributes();\n            $propName = $prop->getName();\n            $propType = $prop->getType();\n\n            foreach ($attrs as $attr) {\n                if ($attr->getName() !== JsonProperty::class) {\n                    continue;\n                }\n\n                $args = $attr->getArguments();\n                $argName = $args['name'];\n\n                if (isset($values[$argName])) {\n                    $values[$propName] = $values[$argName];\n                }\n                break;\n            }\n\n            if (!property_exists($structure, $propName)) {\n                throw new Error(\"The property [$propName] is not defined.\");\n            }\n\n            if (isset($values[$propName])) {\n                if (!$propType->isBuiltin() && in_array(StructureInterface::class, class_implements($propType->getName()))) {\n                    $propClass = $propType->getName();\n                    $structureChild = new $propClass();\n                    $structure->{$propName} = $this->recursiveDecode($structureChild, $values[$propName]);\n                } else {\n                    $structure->{$propName} = $values[$propName];\n                }\n            }\n        }\n\n        return $structure;\n    }\n}"}
{"instruction": "Write an Ephect PHP component", "input": "Based on Ephect source: StructureInterface.php", "output": "<?php\n\nnamespace Ephect\\Framework\\Structure;\n\ninterface StructureInterface\n{\n    public function toArray(): array;\n\n    public function encode(int $jsonOptions = JSON_PRETTY_PRINT, bool $asArray = false): array|string;\n\n    public function decode(string|array $input): void;\n}"}
{"instruction": "Write an Ephect PHP component", "input": "Based on Ephect source: StructureTrait.php", "output": "<?php\n\nnamespace Ephect\\Framework\\Structure;\n\nuse Error;\n\ntrait StructureTrait\n{\n    protected StructureInterface $structure;\n\n    protected function bindStructure(StructureInterface $structure)\n    {\n        $this->structure = $structure;\n        foreach ($structure as $key => $value) {\n            if (!property_exists($this, $key)) {\n                $class = get_class($this);\n                throw new Error(\"The property [$key] is not defined in {$class}.\");\n            }\n\n            $this->{$key} = $value;\n        }\n    }\n\n    public function getStructure(): StructureInterface\n    {\n        return $this->structure;\n    }\n}"}
{"instruction": "Write an Ephect PHP component", "input": "Based on Ephect source: TemplateMaker.php", "output": "<?php\n\nnamespace Ephect\\Framework\\Templates;\n\nuse Ephect\\Framework\\Utils\\File;\n\nclass TemplateMaker\n{\n    private string $template;\n\n    public function __construct(private readonly string $filename)\n    {\n        $contents = File::safeRead($this->filename);\n        $this->template = ($contents !== null) ? $contents : '';\n    }\n\n    public function make(array $params): void\n    {\n        $keys = array_keys($params);\n\n        if (count($keys) == 0) {\n            return;\n        }\n\n        foreach ($keys as $key) {\n            $this->template = str_replace('{{' . $key . '}}', $params[$key], $this->template);\n        }\n    }\n\n    public function save(string $destinationFile): void\n    {\n        File::safeWrite($destinationFile, $this->template);\n    }\n\n    public function getTemplate(): string\n    {\n        return $this->template;\n    }\n\n    public function setTemplate(string $template): void\n    {\n        $this->template = $template;\n    }\n\n}"}
{"instruction": "Write an Ephect PHP component", "input": "Based on Ephect source: Tree.php", "output": "<?php\n\nnamespace Ephect\\Framework\\Tree;\n\nclass Tree implements TreeInterface\n{\n    use TreeTrait;\n\n    public function __construct(array $list)\n    {\n        $this->elementList = $list;\n    }\n}"}
{"instruction": "Write an Ephect PHP component", "input": "Based on Ephect source: TreeInterface.php", "output": "<?php\n\nnamespace Ephect\\Framework\\Tree;\n\nuse Closure;\nuse IteratorAggregate;\n\ninterface TreeInterface extends IteratorAggregate\n{\n    public function add($object): int;\n\n    public function addArray($array): int;\n\n    public function insert($object, $index): bool;\n\n    public function update($object, $index): bool;\n\n    public function removeAt($index): bool;\n\n    public function find($object): ?int;\n\n    public function items(?int $index = null);\n\n    public function count(): int;\n\n    public function hasChildren(): bool;\n\n    public function forEach(callable $callback, TreeInterface $tree, Closure|null $breakOn = null): void;\n\n    public function forEachRecursive(callable $callback, TreeInterface $tree, Closure|null $breakOn = null): void;\n\n    public function clear(): void;\n\n\n}"}
{"instruction": "Write an Ephect PHP component", "input": "Based on Ephect source: TreeIterator.php", "output": "<?php\n\nnamespace Ephect\\Framework\\Tree;\n\nuse Ephect\\Framework\\ElementTrait;\nuse RecursiveIterator;\n\nclass TreeIterator implements RecursiveIterator\n{\n    use ElementTrait;\n\n    protected int $count = 0;\n    protected array $elementList = [];\n    protected bool $hasElements = false;\n    protected int $index = 0;\n    protected $innerChildren = null;\n\n    public function __construct(array $list)\n    {\n        $this->elementList = $list;\n    }\n\n\n    public function count(): int\n    {\n        $this->count = count($this->elementList);\n        return $this->count;\n    }\n\n    public function current(): mixed\n    {\n        if (!$this->valid()) {\n            return null;\n        }\n        return $this->elementList[$this->index];\n    }\n\n    public function valid(): bool\n    {\n        return isset($this->elementList[$this->index]);\n    }\n\n    public function key(): int\n    {\n        return $this->index;\n    }\n\n    public function next(): void\n    {\n        ++$this->index;\n    }\n\n    public function rewind(): void\n    {\n        $this->index = 0;\n    }\n\n    public function getChildren(): TreeIterator\n    {\n        $it = new TreeIterator($this->elementList);\n        return $it;\n    }\n\n    public function hasChildren(): bool\n    {\n        if ($this->hasElements === false) {\n            $this->hasElements = $this->elementList !== null;\n        }\n        return $this->hasElements;\n    }\n\n    public function toArray(): array\n    {\n        return $this->elementList;\n    }\n\n    public function toString(): string\n    {\n        $result = '';\n        for ($i = 0; $i < $this->count; $i++) {\n            $result .= $this->elementList[$i] . \"\\n\";\n        }\n\n        return $result;\n    }\n}"}
{"instruction": "Write an Ephect PHP component", "input": "Based on Ephect source: TreeTrait.php", "output": "<?php\n\nnamespace Ephect\\Framework\\Tree;\n\nuse Closure;\n\ntrait TreeTrait\n{\n    protected array $elementList = [];\n\n    public function getIterator(): TreeIterator\n    {\n        return new TreeIterator($this->elementList);\n    }\n\n    public function items(?int $index = null)\n    {\n        if ($index === null) {\n            return $this->elementList;\n        }\n        return $this->elementList[$index];\n    }\n\n    public function addArray($array): int\n    {\n        $result = 0;\n        foreach ($array as $item) {\n            $result = $this->add($item);\n        }\n\n        return $result;\n    }\n\n    public function add($object): int\n    {\n        $index = count($this->elementList);\n        $this->elementList[$index] = $object;\n\n        return $index;\n    }\n\n    public function insert($object, $index): bool\n    {\n        $current = [];\n        $current[0] = $object;\n        $current[1] = $this->elementList[$index];\n\n        array_splice($this->elementList, $index, null, $current);\n\n        return true;\n    }\n\n    public function update($object, $index): bool\n    {\n        $this->elementList[$index] = $object;\n\n        return true;\n    }\n\n    public function removeAt($index): bool\n    {\n        unset($this->elementList[$index]);\n\n        return true;\n    }\n\n    public function find($object): ?int\n    {\n        $result = array_search($object, $this->elementList, true);\n\n        return false === $result ? null : $result;\n    }\n\n    public function clear(): void\n    {\n        $c = count($this->elementList);\n        for ($i = 0; $i < $c; $i++) {\n            unset($this->elementList[$i]);\n        }\n\n        $this->elementList = [];\n    }\n\n    public function forEachRecursive(callable $callback, TreeInterface $tree, Closure|null $breakOn = null): void\n    {\n        foreach ($tree as $key => $item) {\n            if ($item->hasChildren()) {\n                $this->forEachRecursive($callback, $item, $breakOn);\n            }\n\n            call_user_func($callback, $item, $key);\n            if ($breakOn != null && $breakOn()) {\n                break;\n            }\n        }\n    }\n\n    public function hasChildren(): bool\n    {\n        return $this->count() > 0;\n    }\n\n    public function count(): int\n    {\n        return count($this->elementList);\n    }\n\n    public function forEach(callable $callback, TreeInterface $tree, Closure|null $breakOn = null): void\n    {\n        foreach ($tree as $key => $item) {\n            call_user_func($callback, $item, $key);\n            if ($breakOn != null && $breakOn()) {\n                break;\n            }\n            if ($item->hasChildren()) {\n                $this->forEach($callback, $item, $breakOn);\n            }\n        }\n    }\n}"}
{"instruction": "Write an Ephect PHP component", "input": "Based on Ephect source: File.php", "output": "<?php\n\nnamespace Ephect\\Framework\\Utils;\n\nuse FilesystemIterator;\nuse RecursiveDirectoryIterator;\nuse RecursiveIteratorIterator;\n\nclass File\n{\n    public static function walkTreeFiltered($path, $filter = [], $maxDepth1 = false): array\n    {\n        $result = [];\n\n        $l = strlen($path);\n\n        $iterator = null;\n\n        if ($maxDepth1) {\n            $iterator = dir($path);\n\n            while ($file = $iterator->read()) {\n                $fi = pathinfo($file);\n\n                if ($fi['basename'] == '.' || $fi['basename'] == '..') {\n                    continue;\n                }\n\n                if (is_dir($file)) {\n                    continue;\n                }\n\n                if (isset($fi['extension']) && $fi['extension'] === 'DS_Store') {\n                    continue;\n                }\n\n                if (\n                    (count($filter) > 0 && isset($fi['extension']) && in_array($fi['extension'], $filter))\n                    || count($filter) === 0\n                ) {\n                    $result[] = $file;\n                }\n            }\n        } else {\n            $dir_iterator = new RecursiveDirectoryIterator($path, FilesystemIterator::FOLLOW_SYMLINKS);\n            $iterator = new RecursiveIteratorIterator($dir_iterator, RecursiveIteratorIterator::CHILD_FIRST);\n\n            foreach ($iterator as $file) {\n                $fi = pathinfo($file->getPathName());\n\n                if ($fi['basename'] == '.' || $fi['basename'] == '..') {\n                    continue;\n                }\n\n                if (is_dir($file->getPathName())) {\n                    continue;\n                }\n\n                if (isset($fi['extension']) && $fi['extension'] === 'DS_Store') {\n                    continue;\n                }\n\n                if (\n                    (count($filter) > 0 && isset($fi['extension']) && in_array($fi['extension'], $filter))\n                    || count($filter) === 0\n                ) {\n                    $result[] = substr($file->getPathName(), $l);\n                }\n            }\n        }\n\n        return $result;\n    }\n\n    public static function walkTree(string $path, array &$tree = []): int\n    {\n        $class_func = array(__CLASS__, __FUNCTION__);\n        return is_file($path) ?\n            @array_push($tree, $path) :\n            array_map($class_func, glob($path . '/*'), $tree);\n    }\n\n    public static function delTree(string $path): bool\n    {\n        $class_func = array(__CLASS__, __FUNCTION__);\n        return is_file($path) ?\n            @unlink($path) :\n            array_map($class_func, glob($path . '/*')) == @rmdir($path);\n    }\n\n    public static function safeMkDir(string $directory): bool\n    {\n        if (!$result = file_exists($directory)) {\n            $result = mkdir($directory, 0775, true);\n        }\n\n        return $result;\n    }\n\n    public static function safeRmdir($src): bool\n    {\n        if (!file_exists($src)) {\n            return false;\n        }\n\n        $dir = opendir($src);\n        while (false !== ($file = readdir($dir))) {\n            if (($file != '.') && ($file != '..')) {\n                $full = $src . DIRECTORY_SEPARATOR . $file;\n                if (is_dir($full)) {\n                    self::safeRmdir($full);\n                } else {\n                    unlink($full);\n                }\n            }\n        }\n        closedir($dir);\n        rmdir($src);\n\n        return true;\n    }\n\n    public static function safeWrite(string $filename, string $contents): ?int\n    {\n        $dir = pathinfo($filename, PATHINFO_DIRNAME);\n        self::safeMkDir($dir);\n        return (false === $len = file_put_contents($filename, $contents)) ? null : $len;\n    }\n\n    public static function safeRead(string $filename): ?string\n    {\n        if (!file_exists($filename)) {\n            return null;\n        }\n        return (false === $contents = file_get_contents($filename)) ? null : $contents;\n    }\n\n    public static function safeCopy(string $source, string $destination): bool\n    {\n        if (!file_exists($source)) {\n            return false;\n        }\n\n        $dir = pathinfo($destination, PATHINFO_DIRNAME);\n        self::safeMkDir($dir);\n\n        copy($source, $destination);\n\n        return true;\n    }\n\n    public static function safeReadLines(string $filename): ?array\n    {\n        if (!file_exists($filename)) {\n            return null;\n        }\n        return (false === $contents = file($filename)) ? null : $contents;\n    }\n\n    /**\n     * Should be replaced by realpath()\n     *\n     * @param string $path\n     * @return string\n     */\n    public static function reducePath(string $path): string\n    {\n        $array = explode(DIRECTORY_SEPARATOR, $path);\n\n        $c = count($array);\n        $offset = 1;\n        for ($i = 0; $i < $c; $i++) {\n            if ($array[$i] == '..') {\n                unset($array[$i]);\n                unset($array[$i - $offset]);\n                $offset += 2;\n            }\n        }\n\n        return implode(DIRECTORY_SEPARATOR, $array);\n    }\n}"}
{"instruction": "Write an Ephect PHP component", "input": "Based on Ephect source: Misc.php", "output": "<?php\n\nnamespace Ephect\\Framework\\Utils;\n\nuse DateTimeImmutable;\nuse Random\\Randomizer;\n\nclass Misc\n{\n    public static function makeId(): int\n    {\n        $dti = new DateTimeImmutable();\n        $ts = $dti->getTimestamp();\n        $string = str_split($ts);\n\n        $r = new Randomizer();\n        $result = implode('', $r->shuffleArray($string));\n\n        return intval($result);\n    }\n}"}
{"instruction": "Write an Ephect PHP component", "input": "Based on Ephect source: Text.php", "output": "<?php\n\nnamespace Ephect\\Framework\\Utils;\n\nuse ReflectionException;\nuse ReflectionFunction;\nuse SplFileObject;\n\nclass Text\n{\n    public static function slugify(string $text): ?string\n    {\n        // replace non letter or digits by -\n        $text = preg_replace('#[^\\\\pL\\d]+#u', '-', $text);\n\n        // trim\n        $text = trim($text, '-');\n\n        // transliterate\n        if (function_exists('iconv')) {\n            $text = iconv('utf-8', 'us-ascii//TRANSLIT', $text);\n        }\n\n        // lowercase\n        $text = strtolower($text);\n\n        // remove unwanted characters\n        $text = preg_replace('#[^-\\w]+#', '', $text);\n\n        if (empty($text)) {\n            return null;\n        }\n\n        $text = iconv('us-ascii', 'utf-8', $text);\n\n        return $text;\n    }\n\n    public static function format(string|array|object $string, ...$params): string\n    {\n        $result = $string;\n\n        if (is_object($string)) {\n            $result = json_encode($string, JSON_PRETTY_PRINT);\n        }\n        if (is_array($string)) {\n            $result = print_r($string, true);\n        }\n        if (count($params) > 0 && count($params[0]) > 0) {\n            $result = vsprintf($string, $params[0]);\n        }\n\n        return $result;\n    }\n\n    public static function jsonToPhpReturnedArray(string|array $json, bool $prettify = true): string\n    {\n        $array = [];\n        if (!is_array($json)) {\n            $array = json_decode($json, JSON_OBJECT_AS_ARRAY);\n        }\n        $result = '<?php' . PHP_EOL;\n        $result .= 'return ';\n\n        $result .= self::arrayToString($array, $prettify);\n        $result .= ';' . PHP_EOL;\n\n        return $result;\n    }\n\n    public static function arrayToString(array $array, bool $prettify = false): string\n    {\n        $dump = var_export($array, true);\n\n        $convert = '';\n\n        $re = '/(.*)(\\'(.*)\\' =>)( +)?(\\n)( +)/m';\n        $subst = \"$1$2\";\n        $entries = preg_replace($re, $subst, $dump);\n        $buffer = $entries;\n\n        $entryRx = '/( +)?((.*) =>)?(((array) \\()| \\'?((.|\\s)*?)\\'?,$)?(\\n)?/m';\n        $closeArrayRx = '/^( +)?\\),?(\\n)?/';\n\n        $isSpinning = false;\n        $countSpinning = 0;\n        $isDirty = false;\n\n        try {\n            while (strlen($buffer) > 0 && !$isSpinning) {\n                $isDirty = false;\n\n                if (preg_match($closeArrayRx, $buffer, $matches)) {\n                    $indent = !isset($matches[1]) ? '' : $matches[1];\n                    $convert .= $indent . ']' . ($indent == '' ? '' : ',');\n                    $convert .= \"\\n\";\n                    $stringLen = strlen($matches[0]);\n                    $buffer = substr($buffer, $stringLen);\n                    $isDirty = true;\n                } elseif (preg_match($entryRx, $buffer, $matches)) {\n                    $indent = !isset($matches[1]) ? '' : $matches[1];\n                    $convert .= $indent;\n                    $key = !isset($matches[3]) ? '' : $matches[3];\n\n                    if (isset($matches[6]) && $matches[6] == 'array') {\n                        $convert .= !empty($key) ? $key . ' => [' : '[';\n\n                        $stringLen = strlen($matches[0]);\n                        $buffer = substr($buffer, $stringLen);\n                        $isDirty = true;\n                    } else {\n                        $value = !isset($matches[4]) ? '' : $matches[4];\n\n                        if (isset($matches[7]) && str_starts_with($matches[7], 'function')) {\n                            $value = stripslashes($matches[7]) . ',';\n                        }\n\n                        if ($key !== '' && $key[0] == \"'\") {\n                            $convert .= $key . ' => ' . $value;\n                        } else {\n                            $convert .= $value;\n                        }\n\n                        $stringLen = strlen($matches[0]);\n                        $buffer = substr($buffer, $stringLen);\n                        $isDirty = true;\n                    }\n                    $convert .= \"\\n\";\n\n                }\n\n                if (!$isDirty) {\n                    $countSpinning++;\n                }\n\n                $isSpinning = $countSpinning > 10;\n            }\n\n        } catch (\\Exception $exception) {\n            throw new Exception(\"Something went wrong while converting array to string\", 1, $exception);\n        }\n\n        if (!$prettify) {\n            $convert = str_replace(\"\\n\", \"\", $convert);\n        }\n\n        return $convert;\n    }\n\n    /**\n     * @throws ReflectionException\n     */\n    private function callableToString(callable $controller): string\n    {\n        $ref = new ReflectionFunction($controller);\n\n        $file = new SplFileObject($ref->getFileName());\n        $file->seek($ref->getStartLine() - 1);\n\n        $code = '';\n        while ($file->key() < $ref->getEndLine()) {\n            $code .= $file->current();\n            $file->next();\n        }\n\n        $begin = strpos($code, 'function');\n        $end = strrpos($code, '}');\n        $code = substr($code, $begin, $end - $begin + 1);\n\n        return $code;\n    }\n\n}"}
{"instruction": "Write an Ephect PHP component", "input": "Based on Ephect source: Zip.php", "output": "<?php\n\nnamespace Ephect\\Framework\\Utils;\n\nuse ZipArchive;\n\nuse function mkdir;\n\nclass Zip\n{\n    //put your code here\n    public function inflate($src_file, $dest_dir = false, $create_zip_name_dir = true, $overwrite = true): bool\n    {\n        $zip = new ZipArchive();\n\n        if (!$zip->open($src_file)) {\n            return false;\n        }\n\n        $splitter = ($create_zip_name_dir === true) ? \".\" : \"/\";\n        if ($dest_dir === false) {\n            $dest_dir = substr($src_file, 0, strrpos($src_file, $splitter)) . \"/\";\n        }\n\n        // Create the directories to the destination dir if they don't already exist\n        if (!file_exists($dest_dir)) {\n            mkdir($dest_dir, 0777, true);\n        }\n\n        // For every file in the zip-packet\n        for ($i = 0; $i < $zip->numFiles; $i++) {\n\n            $filename = $zip->statIndex($i)['name'];\n            $pos_last_slash = strrpos($filename, \"/\");\n            if ($pos_last_slash !== false) {\n                // Create the directory where the zip-entry should be saved (with a \"/\" at the end)\n                $path = $dest_dir . substr($filename, 0, $pos_last_slash + 1);\n                if (!file_exists($path)) {\n                    mkdir($path, 0777, true);\n                }\n            }\n\n            $zip->extractTo($dest_dir, $filename);\n        }\n        $zip->close();\n\n        return true;\n    }\n}"}
{"instruction": "Write an Ephect PHP component", "input": "Based on Ephect source: ApplicationIgniter.php", "output": "<?php\n\nnamespace Ephect\\Framework\\Web;\n\nuse Ephect\\Framework\\Middlewares\\ApplicationStateMiddlewareInterface;\n\nuse function Ephect\\Hooks\\useState;\n\nclass ApplicationIgniter\n{\n    public function ignite(): void\n    {\n        [$middlewares] = useState(get: 'middlewares');\n\n        if ($middlewares === null) {\n            return;\n        }\n\n        foreach ($middlewares as $className => $arguments) {\n            //            $filename = FrameworkRegistry::read($className);\n            if (class_exists($className) && class_implements($className, ApplicationStateMiddlewareInterface::class)) {\n                //                include_once $filename;\n                $middleware = new $className();\n                $middleware((object)$arguments);\n            }\n        }\n    }\n}"}
{"instruction": "Write an Ephect PHP component", "input": "Based on Ephect source: Curl.php", "output": "<?php\n\nnamespace Ephect\\Framework\\Web;\n\nuse Exception;\n\nclass Curl\n{\n    //put your code here\n\n    /**\n     * @throws Exception\n     */\n    public function request($uri, $headers = [], $data = []): array\n    {\n\n        $ch = curl_init();\n        curl_setopt($ch, CURLOPT_URL, $uri);\n        curl_setopt($ch, CURLOPT_RETURNTRANSFER, 1);\n        curl_setopt($ch, CURLOPT_FOLLOWLOCATION, true);\n        curl_setopt($ch, CURLOPT_SSL_VERIFYHOST, false);\n        curl_setopt($ch, CURLOPT_SSL_VERIFYPEER, false);\n        //            curl_setopt($ch, CURLOPT_CAINFO, $certpath);\n        //            curl_setopt($ch, CURLOPT_CAPATH, $certpath);\n        if (count($headers) > 0) {\n            curl_setopt($ch, CURLOPT_HTTPHEADER, $headers);\n        }\n        if (count($data) > 0) {\n            $queryString = http_build_query($data);\n            curl_setopt($ch, CURLOPT_POST, true);\n            curl_setopt($ch, CURLOPT_POSTFIELDS, $queryString);\n        } else {\n            curl_setopt($ch, CURLOPT_CUSTOMREQUEST, 'GET');\n\n        }\n        curl_setopt($ch, CURLOPT_HEADER, 0);\n        curl_setopt($ch, CURLINFO_HEADER_OUT, true);\n\n        $content = curl_exec($ch);\n        $error = curl_error($ch);\n        $errno = curl_errno($ch);\n\n        $info = curl_getinfo($ch);\n\n        $header = (isset($info['request_header'])) ? $info['request_header'] : '';\n\n        if ($errno > 0) {\n            throw new Exception($error, $errno);\n        }\n        if ($header == '') {\n            throw new Exception(\"Curl is not working fine for some reason. Are you using Android ?\");\n        }\n\n        $code = (int)$info['http_code'];\n        curl_close($ch);\n\n        return [$code, $header, $content];\n    }\n}"}
{"instruction": "Write an Ephect PHP component", "input": "Based on Ephect source: XmlUtils.php", "output": "<?php\n\nnamespace Ephect\\Framework\\Xml;\n\n/**\n * Description of xml\n *\n * @author David\n */\nclass XmlUtils\n{\n    //put your code here\n    public static function convertArray(array $array, string $node_block = 'nodes', string $node_name = 'node'): string\n    {\n        $xml = '<?xml version=\"1.0\" encoding=\"UTF-8\" ?>' . \"\\n\";\n\n        $xml .= '<' . $node_block . '>' . \"\\n\";\n        $xml .= self::convertArrayEx($array, $node_name);\n        $xml .= '</' . $node_block . '>' . \"\\n\";\n\n        return $xml;\n    }\n\n    private static function convertArrayEx(mixed $array, string $node_name): string\n    {\n        $xml = '';\n\n        if (is_array($array) || is_object($array)) {\n            foreach ($array as $key => $value) {\n                if (is_numeric($key)) {\n                    $key = $node_name;\n                }\n\n                $xml .= '<' . $key . '>' . \"\\n\" . self::convertArrayEx($value, $node_name) . '</' . $key . '>' . \"\\n\";\n            }\n        } else {\n            $xml = htmlspecialchars($array, ENT_QUOTES) . \"\\n\";\n        }\n\n        return $xml;\n    }\n}"}
{"instruction": "Write an Ephect PHP component", "input": "Based on Ephect source: ComposerConfigEntity.php", "output": "<?php\n\nnamespace Ephect\\Framework\\Modules\\Composer;\n\nuse Ephect\\Framework\\Manifest\\ManifestEntity;\nuse Ephect\\Framework\\Structure\\StructureTrait;\nuse Override;\n\nuse function siteRoot;\n\nclass ComposerConfigEntity extends ManifestEntity\n{\n    use StructureTrait;\n\n    private string $name;\n\n    private string $type;\n\n    private string $homepage;\n\n    private string $license;\n\n    private string $description;\n\n    private array $authors;\n\n    private array $autoload;\n\n    private string $minimumStability;\n\n    private array $require = [];\n\n    private array $requireDev = [];\n\n    public function __construct(private ?ComposerConfigStructure $structure = null)\n    {\n        $this->filename = siteRoot() . \"composer.json\";\n\n        parent::__construct($structure);\n\n        if ($structure instanceof ComposerConfigStructure) {\n            $this->bindStructure($this->structure);\n        }\n    }\n\n    public function getName(): string\n    {\n        return $this->name;\n    }\n\n    public function getType(): string\n    {\n        return $this->type;\n    }\n\n    public function getHomepage(): string\n    {\n        return $this->homepage;\n    }\n\n    public function getLicense(): string\n    {\n        return $this->license;\n    }\n\n    public function getDescription(): string\n    {\n        return $this->description;\n    }\n\n    public function getAuthors(): array\n    {\n        return $this->authors;\n    }\n\n    public function getAutoload(): array\n    {\n        return $this->autoload;\n    }\n\n    public function getMinimumStability(): string\n    {\n        return $this->minimumStability;\n    }\n\n    public function getRequire(): array\n    {\n        return $this->require;\n    }\n\n    public function getRequireDev(): array\n    {\n        return $this->requireDev;\n    }\n\n    #[Override]\n    public function load(bool $asPhpArray = false): void\n    {\n        parent::load($asPhpArray);\n        $this->structure = new ComposerConfigStructure($this->data);\n        $this->bindStructure($this->structure);\n    }\n\n    #[Override]\n    public function save(bool $asPhpArray = false): void\n    {\n        // DO NOT SAVE composer.json\n    }\n\n    private function bindStructure_()\n    {\n        $this->name = $this->structure->name;\n        $this->type = $this->structure->type;\n        $this->homepage = $this->structure->homepage;\n        $this->license = $this->structure->license;\n        $this->description = $this->structure->description;\n        $this->authors = $this->structure->authors;\n        $this->autoload = $this->structure->autoload;\n        $this->minimumStability = $this->structure->minimumStability;\n        $this->require = $this->structure->require;\n        $this->requireDev = $this->structure->requireDev;\n    }\n}"}
{"instruction": "Write an Ephect PHP component", "input": "Based on Ephect source: ComposerConfigReader.php", "output": "<?php\n\nnamespace Ephect\\Framework\\Modules\\Composer;\n\nuse Ephect\\Framework\\Manifest\\ManifestReader;\nuse Ephect\\Framework\\Utils\\File;\nuse ErrorException;\nuse JsonException;\n\nuse function siteRoot;\n\nclass ComposerConfigReader extends ManifestReader\n{\n    /**\n     * @throws JsonException\n     * @throws ErrorException\n     */\n    public function read(?string $manifestDirectory = null): ComposerConfigEntity\n    {\n        $json = File::safeRead(siteRoot() . \"composer.json\");\n        $struct = new ComposerConfigStructure();\n        $struct->decode($json);\n\n        return new ComposerConfigEntity($struct);\n    }\n}"}
{"instruction": "Write an Ephect PHP component", "input": "Based on Ephect source: ComposerConfigStructure.php", "output": "<?php\n\nnamespace Ephect\\Framework\\Modules\\Composer;\n\nuse Ephect\\Framework\\Structure\\JsonProperty;\nuse Ephect\\Framework\\Structure\\Structure;\n\nclass ComposerConfigStructure extends Structure\n{\n    public string $name = '';\n\n    public string $type = '';\n\n    public string $homepage = '';\n\n    public string $license = '';\n\n    public string $description = '';\n\n    public array $authors = [];\n\n    public array $autoload = [];\n\n    #[JsonProperty(name: \"minimum-stability\")]\n    public string $minimumStability = '';\n\n    public array $require = [];\n\n    #[JsonProperty(name: \"require-dev\")]\n    public array $requireDev = [];\n}"}
{"instruction": "Write an Ephect domain event", "input": "Based on Ephect source: EventServiceProvider.php", "output": "<?php\n\nnamespace Ephect\\Framework\\Event\\Service;\n\nuse Ephect\\Framework\\Event\\EventDispatcher;\nuse Ephect\\Framework\\Services\\ServiceProviderInterface;\n\nuse function Ephect\\Hooks\\useState;\n\nreadonly class EventServiceProvider implements ServiceProviderInterface\n{\n    /**\n     * @param EventDispatcher $dispatcher\n     * @param array<class-string, array<class-string>> $eventListeners\n     */\n    public function __construct(\n        private EventDispatcher $dispatcher,\n        private array $eventListeners = [],\n    ) {\n    }\n\n    /**\n     * @return void\n     */\n    public function register(): void\n    {\n        [$events, $setState] = useState(get: 'events');\n\n        foreach ($this->eventListeners as $eventClass => $listeners) {\n            $events[$eventClass] = $listeners;\n            foreach (array_unique($listeners) as $listener) {\n                $this->dispatcher->addListener($eventClass, new $listener());\n            }\n        }\n\n        $setState(['events' => $events]);\n    }\n}"}
{"instruction": "Write an Ephect command handler", "input": "Based on Ephect source: CommandDeclaration.php", "output": "<?php\n\nnamespace Ephect\\Framework\\Commands\\Attributes;\n\nuse Attribute;\n\n#[Attribute(Attribute::IS_REPEATABLE | Attribute::TARGET_CLASS)]\nclass CommandDeclaration\n{\n    public function __construct(\n        public string $verb = '',\n        public string $subject = '',\n        public string $desc = '',\n        public bool   $isPhar = false\n    ) {\n    }\n}"}
{"instruction": "Write an Ephect PHP component", "input": "Based on Ephect source: ConsoleOptionsEnum.php", "output": "<?php\n\nnamespace Ephect\\Framework\\CLI\\Enums;\n\nenum ConsoleOptionsEnum\n{\n    case None;\n    case ErrorMessageOnly;\n}"}
{"instruction": "Write an Ephect PHP component", "input": "Based on Ephect source: Watcher.php", "output": "<?php\n\ndeclare(ticks=1);\n\nnamespace Ephect\\Framework\\CLI\\FileSystem;\n\nuse Ephect\\Framework\\CLI\\Console;\nuse Ephect\\Framework\\Utils\\File;\n\nuse function Ephect\\Hooks\\useInterval;\n\nclass Watcher\n{\n    public function watch(string $directory, array $filter): void\n    {\n        $mtimes = [];\n\n        useInterval(function () use ($directory, $filter, &$mtimes) {\n            $files = $this->_listFiles($directory, $filter);\n\n            foreach ($files as $filename) {\n\n                $mtime = filemtime($directory . $filename);\n\n                if (isset($mtimes[$filename]) && $mtimes[$filename] < $mtime) {\n                    Console::writeLine('File \"%s\" was modified', $directory . $filename);\n                }\n                $mtimes[$filename] = $mtime;\n\n            }\n\n        }, 100);\n\n        while (true) {\n            usleep(1);\n        }\n\n    }\n\n    private function _listFiles(string $directory, array $filter): array\n    {\n        return File::walkTreeFiltered($directory, $filter);\n    }\n}"}
{"instruction": "Write an Ephect PHP component", "input": "Based on Ephect source: PharInterface.php", "output": "<?php\n\nnamespace Ephect\\Framework\\CLI\\Phar;\n\ninterface PharInterface\n{\n    public function addPharFiles();\n}"}
{"instruction": "Write an Ephect command handler", "input": "Based on Ephect source: Command.php", "output": "<?php\n\nnamespace Ephect\\Framework\\CLI\\System;\n\nuse Ephect\\Framework\\CLI\\Console;\nuse Exception;\n\nclass Command\n{\n    public function execute(string $cmd, ...$args): int\n    {\n        $fqcmd = $cmd . ' ' . implode(' ', $args);\n        $return = system($fqcmd, $returnCode);\n\n        if (false === $return) {\n            throw new Exception('Something went wrong while trying to execute: ' . $fqcmd . '.');\n        }\n        Console::writeLine($return);\n        return $returnCode;\n    }\n\n    public function which($bin): ?string\n    {\n        $result = null;\n\n        $cleanBin = preg_replace('/([\\w]+)/', '$1', $bin);\n\n        if ($cleanBin !== $bin) {\n            return null;\n        }\n\n        $cmd = \"which $bin\";\n        if (PHP_OS == 'WINNT') {\n            $cmd = \"cmd /c where $bin\";\n        }\n\n        return exec($cmd, $output, $code);\n    }\n}"}
{"instruction": "Write an Ephect command handler", "input": "Based on Ephect source: Main.php", "output": "<?php\n\nnamespace Ephect\\Commands\\ClearAll;\n\nuse Ephect\\Framework\\CLI\\Console;\nuse Ephect\\Framework\\Commands\\AbstractCommand;\nuse Ephect\\Framework\\Commands\\Attributes\\CommandDeclaration;\n\n#[CommandDeclaration(verb: \"clear\", subject: \"all\")]\n#[CommandDeclaration(desc: \"Clear cache, runtime and log files.\")]\nclass Main extends AbstractCommand\n{\n    public function run(): int\n    {\n        $data = $this->application->clearLogs();\n        Console::writeLine($data);\n        $data = $this->application->clearRuntime();\n        Console::writeLine($data);\n\n        return 0;\n    }\n}"}
{"instruction": "Write an Ephect command handler", "input": "Based on Ephect source: Main.php", "output": "<?php\n\nnamespace Ephect\\Commands\\ClearCache;\n\nuse Ephect\\Framework\\CLI\\Console;\nuse Ephect\\Framework\\Commands\\AbstractCommand;\nuse Ephect\\Framework\\Commands\\Attributes\\CommandDeclaration;\n\n#[CommandDeclaration(verb: \"clear\", subject: \"cache\")]\n#[CommandDeclaration(desc: \"Clear all cache files.\")]\nclass Main extends AbstractCommand\n{\n    public function run(): int\n    {\n        $data = $this->application->clearRuntime();\n        Console::writeLine($data);\n\n        return 0;\n    }\n}"}
{"instruction": "Write an Ephect command handler", "input": "Based on Ephect source: Main.php", "output": "<?php\n\nnamespace Ephect\\Commands\\ClearLogs;\n\nuse Ephect\\Framework\\CLI\\Console;\nuse Ephect\\Framework\\Commands\\AbstractCommand;\nuse Ephect\\Framework\\Commands\\Attributes\\CommandDeclaration;\n\n#[CommandDeclaration(verb: \"clear\", subject: \"logs\")]\n#[CommandDeclaration(desc: \"Clear all logs.\")]\nclass Main extends AbstractCommand\n{\n    public function run(): int\n    {\n        $data = $this->application->clearLogs();\n        Console::writeLine($data);\n\n        return 0;\n    }\n}"}
{"instruction": "Write an Ephect command handler", "input": "Based on Ephect source: Main.php", "output": "<?php\n\nnamespace Ephect\\Commands\\Help;\n\nuse Ephect\\Framework\\Commands\\AbstractCommand;\nuse Ephect\\Framework\\Commands\\Attributes\\CommandDeclaration;\n\n#[CommandDeclaration(verb: \"help\")]\n#[CommandDeclaration(desc: \"Display this help\")]\nclass Main extends AbstractCommand\n{\n    public function run(): int\n    {\n        $this->application->help();\n\n        return 0;\n    }\n}"}
{"instruction": "Write an Ephect command handler", "input": "Based on Ephect source: Main.php", "output": "<?php\n\nnamespace Ephect\\Commands\\History;\n\nuse Ephect\\Framework\\CLI\\Console;\nuse Ephect\\Framework\\Commands\\AbstractCommand;\nuse Ephect\\Framework\\Commands\\Attributes\\CommandDeclaration;\n\n#[CommandDeclaration(verb: \"history\")]\n#[CommandDeclaration(desc: \"Display the commands history.\")]\nclass Main extends AbstractCommand\n{\n    public function run(): int\n    {\n        $history = readline_list_history();\n        Console::writeLine($history);\n\n        return 0;\n    }\n}"}
{"instruction": "Write an Ephect command handler", "input": "Based on Ephect source: Lib.php", "output": "<?php\n\nnamespace Ephect\\Commands\\InstallModule;\n\nuse Ephect\\Framework\\Commands\\AbstractCommandLib;\nuse Ephect\\Framework\\Modules\\ModuleInstaller;\n\nclass Lib extends AbstractCommandLib\n{\n    public function install(string $workingDirectory, bool $remove): void\n    {\n        $moduleInstaller = new ModuleInstaller($workingDirectory);\n        if ($remove) {\n            $moduleInstaller->remove();\n        } else {\n            $moduleInstaller->install();\n        }\n    }\n}"}
{"instruction": "Write an Ephect command handler", "input": "Based on Ephect source: Main.php", "output": "<?php\n\nnamespace Ephect\\Commands\\InstallModule;\n\nuse Ephect\\Framework\\Commands\\AbstractCommand;\nuse Ephect\\Framework\\Commands\\Attributes\\CommandDeclaration;\n\n#[CommandDeclaration(verb: \"install\", subject: \"module\")]\n#[CommandDeclaration(desc: \"Install an Ephect framework module.\")]\nclass Main extends AbstractCommand\n{\n    public function run(): int\n    {\n        $workingDirectory = $this->application->getArgi(2);\n        $remove = $this->application->getArgi(3);\n\n        $lib = new Lib($this->application);\n        $lib->install($workingDirectory, $remove == '-r');\n\n        return 0;\n    }\n}"}
{"instruction": "Write an Ephect command handler", "input": "Based on Ephect source: Lib.php", "output": "<?php\n\nnamespace Ephect\\Commands\\InstallPlugin;\n\nuse Ephect\\Framework\\Commands\\AbstractCommandLib;\nuse Ephect\\Framework\\Plugins\\PluginInstaller;\n\nclass Lib extends AbstractCommandLib\n{\n    public function install(string $workingDirectory, bool $remove): void\n    {\n        $pluginInstaller = new PluginInstaller($workingDirectory);\n        if ($remove) {\n            $pluginInstaller->remove();\n        } else {\n            $pluginInstaller->install();\n        }\n    }\n}"}
{"instruction": "Write an Ephect command handler", "input": "Based on Ephect source: Main.php", "output": "<?php\n\nnamespace Ephect\\Commands\\InstallPlugin;\n\nuse Ephect\\Framework\\Commands\\AbstractCommand;\nuse Ephect\\Framework\\Commands\\Attributes\\CommandDeclaration;\n\n#[CommandDeclaration(verb: \"install\", subject: \"plugin\")]\n#[CommandDeclaration(desc: \"Install an Ephect framework plugin.\")]\nclass Main extends AbstractCommand\n{\n    public function run(): int\n    {\n        $workingDirectory = $this->application->getArgi(2);\n        $remove = $this->application->getArgi(3);\n\n        $lib = new Lib($this->application);\n        $lib->install($workingDirectory, $remove == '-r');\n\n        return 0;\n    }\n}"}
{"instruction": "Write an Ephect component", "input": "Based on Ephect source: Lib.php", "output": "<?php\n\nnamespace Ephect\\Commands\\MakeCommand;\n\nuse Ephect\\Framework\\CLI\\Console;\nuse Ephect\\Framework\\CLI\\ConsoleColors;\nuse Ephect\\Framework\\CLI\\Enums\\ConsoleOptionsEnum;\nuse Ephect\\Framework\\Commands\\AbstractCommandLib;\nuse Ephect\\Framework\\Commands\\Builder;\nuse Exception;\n\nclass Lib extends AbstractCommandLib\n{\n    public function createCommandBase(): void\n    {\n        try {\n            Console::writeLine(ConsoleColors::getColoredString(\"Creating a new command.\", ConsoleColors::LIGHT_BLUE));\n            Console::writeLine(ConsoleColors::getColoredString(\"Please, answer the following questions.\", ConsoleColors::BLUE));\n            Console::writeLine(ConsoleColors::getColoredString(\"Leaving the answer blank aborts the process on mandatory questions.\", ConsoleColors::BROWN));\n            Console::writeLine(ConsoleColors::getColoredString(\"Mandatory questions are marked with *.\", ConsoleColors::BROWN));\n\n            $builder = new Builder();\n            [$verb, $subject, $description, $methodName, $arguments] = $this->readLine();\n\n            $commandName = $subject != \"\" ? $verb . \":\" . $subject : ucfirst($verb);\n            $commandDirectory = $subject != \"\" ? ucfirst($verb) . ucfirst($subject) : ucfirst($verb);\n\n            $destDir = \\Constants::SRC_ROOT . 'Commands' . DIRECTORY_SEPARATOR . $commandDirectory . DIRECTORY_SEPARATOR;\n            $srcDir = \\Constants::EPHECT_ROOT . 'Templates' . DIRECTORY_SEPARATOR . 'Commands' . DIRECTORY_SEPARATOR;\n            $builder->copyTemplates($verb, $subject, $description, $methodName, $arguments, $srcDir, $destDir);\n\n            Console::writeLine(\n                ConsoleColors::getColoredString(\"Command \", ConsoleColors::BLUE)\n                . \"%s\"\n                . ConsoleColors::getColoredString(\" is available in:\", ConsoleColors::BLUE),\n                $commandName\n            );\n            Console::writeLine(\"%s\", $destDir);\n        } catch (Exception $ex) {\n            Console::error($ex, ConsoleOptionsEnum::ErrorMessageOnly);\n        }\n    }\n\n    /**\n     * Ask some questions to get the properties of the webComponent\n     *\n     * @return array\n     * @throws Exception\n     */\n    private function readLine(): array\n    {\n        /**\n         * Asking for the verb\n         */\n        $verb = Console::readLine(\"* Verb (kebab-case, eg: make, create, clear, etc.): \");\n        $verb = strtolower($verb);\n        if (trim($verb) == '') {\n            throw new Exception(\"Verb must not be empty\");\n        }\n\n        /**\n         * Asking for the subject\n         */\n        $subject = Console::readLine(\"Subject (kebab-case): \");\n        $subject = strtolower($subject);\n\n        /**\n         * Asking for the description\n         */\n        $description = Console::readLine(\"* Description: \");\n        if (trim($description) == '') {\n            throw new Exception(\"* Description must not be empty\");\n        }\n\n        /**\n         * Asking for the method name\n         */\n        $methodName = Console::readLine(\"* Method name (camelCase): \");\n        if (trim($methodName) == '') {\n            throw new Exception(\"Method name must not be empty\");\n        }\n\n        /**\n         * Asking for arguments\n         */\n        $next = true;\n        $argIndex = 1;\n        $arguments = [];\n        while ($next) {\n            $arg = Console::readLine(\"Argument $argIndex: \");\n            if (trim($arg) == '') {\n                Console::writeLine(ConsoleColors::getColoredString(\"Ending command arguments list\", ConsoleColors::LIGHT_BLUE));\n                $next = false;\n                continue;\n            }\n            $arguments[] = $arg;\n            $argIndex++;\n        }\n\n        return [$verb, $subject, $description, $methodName, $arguments];\n    }\n}"}
{"instruction": "Write an Ephect command handler", "input": "Based on Ephect source: Main.php", "output": "<?php\n\nnamespace Ephect\\Commands\\MakeCommand;\n\nuse Ephect\\Framework\\Commands\\AbstractCommand;\nuse Ephect\\Framework\\Commands\\Attributes\\CommandDeclaration;\n\n#[CommandDeclaration(verb: \"make\", subject: \"command\")]\n#[CommandDeclaration(desc: \"Create the base tree of a command.\")]\nclass Main extends AbstractCommand\n{\n    public function run(): int\n    {\n        $lib = new Lib($this->application);\n        $lib->createCommandBase();\n        $this->application->clearRuntime();\n\n        return 0;\n    }\n}"}
{"instruction": "Write an Ephect command handler", "input": "Based on Ephect source: Lib.php", "output": "<?php\n\nnamespace Ephect\\Commands\\ModuleRemove;\n\nuse Ephect\\Framework\\CLI\\Console;\nuse Ephect\\Framework\\CLI\\ConsoleColors;\nuse Ephect\\Framework\\Commands\\AbstractCommandLib;\n\nclass Lib extends AbstractCommandLib\n{\n    public function remove(string $package, string $version): void\n    {\n\n        $binScript = \\Constants::SITE_ROOT . \"vendor/bin/\" . str_replace('/', '_', $package) . '_install.sh';\n        if (PHP_OS == 'WINNT') {\n            $binScript = \\Constants::SITE_ROOT . \"vendor\\\\bin\\\\\" . str_replace('/', '_', $package) . '_install.bat';\n        }\n\n        if (file_exists($binScript)) {\n            Console::writeLine(ConsoleColors::getColoredString(\"An remove script was found\", ConsoleColors::BLUE, ConsoleColors::WHITE));\n            if (Console::readYesOrNo(\"Do you want to run the script?\")) {\n                exec(\"$binScript -r\", $output, $returnCode);\n                if ($returnCode !== 0) {\n                    foreach ($output as $item) {\n                        Console::writeLine(ConsoleColors::getColoredString($item, ConsoleColors::RED, ConsoleColors::WHITE));\n                    }\n                } else {\n                    foreach ($output as $item) {\n                        Console::writeLine(ConsoleColors::getColoredString($item, ConsoleColors::BLUE, ConsoleColors::WHITE));\n                    }\n                }\n            }\n        }\n\n        $output = [];\n        exec(\"composer remove {$package} {$version}\", $output, $returnCode);\n        if ($returnCode !== 0) {\n            foreach ($output as $item) {\n                Console::writeLine(ConsoleColors::getColoredString($item, ConsoleColors::RED, ConsoleColors::WHITE));\n            }\n        } else {\n            foreach ($output as $item) {\n                Console::writeLine(ConsoleColors::getColoredString($item, ConsoleColors::BLUE, ConsoleColors::WHITE));\n            }\n        }\n\n    }\n\n}"}
{"instruction": "Write an Ephect command handler", "input": "Based on Ephect source: Main.php", "output": "<?php\n\nnamespace Ephect\\Commands\\ModuleRemove;\n\nuse Ephect\\Framework\\Commands\\AbstractCommand;\nuse Ephect\\Framework\\Commands\\Attributes\\CommandDeclaration;\n\n#[CommandDeclaration(verb: \"module\", subject: \"remove\")]\n#[CommandDeclaration(desc: \"Composer remove wrapper and more.\")]\nclass Main extends AbstractCommand\n{\n    public function run(): int\n    {\n        $package = $this->application->getArgi(2);\n        $version = $this->application->getArgi(3);\n\n        $lib = new Lib($this->application);\n        $lib->remove($package, $version);\n\n        return 0;\n    }\n}"}
{"instruction": "Write an Ephect command handler", "input": "Based on Ephect source: Lib.php", "output": "<?php\n\nnamespace Ephect\\Commands\\ModuleRequire;\n\nuse Ephect\\Framework\\CLI\\Console;\nuse Ephect\\Framework\\CLI\\ConsoleColors;\nuse Ephect\\Framework\\Commands\\AbstractCommandLib;\n\nclass Lib extends AbstractCommandLib\n{\n    public function require(string $package, string $version): void\n    {\n        exec(\"composer require {$package} {$version}\", $output, $returnCode);\n        if ($returnCode !== 0) {\n            if ($returnCode !== 0) {\n                foreach ($output as $item) {\n                    Console::writeLine(ConsoleColors::getColoredString($item, ConsoleColors::RED, ConsoleColors::WHITE));\n                }\n            } else {\n                foreach ($output as $item) {\n                    Console::writeLine(ConsoleColors::getColoredString($item, ConsoleColors::BLUE, ConsoleColors::WHITE));\n                }\n            }\n        }\n\n        $binScript = \\Constants::SITE_ROOT . \"vendor/bin/\" . str_replace('/', '_', $package) . '_install.sh';\n        if (PHP_OS == 'WINNT') {\n            $binScript = \\Constants::SITE_ROOT . \"vendor\\\\bin\\\\\" . str_replace('/', '_', $package) . '_install.bat';\n        }\n\n        $output = [];\n        if (file_exists($binScript)) {\n            Console::writeLine(ConsoleColors::getColoredString(\"An install script was found\", ConsoleColors::BLUE, ConsoleColors::WHITE));\n            if (Console::readYesOrNo(\"Do you want to run the script?\")) {\n                exec(\"$binScript\", $output, $returnCode);\n                if ($returnCode !== 0) {\n                    foreach ($output as $item) {\n                        Console::writeLine(ConsoleColors::getColoredString($item, ConsoleColors::RED, ConsoleColors::WHITE));\n                    }\n                } else {\n                    foreach ($output as $item) {\n                        Console::writeLine(ConsoleColors::getColoredString($item, ConsoleColors::BLUE, ConsoleColors::WHITE));\n                    }\n                }\n            }\n        }\n\n    }\n\n}"}
{"instruction": "Write an Ephect command handler", "input": "Based on Ephect source: Main.php", "output": "<?php\n\nnamespace Ephect\\Commands\\ModuleRequire;\n\nuse Ephect\\Framework\\Commands\\AbstractCommand;\nuse Ephect\\Framework\\Commands\\Attributes\\CommandDeclaration;\n\n#[CommandDeclaration(verb: \"module\", subject: \"require\")]\n#[CommandDeclaration(desc: \"Composer require wrapper and more.\")]\nclass Main extends AbstractCommand\n{\n    public function run(): int\n    {\n        $package = $this->application->getArgi(2);\n        $version = $this->application->getArgi(3);\n\n        $lib = new Lib($this->application);\n        $lib->require($package, $version);\n\n        return 0;\n    }\n}"}
{"instruction": "Write an Ephect command handler", "input": "Based on Ephect source: Lib.php", "output": "<?php\n\nnamespace Ephect\\Commands\\ModuleUpdate;\n\nuse Ephect\\Framework\\CLI\\Console;\nuse Ephect\\Framework\\CLI\\ConsoleColors;\nuse Ephect\\Framework\\Commands\\AbstractCommandLib;\nuse Ephect\\Framework\\Modules\\ModulesConfigReader;\n\nclass Lib extends AbstractCommandLib\n{\n    public function update(): void\n    {\n        $moduleConfigReader = new ModulesConfigReader();\n        $modulesConfig = $moduleConfigReader->read();\n        $modules = $modulesConfig->getModules();\n\n        foreach ($modules as $package => $version) {\n            exec(\"composer require {$package} {$version}\", $output, $returnCode);\n            Console::writeLine(ConsoleColors::getColoredString(\n                \"Installing $package $version\",\n                ConsoleColors::BLUE,\n                ConsoleColors::WHITE\n            ));\n\n            if ($returnCode !== 0) {\n                if ($returnCode !== 0) {\n                    foreach ($output as $item) {\n                        Console::writeLine(ConsoleColors::getColoredString(\n                            $item,\n                            ConsoleColors::RED,\n                            ConsoleColors::WHITE\n                        ));\n                    }\n                } else {\n                    foreach ($output as $item) {\n                        Console::writeLine(ConsoleColors::getColoredString(\n                            $item,\n                            ConsoleColors::BLUE,\n                            ConsoleColors::WHITE\n                        ));\n                    }\n                }\n            }\n\n            $binScript = \\Constants::SITE_ROOT . \"vendor/bin/\" . str_replace('/', '_', $package) . '_install.sh';\n            if (PHP_OS == 'WINNT') {\n                $binScript = \\Constants::SITE_ROOT . \"vendor\\\\bin\\\\\" . str_replace('/', '_', $package) . '_install.bat';\n            }\n\n            $output = [];\n            if (file_exists($binScript)) {\n                Console::writeLine(ConsoleColors::getColoredString(\n                    \"Running install script\",\n                    ConsoleColors::BLUE,\n                    ConsoleColors::WHITE\n                ));\n                exec(\"$binScript\", $output, $returnCode);\n                if ($returnCode !== 0) {\n                    foreach ($output as $item) {\n                        Console::writeLine(ConsoleColors::getColoredString(\n                            $item,\n                            ConsoleColors::RED,\n                            ConsoleColors::WHITE\n                        ));\n                    }\n                } else {\n                    foreach ($output as $item) {\n                        Console::writeLine(ConsoleColors::getColoredString(\n                            $item,\n                            ConsoleColors::BLUE,\n                            ConsoleColors::WHITE\n                        ));\n                    }\n                }\n            }\n        }\n    }\n}"}
{"instruction": "Write an Ephect command handler", "input": "Based on Ephect source: Main.php", "output": "<?php\n\nnamespace Ephect\\Commands\\ModuleUpdate;\n\nuse Ephect\\Framework\\Commands\\AbstractCommand;\nuse Ephect\\Framework\\Commands\\Attributes\\CommandDeclaration;\n\n#[CommandDeclaration(verb: \"module\", subject: \"update\")]\n#[CommandDeclaration(desc: \"Composer update wrapper and more.\")]\nclass Main extends AbstractCommand\n{\n    public function run(): int\n    {\n        $lib = new Lib($this->application);\n        $lib->update();\n\n        return 0;\n    }\n}"}
{"instruction": "Write an Ephect command handler", "input": "Based on Ephect source: Main.php", "output": "<?php\n\nnamespace Ephect\\Commands\\Name;\n\nuse Ephect\\Framework\\CLI\\Console;\nuse Ephect\\Framework\\Commands\\AbstractCommand;\nuse Ephect\\Framework\\Commands\\Attributes\\CommandDeclaration;\n\n#[CommandDeclaration(verb: \"name\")]\n#[CommandDeclaration(desc: \"Display the running application name.\")]\nclass Main extends AbstractCommand\n{\n    public function run(): int\n    {\n        $data = $this->application->getName();\n        Console::writeLine($data);\n\n        return 0;\n    }\n}"}
{"instruction": "Write an Ephect command handler", "input": "Based on Ephect source: Main.php", "output": "<?php\n\nnamespace Ephect\\Commands\\Os;\n\nuse Ephect\\Framework\\CLI\\Console;\nuse Ephect\\Framework\\Commands\\AbstractCommand;\nuse Ephect\\Framework\\Commands\\Attributes\\CommandDeclaration;\n\n#[CommandDeclaration(verb: \"os\")]\n#[CommandDeclaration(desc: \"Display the running operating system name.\")]\nclass Main extends AbstractCommand\n{\n    public function run(): int\n    {\n        $data = $this->application->getOS();\n        Console::writeLine($data);\n\n        return 0;\n    }\n}"}
{"instruction": "Write an Ephect command handler", "input": "Based on Ephect source: Lib.php", "output": "<?php\n\nnamespace Ephect\\Commands\\Serve;\n\nuse Ephect\\Commands\\CommonLib;\nuse Ephect\\Framework\\CLI\\Console;\nuse Ephect\\Framework\\CLI\\ConsoleColors;\nuse Ephect\\Framework\\CLI\\System\\Command;\nuse Ephect\\Framework\\Commands\\AbstractCommandLib;\nuse Ephect\\Framework\\Utils\\File;\n\nclass Lib extends AbstractCommandLib\n{\n    public function Serve(): void\n    {\n        $use = new CommonLib($this->parent);\n        $port = $this->getPort();\n\n        File::safeWrite(\\Constants::CONFIG_DIR . 'dev_port', $port);\n\n        $cmd = new Command();\n        $php = $cmd->which('php');\n\n        Console::writeLine('PHP is %s', ConsoleColors::getColoredString($php, ConsoleColors::RED));\n        Console::writeLine('Port is %s', ConsoleColors::getColoredString($port, ConsoleColors::RED));\n        $cmd->execute($php, '-S', \"localhost:$port\", '-t', \\Constants::CONFIG_DOCROOT);\n        Console::writeLine(\"Serving the application locally ...\");\n    }\n\n    public function getPort($default = 8000): int\n    {\n        $port = $default;\n\n        if ($this->parent->getArgc() > 2) {\n            $customPort = $this->parent->getArgi(2);\n\n            $cleanPort = preg_replace('/([\\d]+)/', '$1', $customPort);\n\n            if ($cleanPort !== $customPort) {\n                $customPort = $port;\n            }\n\n            $port = $customPort;\n        }\n\n        return $port;\n    }\n}"}
{"instruction": "Write an Ephect command handler", "input": "Based on Ephect source: Main.php", "output": "<?php\n\nnamespace Ephect\\Commands\\Serve;\n\nuse Ephect\\Framework\\Commands\\AbstractCommand;\nuse Ephect\\Framework\\Commands\\Attributes\\CommandDeclaration;\n\n#[CommandDeclaration(verb: \"serve\")]\n#[CommandDeclaration(desc: \"Launch PHP embedded server on available port starting from the one in config.\")]\nclass Main extends AbstractCommand\n{\n    public function run(): int\n    {\n        $lib = new Lib($this->application);\n        $lib->serve();\n\n        return 0;\n    }\n}"}
{"instruction": "Write an Ephect command handler", "input": "Based on Ephect source: Main.php", "output": "<?php\n\nnamespace Ephect\\Commands\\ShowApplicationTree;\n\nuse Ephect\\Commands\\CommonLib;\nuse Ephect\\Framework\\Commands\\AbstractCommand;\nuse Ephect\\Framework\\Commands\\Attributes\\CommandDeclaration;\n\n#[CommandDeclaration(verb: \"show\", subject: \"tree\")]\n#[CommandDeclaration(desc: \"Display the tree of the current application.\")]\nclass Main extends AbstractCommand\n{\n    public function run(): int\n    {\n        $use = new CommonLib($this->application);\n        $use->displayTree(\\Constants::APP_DIR);\n    }\n}"}
{"instruction": "Write an Ephect command handler", "input": "Based on Ephect source: Main.php", "output": "<?php\n\nnamespace Ephect\\Commands\\ShowArguments;\n\nuse Ephect\\Framework\\CLI\\Console;\nuse Ephect\\Framework\\Commands\\AbstractCommand;\nuse Ephect\\Framework\\Commands\\Attributes\\CommandDeclaration;\n\n#[CommandDeclaration(verb: \"show\", subject: \"arguments\")]\n#[CommandDeclaration(desc: \"Show the application arguments.\")]\nclass Main extends AbstractCommand\n{\n    public function run(): int\n    {\n        $data = ['argv' => $this->application->getArgv(), 'argc' => $this->application->getArgc()];\n        Console::writeLine($data);\n\n        return 0;\n    }\n}"}
{"instruction": "Write an Ephect command handler", "input": "Based on Ephect source: Main.php", "output": "<?php\n\nnamespace Ephect\\Commands\\ShowBranchTree;\n\nuse Ephect\\Commands\\CommonLib;\nuse Ephect\\Framework\\Commands\\AbstractCommand;\nuse Ephect\\Framework\\Commands\\Attributes\\CommandDeclaration;\n\n#[CommandDeclaration(verb: \"show\", subject: \"branch-tree\")]\n#[CommandDeclaration(desc: \"Display the tree of the Ephect\\Framework framework master branch.\")]\nclass Main extends AbstractCommand\n{\n    public function run(): int\n    {\n        $dir = 'master' . DIRECTORY_SEPARATOR . 'ephect-master' . DIRECTORY_SEPARATOR . 'src' . DIRECTORY_SEPARATOR . 'ephect';\n\n        $use = new CommonLib($this->application);\n        $use->displayTree($dir);\n\n        return 0;\n    }\n}"}
{"instruction": "Write an Ephect command handler", "input": "Based on Ephect source: Main.php", "output": "<?php\n\nnamespace Ephect\\Commands\\ShowConnections;\n\nuse Ephect\\Framework\\CLI\\Console;\nuse Ephect\\Framework\\Commands\\AbstractCommand;\nuse Ephect\\Framework\\Commands\\Attributes\\CommandDeclaration;\nuse Ephect\\Framework\\Registry\\StateRegistry;\n\n#[CommandDeclaration(verb: \"show\", subject: \"connections\")]\n#[CommandDeclaration(desc: \"Display the data connections registered.\")]\nclass Main extends AbstractCommand\n{\n    public function run(): int\n    {\n        $data = StateRegistry::item('connections');\n        Console::writeLine($data);\n\n        return 0;\n    }\n}"}
{"instruction": "Write an Ephect command handler", "input": "Based on Ephect source: Lib.php", "output": "<?php\n\nnamespace Ephect\\Commands\\ShowConstants;\n\nuse Ephect\\Framework\\CLI\\Console;\nuse Ephect\\Framework\\CLI\\ConsoleColors;\nuse Ephect\\Framework\\Commands\\AbstractCommandLib;\nuse Throwable;\n\nclass Lib extends AbstractCommandLib\n{\n    public function displayConstants(): array\n    {\n        try {\n            $constants = [];\n            $constants['APP_NAME'] = \\Constants::APP_NAME;\n            $constants['APP_CWD'] = \\Constants::APP_CWD;\n            $constants['SCRIPT_ROOT'] = \\Constants::SITE_ROOT;\n            $constants['SRC_ROOT'] = \\Constants::SRC_ROOT;\n            $constants['SITE_ROOT'] = \\Constants::SITE_ROOT;\n            $constants['IS_PHAR_APP'] = \\Constants::IS_PHAR_APP ? 'true' : 'false';\n            $constants['EPHECT_ROOT'] = \\Constants::EPHECT_ROOT;\n\n            // $constants['EPHECT_VENDOR_SRC'] = \\Constants::EPHECT_VENDOR_SRC;\n            // $constants['EPHECT_VENDOR_LIB'] = \\Constants::EPHECT_VENDOR_LIB;\n            // $constants['EPHECT_VENDOR_APPS'] = \\Constants::EPHECT_VENDOR_APPS;\n\n            if (\\Constants::APP_NAME !== 'use') {\n                $constants['APP_ROOT'] = \\Constants::APP_ROOT;\n                $constants['APP_SCRIPTS'] = \\Constants::APP_SCRIPTS;\n                $constants['APP_BUSINESS'] = \\Constants::APP_BUSINESS;\n                $constants['MODEL_ROOT'] = \\Constants::MODEL_ROOT;\n                $constants['VIEW_ROOT'] = \\Constants::VIEW_ROOT;\n                $constants['CONTROLLER_ROOT'] = \\Constants::CONTROLLER_ROOT;\n                $constants['REST_ROOT'] = \\Constants::REST_ROOT;\n                $constants['APP_DATA'] = \\Constants::APP_DATA;\n                $constants['CACHE_DIR'] = \\Constants::CACHE_DIR;\n            }\n            $constants['LOG_PATH'] = \\Constants::LOG_PATH;\n            $constants['DEBUG_LOG'] = \\Constants::DEBUG_LOG;\n            $constants['ERROR_LOG'] = \\Constants::ERROR_LOG;\n\n            Console::writeLine('Application constants are :');\n            foreach ($constants as $key => $value) {\n                Console::writeLine(\n                    ConsoleColors::getColoredString($key, ConsoleColors::CYAN)\n                    . ' => '\n                    . ConsoleColors::getColoredString($value, ConsoleColors::BLUE)\n                );\n            }\n\n            return $constants;\n        } catch (Throwable $ex) {\n            Console::error($ex);\n\n            return [];\n        }\n    }\n}"}
{"instruction": "Write an Ephect command handler", "input": "Based on Ephect source: Main.php", "output": "<?php\n\nnamespace Ephect\\Commands\\ShowConstants;\n\nuse Ephect\\Framework\\Commands\\AbstractCommand;\nuse Ephect\\Framework\\Commands\\Attributes\\CommandDeclaration;\n\n#[CommandDeclaration(verb: \"show\", subject: \"constants\")]\n#[CommandDeclaration(desc: \"Display the application constants.\")]\nclass Main extends AbstractCommand\n{\n    public function run(): int\n    {\n        $lib = new Lib($this->application);\n        $lib->displayConstants();\n\n        return 0;\n    }\n}"}
{"instruction": "Write an Ephect command handler", "input": "Based on Ephect source: Main.php", "output": "<?php\n\nnamespace Ephect\\Commands\\ShowDebug;\n\nuse Ephect\\Framework\\CLI\\Console;\nuse Ephect\\Framework\\Commands\\AbstractCommand;\nuse Ephect\\Framework\\Commands\\Attributes\\CommandDeclaration;\n\n#[CommandDeclaration(verb: \"show\", subject: \"debug\")]\n#[CommandDeclaration(desc: \"Display the debug log.\")]\nclass Main extends AbstractCommand\n{\n    public function run(): int\n    {\n        $data = $this->application->getDebugLog();\n        Console::writeLine($data);\n\n        return 0;\n    }\n}"}
{"instruction": "Write an Ephect command handler", "input": "Based on Ephect source: Main.php", "output": "<?php\n\nnamespace Ephect\\Commands\\ShowError;\n\nuse Ephect\\Framework\\CLI\\Console;\nuse Ephect\\Framework\\Commands\\AbstractCommand;\nuse Ephect\\Framework\\Commands\\Attributes\\CommandDeclaration;\n\n#[CommandDeclaration(verb: \"show\", subject: \"error\")]\n#[CommandDeclaration(desc: \"Display the php error log.\")]\nclass Main extends AbstractCommand\n{\n    public function run(): int\n    {\n        $data = $this->application->getPhpErrorLog();\n        Console::writeLine($data);\n\n        return 0;\n    }\n}"}
{"instruction": "Write an Ephect command handler", "input": "Based on Ephect source: Main.php", "output": "<?php\n\nnamespace Ephect\\Commands\\ShowIni;\n\nuse Ephect\\Framework\\CLI\\Console;\nuse Ephect\\Framework\\Commands\\AbstractCommand;\nuse Ephect\\Framework\\Commands\\Attributes\\CommandDeclaration;\nuse Ephect\\Framework\\Registry\\StateRegistry;\n\n#[CommandDeclaration(verb: \"show\", subject: \"ini\")]\n#[CommandDeclaration(desc: \"Display the ini file if exists\")]\nclass Main extends AbstractCommand\n{\n    public function run(): int\n    {\n        $this->application->loadInFile();\n        $data = StateRegistry::item('ini');\n        Console::writeLine($data);\n\n        return 0;\n    }\n}"}
{"instruction": "Write an Ephect command handler", "input": "Based on Ephect source: Main.php", "output": "<?php\n\nnamespace Ephect\\Commands\\Title;\n\nuse Ephect\\Framework\\CLI\\Console;\nuse Ephect\\Framework\\Commands\\AbstractCommand;\nuse Ephect\\Framework\\Commands\\Attributes\\CommandDeclaration;\n\n#[CommandDeclaration(verb: \"title\")]\n#[CommandDeclaration(desc: \"Display the running application title.\")]\nclass Main extends AbstractCommand\n{\n    public function run(): int\n    {\n        $data = $this->application->getTitle();\n        Console::writeLine($data);\n\n        return 0;\n    }\n}"}
{"instruction": "Write an Ephect command handler", "input": "Based on Ephect source: Lib.php", "output": "<?php\n\nnamespace Ephect\\Commands\\WatchApplication;\n\nuse Ephect\\Framework\\CLI\\FileSystem\\Watcher;\nuse Ephect\\Framework\\Commands\\AbstractCommandLib;\n\nclass Lib extends AbstractCommandLib\n{\n    public function watch(): void\n    {\n        $watcher = new Watcher();\n\n        $watcher->watch(\\Constants::SRC_ROOT, ['phtml', 'php']);\n    }\n}"}
{"instruction": "Write an Ephect command handler", "input": "Based on Ephect source: Main.php", "output": "<?php\n\nnamespace Ephect\\Commands\\WatchApplication;\n\nuse Ephect\\Framework\\Commands\\AbstractCommand;\nuse Ephect\\Framework\\Commands\\Attributes\\CommandDeclaration;\n\n#[CommandDeclaration(verb: \"watch\")]\n#[CommandDeclaration(desc: \"Watch the application.\")]\nclass Main extends AbstractCommand\n{\n    public function run(): int\n    {\n        $use = new Lib($this->application);\n        $use->watch();\n\n        return 0;\n    }\n}"}
